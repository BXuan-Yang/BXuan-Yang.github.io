(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{315:function(a,t,s){"use strict";s.r(t);var n=s(10),e=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"🚀java"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#🚀java"}},[a._v("#")]),a._v(" 🚀Java")]),a._v(" "),t("h2",{attrs:{id:"java基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java基础"}},[a._v("#")]),a._v(" Java基础")]),a._v(" "),t("h3",{attrs:{id:"面向对象和面向过程的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象和面向过程的区别"}},[a._v("#")]),a._v(" 面向对象和面向过程的区别？")]),a._v(" "),t("p",[a._v("两者的区别主要在于解决问题的方式不同：")]),a._v(" "),t("ul",[t("li",[a._v("面向过程：把解决问题的过程拆成一个又一个的方法，然后通过执行方法来解决问题")]),a._v(" "),t("li",[a._v("面向对象：抽出来对象，然后用对象执行方法的形式来解决问题")])]),a._v(" "),t("p",[a._v("面向对象开发的程序一般更易维护、易复用、易扩展。")]),a._v(" "),t("h3",{attrs:{id:"java-中如何创建对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-中如何创建对象"}},[a._v("#")]),a._v(" Java 中如何创建对象？")]),a._v(" "),t("p",[t("strong",[a._v("通过 new 运算符来创建")]),a._v("，new 运算创建对象实例（对象实例存储在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）")]),a._v(" "),t("p",[a._v("一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。")]),a._v(" "),t("h3",{attrs:{id:"jdk、jre与jvm的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk、jre与jvm的区别"}},[a._v("#")]),a._v(" JDK、JRE与JVM的区别")]),a._v(" "),t("ul",[t("li",[a._v("JDK 是 Java 的开发工具包，包含了编写、编译、调试和运行 Java 程序所需的所有工具和组件。JDK 是针对 Java 开发人员的，包含了 JRE，还有针对编译器以及其他的工具，可以用来编写和调试 Java 程序")]),a._v(" "),t("li",[a._v("JRE 是 Java 运行时环境，包括了 JVM 和 Java API。JRE 是针对 Java 应用程序的，提供了Java应用程序在计算机上运行的所需的最小环境。")]),a._v(" "),t("li",[a._v("JVM，Java虚拟机，是 Java 程序运行时的环境，负责将 Java 代码编译或者解释成本地机器代码，并在代码运行时提供必要的环境支持。（如内存管理、垃圾回收等）")])]),a._v(" "),t("h3",{attrs:{id:"什么是字节码-采用字节码的最大的好处是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是字节码-采用字节码的最大的好处是什么"}},[a._v("#")]),a._v(" 什么是字节码？采用字节码的最大的好处是什么？")]),a._v(" "),t("p",[a._v("字节码(.class 文件)是Java程序编译后的中间代码，是一种可移植的二进制代码，可以在任何支持JVM的平台运行。")]),a._v(" "),t("h3",{attrs:{id:"面向对象的三大特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的三大特征"}},[a._v("#")]),a._v(" 面向对象的三大特征")]),a._v(" "),t("h4",{attrs:{id:"封装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[a._v("#")]),a._v(" 封装")]),a._v(" "),t("p",[a._v("封装是指把一个对象的状态信息（属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Student")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    \n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" id"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//id属性私有化")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//name属性私有化")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//获取id的方法")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getId")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" id"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//设置id的方法")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("setId")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" id"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("id "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" id"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//获取name的方法")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getName")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//设置name的方法")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("setName")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n")])])]),t("h4",{attrs:{id:"继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[a._v("#")]),a._v(" 继承")]),a._v(" "),t("p",[a._v("不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。")]),a._v(" "),t("p",[a._v("继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。")]),a._v(" "),t("p",[t("strong",[a._v("关于继承有以下注意点")]),a._v("：")]),a._v(" "),t("ol",[t("li",[a._v("子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，"),t("strong",[a._v("只是拥有")]),a._v("。")]),a._v(" "),t("li",[a._v("子类可以拥有自己属性和方法，即子类可以对父类进行扩展。")]),a._v(" "),t("li",[a._v("子类可以用重载重新实现父类的方法。")])]),a._v(" "),t("h4",{attrs:{id:"多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[a._v("#")]),a._v(" 多态")]),a._v(" "),t("p",[a._v("多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。")]),a._v(" "),t("p",[a._v("多态的特点：")]),a._v(" "),t("ul",[t("li",[a._v("对象类型和引用类型之间具有继承（类）/实现（接口）的关系；")]),a._v(" "),t("li",[a._v("引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；")]),a._v(" "),t("li",[a._v("多态不能调用“只在子类存在但在父类不存在”的方法；")]),a._v(" "),t("li",[a._v("如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。")])]),a._v(" "),t("h3",{attrs:{id:"接口类和抽象类有什么共同点和区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口类和抽象类有什么共同点和区别"}},[a._v("#")]),a._v(" 接口类和抽象类有什么共同点和区别？")]),a._v(" "),t("h3",{attrs:{id:"和-equals-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#和-equals-的区别"}},[a._v("#")]),a._v(" == 和 equals 的区别")]),a._v(" "),t("p",[t("strong",[a._v("==")]),a._v(" 对于基本数据和引用数据类型效果是不一样的：")]),a._v(" "),t("ul",[t("li",[a._v("基本数据类型，== 比较的是值")]),a._v(" "),t("li",[a._v("引用数据类新，== 比较的是对象引用的内存地址")])]),a._v(" "),t("p",[a._v("因为 Java 只有值传递，所以对于 == 来说，不管是比较基本数据类型还是引用数据类型，本质都是比较值。只不过比较引用对象的时候比较的是内存地址的值。")]),a._v(" "),t("p",[t("strong",[a._v("equals()")]),a._v("：不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()：方法存在于 Object 类，而 Object 类是所有类的直接或者是间接的父类。因此所有的类都是有 equals() 方法。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("equals")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n     "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("equals() 方法存在两种使用情况：")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("类没有重写 "),t("code",[a._v("equals()")]),a._v("方法")]),a._v(" ：通过"),t("code",[a._v("equals()")]),a._v("比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 "),t("code",[a._v("Object")]),a._v("类"),t("code",[a._v("equals()")]),a._v("方法。")]),a._v(" "),t("li",[t("strong",[a._v("类重写了 "),t("code",[a._v("equals()")]),a._v("方法")]),a._v(" ：一般我们都重写 "),t("code",[a._v("equals()")]),a._v("方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。")])]),a._v(" "),t("h3",{attrs:{id:"hashcode-有什么用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashcode-有什么用"}},[a._v("#")]),a._v(" hashCode() 有什么用？")]),a._v(" "),t("p",[t("strong",[a._v("hashcode()")]),a._v(" 的作用是获取哈希码（"),t("code",[a._v("int")]),a._v(" 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。")]),a._v(" "),t("p",[t("code",[a._v("hashCode()")]),a._v("定义在 JDK 的 "),t("code",[a._v("Object")]),a._v(" 类中，这就意味着 Java 中的任何类都包含有 "),t("code",[a._v("hashCode()")]),a._v(" 函数。另外需要注意的是： "),t("code",[a._v("Object")]),a._v(" 的 "),t("code",[a._v("hashCode()")]),a._v(" 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("native")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("散列表存储的是键值对(key-value)，它的特点是："),t("strong",[a._v("能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以根据哈希码快速找到所需要的对象）")]),a._v("。")]),a._v(" "),t("h4",{attrs:{id:"为什么需要-hashcode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-hashcode"}},[a._v("#")]),a._v(" 为什么需要 hashcode()？")]),a._v(" "),t("p",[t("strong",[a._v("以 HashSet 为例子")]),a._v("：")]),a._v(" "),t("p",[a._v("当把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较。如果没有出现相符的 hashcode，那么就假设对象没有重复出现过。但是如果有出现相同的 hashcode 值的对象，这时候就会调用 equals() 方法来检查 hashcode 相等的对象是否真的是同一个对象。如果是同一个对象，HashSet 就不会让其加入操作成功，如果不是同一个对象的话，就会重新散列到其他位置。这样可以大大减少 equals 的次数，可以大大提高执行速度。")]),a._v(" "),t("p",[a._v("其实，hashcode() 和 equals() 都是用于比较两个对象是否相等。")]),a._v(" "),t("h4",{attrs:{id:"为什么-jdk-还要同时提供-hashcode-和-equals-这两种方法呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么-jdk-还要同时提供-hashcode-和-equals-这两种方法呢"}},[a._v("#")]),a._v(" 为什么 JDK 还要同时提供 hashcode() 和 equals() 这两种方法呢？")]),a._v(" "),t("p",[a._v("这是因为在一些容器（比如 "),t("code",[a._v("HashMap")]),a._v("、"),t("code",[a._v("HashSet")]),a._v("）中，有了 "),t("code",[a._v("hashCode()")]),a._v(" 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进"),t("code",[a._v("HashSet")]),a._v("的过程）！")]),a._v(" "),t("p",[a._v("我们在前面也提到了添加元素进"),t("code",[a._v("HashSet")]),a._v("的过程，如果 "),t("code",[a._v("HashSet")]),a._v(" 在对比的时候，同样的 "),t("code",[a._v("hashCode")]),a._v(" 有多个对象，它会继续使用 "),t("code",[a._v("equals()")]),a._v(" 来判断是否真的相同。也就是说 "),t("code",[a._v("hashCode")]),a._v(" 帮助我们大大缩小了查找成本。")]),a._v(" "),t("h4",{attrs:{id:"为什么不只提供-hashcode-方法呢-为什么两个对象有相同的-hashcode-值-它们也不一定是相等的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么不只提供-hashcode-方法呢-为什么两个对象有相同的-hashcode-值-它们也不一定是相等的"}},[a._v("#")]),a._v(" 为什么不只提供 hashcode() 方法呢？为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？")]),a._v(" "),t("p",[a._v("因为 "),t("code",[a._v("hashCode()")]),a._v(" 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 "),t("code",[a._v("hashCode")]),a._v(" )。")]),a._v(" "),t("p",[a._v("总结下来就是 ：")]),a._v(" "),t("ul",[t("li",[a._v("如果两个对象的"),t("code",[a._v("hashCode")]),a._v(" 值相等，那这两个对象不一定相等（哈希碰撞）。")]),a._v(" "),t("li",[a._v("如果两个对象的"),t("code",[a._v("hashCode")]),a._v(" 值相等并且"),t("code",[a._v("equals()")]),a._v("方法也返回 "),t("code",[a._v("true")]),a._v("，我们才认为这两个对象相等。")]),a._v(" "),t("li",[a._v("如果两个对象的"),t("code",[a._v("hashCode")]),a._v(" 值不相等，我们就可以直接认为这两个对象不相等。")])]),a._v(" "),t("h4",{attrs:{id:"为什么重写-equals-时必须重写-hashcode-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么重写-equals-时必须重写-hashcode-方法"}},[a._v("#")]),a._v(" 为什么重写 equals() 时必须重写 hashCode() 方法？")]),a._v(" "),t("p",[a._v("因为两个相等的对象的 "),t("code",[a._v("hashCode")]),a._v(" 值必须是相等。也就是说如果 "),t("code",[a._v("equals")]),a._v(" 方法判断两个对象是相等的，那前提是这两个对象的 "),t("code",[a._v("hashCode")]),a._v(" 值也要相等。")]),a._v(" "),t("p",[a._v("如果重写 "),t("code",[a._v("equals()")]),a._v(" 时没有重写 "),t("code",[a._v("hashCode()")]),a._v(" 方法的话就可能会导致 "),t("code",[a._v("equals")]),a._v(" 方法判断是相等的两个对象，"),t("code",[a._v("hashCode")]),a._v(" 值却不相等。")]),a._v(" "),t("p",[t("strong",[a._v("总结")]),a._v("：")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("equals")]),a._v(" 方法判断两个对象是相等的，那这两个对象的 "),t("code",[a._v("hashCode")]),a._v(" 值也要相等。")]),a._v(" "),t("li",[a._v("两个对象有相同的 "),t("code",[a._v("hashCode")]),a._v(" 值，他们也不一定是相等的（哈希碰撞）。")])]),a._v(" "),t("h3",{attrs:{id:"string"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[a._v("#")]),a._v(" String")]),a._v(" "),t("h4",{attrs:{id:"string、stringbuffer、stringbuilder-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string、stringbuffer、stringbuilder-有什么区别"}},[a._v("#")]),a._v(" String、StringBuffer、StringBuilder 有什么区别？")]),a._v(" "),t("ul",[t("li",[a._v("可变性")])]),a._v(" "),t("p",[a._v("String 是不可变的。")]),a._v(" "),t("p",[a._v("StringBuilder 和 StringBuffer 都继承自 "),t("code",[a._v("AbstractStringBuilder")]),a._v(" 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串。不过没有使用 final 和 "),t("code",[a._v("private")]),a._v(" 关键字修饰，最关键的是这个 "),t("code",[a._v("AbstractStringBuilder")]),a._v(" 类还提供了很多修改字符串的方法比如 "),t("code",[a._v("append")]),a._v(" 方法。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("abstract")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("AbstractStringBuilder")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Appendable")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("CharSequence")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("char")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("AbstractStringBuilder")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("append")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" str"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("str "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("appendNull")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" len "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" str"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("length")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("ensureCapacityInternal")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("count "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" len"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        str"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getChars")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" len"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" count"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        count "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" len"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  \t"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//...")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n")])])]),t("ul",[t("li",[a._v("线程安全性")])]),a._v(" "),t("p",[t("code",[a._v("String")]),a._v(" 中的对象是不可变的，也就可以理解为常量，线程安全。"),t("code",[a._v("AbstractStringBuilder")]),a._v(" 是 "),t("code",[a._v("StringBuilder")]),a._v(" 与 "),t("code",[a._v("StringBuffer")]),a._v(" 的公共父类，定义了一些字符串的基本操作，如 "),t("code",[a._v("expandCapacity")]),a._v("、"),t("code",[a._v("append")]),a._v("、"),t("code",[a._v("insert")]),a._v("、"),t("code",[a._v("indexOf")]),a._v(" 等公共方法。")]),a._v(" "),t("p",[t("code",[a._v("StringBuffer")]),a._v(" 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。")]),a._v(" "),t("p",[t("code",[a._v("StringBuilder")]),a._v(" 并没有对方法进行加同步锁，所以是非线程安全的。")]),a._v(" "),t("ul",[t("li",[a._v("性能")])]),a._v(" "),t("p",[a._v("每次对 "),t("code",[a._v("String")]),a._v(" 类型进行改变的时候，都会生成一个新的 "),t("code",[a._v("String")]),a._v(" 对象，然后将指针指向新的 "),t("code",[a._v("String")]),a._v(" 对象。"),t("code",[a._v("StringBuffer")]),a._v(" 每次都会对 "),t("code",[a._v("StringBuffer")]),a._v(" 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 "),t("code",[a._v("StringBuilder")]),a._v(" 相比使用 "),t("code",[a._v("StringBuffer")]),a._v(" 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。")]),a._v(" "),t("p",[t("strong",[a._v("总结")]),a._v("：")]),a._v(" "),t("ol",[t("li",[a._v("操作少量的数据: 适用 "),t("code",[a._v("String")])]),a._v(" "),t("li",[a._v("单线程操作字符串缓冲区下操作大量数据: 适用 "),t("code",[a._v("StringBuilder")])]),a._v(" "),t("li",[a._v("多线程操作字符串缓冲区下操作大量数据: 适用 "),t("code",[a._v("StringBuffer")])])]),a._v(" "),t("h2",{attrs:{id:"java集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java集合"}},[a._v("#")]),a._v(" Java集合")]),a._v(" "),t("h2",{attrs:{id:"jvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[a._v("#")]),a._v(" JVM")]),a._v(" "),t("h3",{attrs:{id:"对象分配-一般-new-出的对象都在堆上-什么时候会在栈上分配呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象分配-一般-new-出的对象都在堆上-什么时候会在栈上分配呢"}},[a._v("#")]),a._v(" 对象分配，一般 new 出的对象都在堆上，什么时候会在栈上分配呢？")]),a._v(" "),t("p",[t("strong",[a._v("当能够明确对象不会发生逃逸的时候，就可以对这个对象的内存分配做一个优化，不将其分配到堆上，而是直接分配到栈上")]),a._v("。这样在方法结束的时候，对象会随着方法的出栈而销毁，可以减少垃圾回收的压力。")]),a._v(" "),t("p",[a._v("逃逸分析，是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的 "),t("strong",[a._v("跨函数全局数据流分析算法")]),a._v("。通过逃逸分析，Java Hotspot 编辑器可以分析出一个新的对象的引用的适用范围从而决定是否要将这个对象分配到堆上。")]),a._v(" "),t("p",[a._v("在计算机语言编译器优化原理中，逃逸分析是指分析指针动态范围的方法，同编辑器优化原理的指针分析和外形分析相关联。")]),a._v(" "),t("p",[t("strong",[a._v("相关阅读")]),a._v("：")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/585697032",target:"_blank",rel:"noopener noreferrer"}},[a._v("new 对象的分配在堆而是栈上？"),t("OutboundLink")],1)]),a._v(" "),t("h3",{attrs:{id:"简述一下-java-对象分配的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简述一下-java-对象分配的过程"}},[a._v("#")]),a._v(" 简述一下 Java 对象分配的过程")]),a._v(" "),t("ol",[t("li",[a._v("编译器通过逃逸分析，确定对象是在栈上分配还是在 堆上分配。如果在栈上能进行分配，那就直接栈上分配。否则在堆上进行分配，则进入选项2；")]),a._v(" "),t("li",[a._v("如果 tlab_top + size <= tlab_end，则在 "),t("strong",[a._v("TLAB")]),a._v(" 上直接分配对象并增加 tlab_top 的值，如果现有的 TLAB 不足以进行存放，则重新申请一个 TLAB，并再次尝试存放当前的对象。如果放不下，则进入选项3；")]),a._v(" "),t("li",[a._v("在 Eden 区加锁（这个区是多线程共享的），如果 eden_top + size <= eden_end，则将存放在 "),t("strong",[a._v("Eden")]),a._v(" 区，增加 eden_top 的值，如果 eden 区不足以存放，则执行一次 Young GC（minor collection）")]),a._v(" "),t("li",[a._v("经过 Young GC 之后，如果 Eden 区任然不足以存放当前的对象，则直接分配到 "),t("strong",[a._v("老年代")]),a._v("。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/faedab64034f78f0eb505830211e8152b2191c54.jpeg@f_auto",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"标量和聚合量的定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标量和聚合量的定义"}},[a._v("#")]),a._v(" 标量和聚合量的定义？")]),a._v(" "),t("p",[t("strong",[a._v("标量")]),a._v("：即是不可被进一步分解的量，而 Java 中的基本数据类型就是标量（int、long 等基本数据类型以及 reference 类型等）")]),a._v(" "),t("p",[t("strong",[a._v("聚合量")]),a._v("：与标量对立，即是可以被进一步分解的量，在 Java 中对象就是可以被进一步分解的聚合量。")]),a._v(" "),t("h3",{attrs:{id:"string-s-hello-在内存中是什么样子的-堆栈中又是什么样子的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-s-hello-在内存中是什么样子的-堆栈中又是什么样子的"}},[a._v("#")]),a._v(' String s = "Hello"，在内存中是什么样子的？堆栈中又是什么样子的？')]),a._v(" "),t("p",[a._v("字符串是一种特殊的对象，它不存储在堆栈上，而是"),t("strong",[a._v("存储在字符串常量池")]),a._v("中，就算是字符串失去了所有的引用，也不会被垃圾处理器处理掉，所有的字符串都是唯一的独享，"),t("strong",[a._v("引用 s 则是存储在栈中")]),a._v("。")]),a._v(" "),t("h3",{attrs:{id:"string-s1-hello-和-string-s2-new-string-hello-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-s1-hello-和-string-s2-new-string-hello-有什么区别"}},[a._v("#")]),a._v(' String s1 = "hello" 和 String s2 = new String("hello"); 有什么区别？')]),a._v(" "),t("ul",[t("li",[a._v("单独使用 “ ” 创建的字符串都是属于常量，在编译期的时候就已经确定存储在 字符串常量池（String Pool） 中")]),a._v(" "),t("li",[a._v('使用 new String(" ") 创建的对象是会存储到 堆（heap） 中的，是在运行期新创建的，然后在方法区中的字符串常量池中创建了一个 "hello" 常量值，地址为 0x001；指向 new String()；\n'),t("ul",[t("li",[a._v('使用只包含常量的字符串连接符如"aa" + "aa"创建的也是常量,编译期就能确定,已经确定存储到字符串常量池中；')]),a._v(" "),t("li",[a._v('使用包含变量的字符串连接符如 "aa" + s1 创建的对象是在运行期的时候才创建的，存储在 heap 中；')])])])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/20200803201407924.png",alt:"img"}})]),a._v(" "),t("h3",{attrs:{id:"异常机制-什么时候会出现内存溢出、栈溢出、堆溢出"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异常机制-什么时候会出现内存溢出、栈溢出、堆溢出"}},[a._v("#")]),a._v(" 异常机制，什么时候会出现内存溢出、栈溢出、堆溢出")]),a._v(" "),t("p",[a._v("首先来了解一下 JVM 的内存模型")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230411145117145.png",alt:"image-20230411145117145"}})]),a._v(" "),t("p",[a._v("内存溢出主要有常见的以下几种情形：")]),a._v(" "),t("ol",[t("li",[a._v("栈内存溢出（StackOverflowError）")]),a._v(" "),t("li",[a._v("堆内存溢出（OutOfMemoryError：java heap space）")]),a._v(" "),t("li",[a._v("永久代内存溢出（OutOfMemoryError：java heap space）")])]),a._v(" "),t("h4",{attrs:{id:"_1、栈溢出"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、栈溢出"}},[a._v("#")]),a._v(" 1、栈溢出")]),a._v(" "),t("p",[a._v("栈内存可以分为 虚拟机栈（VM Stack）和 本地方法栈（Native Method Stack），除了它们分别用于执行Java方法（字节码）和本地方法，其余部分原理是类似的。")]),a._v(" "),t("p",[t("strong",[a._v("栈是线程私有的")]),a._v("，生命周期与线程相同，"),t("strong",[a._v("每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表、操作数栈、动态连接、方法出口等信息")]),a._v("。局部变量表又包含了基本数据类型、引用数据类型（局部变量表所需的内存空间在编译期间完成分配。每个方法都对应一个栈帧）。")]),a._v(" "),t("p",[a._v("所以我们可以理解为 栈溢出 就是方法执行的时候创建的栈帧超过了栈的最大深度，最可能的原因就是 方法递归调用 产生了此结果。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("JvmTest")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("a")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t\t"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("i"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t\t"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("a")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\t"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t\t"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("JvmTest")]),a._v(" j "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("JvmTest")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t\tj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("a")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("解决方法：我们需要使用参数 -Xss 去调整 JVM 栈的大小")]),a._v(" "),t("h4",{attrs:{id:"_2、堆溢出"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、堆溢出"}},[a._v("#")]),a._v(" 2、堆溢出")]),a._v(" "),t("p",[a._v("堆内存的唯一作用就是存放数组和对象实例，即通过 new 指令创建的对象，包括数组和引用类型。堆内存溢出又分为两种情况：")]),a._v(" "),t("ul",[t("li",[a._v("堆内存溢出：当堆中对象实例所占的内存空间超出了堆内存的最大容量，JVM就会抛出"),t("code",[a._v("OutOfMemoryError：java heap space")]),a._v("异常")]),a._v(" "),t("li",[a._v("堆内存泄漏：当堆中一些对象不再被引用但垃圾回收器无法识别时，这些未使用的对象就会在堆内存空间中无限期存在，不断的堆积就会造成内存泄漏")])]),a._v(" "),t("p",[a._v("heap space 表示堆空间，堆中主要存储的是对象。所以说如果在程序中不断 new 新的对象可能导致堆中的空间溢出")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("JvmTest")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("List")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ArrayList")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("try")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("add")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"test"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("catch")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Throwable")]),a._v(" e"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("size")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            e"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("printStackTrace")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("解决方法：")]),a._v(" "),t("ul",[t("li",[a._v("如果是因为堆内存空间太小，可以通过改变"),t("code",[a._v("-Xmx")]),a._v("来进行调整，或者分析程序中对象的生命周期和存储结构等信息进行调整；")]),a._v(" "),t("li",[a._v("如果发生了内存泄漏，则可以先找出导致泄漏发生的对象是如何被 GC ROOT 引用起来的，然后通过分析引用链找到发生泄漏的地方；")])]),a._v(" "),t("h4",{attrs:{id:"_3、永久代溢出"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、永久代溢出"}},[a._v("#")]),a._v(" 3、永久代溢出")]),a._v(" "),t("p",[a._v("由于JDK7、8移除永久带，所以上述代码在JDK1.6的情况中会出现永久带溢出（OutOfMemoryError: PermGen space）的现象。")]),a._v(" "),t("h3",{attrs:{id:"try-catch-finally中-catch里return-1-finally里return-2-最终是得到什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#try-catch-finally中-catch里return-1-finally里return-2-最终是得到什么"}},[a._v("#")]),a._v(" try catch finally中，catch里return 1 ，finally里return 2，最终是得到什么？")]),a._v(" "),t("h3",{attrs:{id:"finally有什么用途"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#finally有什么用途"}},[a._v("#")]),a._v(" finally有什么用途")]),a._v(" "),t("h3",{attrs:{id:"静态方法和实例方法的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态方法和实例方法的区别"}},[a._v("#")]),a._v(" 静态方法和实例方法的区别？")]),a._v(" "),t("h3",{attrs:{id:"error-和-exception-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#error-和-exception-的区别"}},[a._v("#")]),a._v(" Error 和 Exception 的区别")]),a._v(" "),t("h3",{attrs:{id:"arraylist-和-linkedlist-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arraylist-和-linkedlist-的区别"}},[a._v("#")]),a._v(" ArrayList 和 LinkedList 的区别？")]),a._v(" "),t("h3",{attrs:{id:"hashmap的put操作以及扩容机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的put操作以及扩容机制"}},[a._v("#")]),a._v(" HashMap的put操作以及扩容机制")]),a._v(" "),t("h3",{attrs:{id:"hashmap线程安全吗-有什么线程安全的集合-底层实现是什么样子的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap线程安全吗-有什么线程安全的集合-底层实现是什么样子的"}},[a._v("#")]),a._v(" HashMap线程安全吗？有什么线程安全的集合？底层实现是什么样子的？")]),a._v(" "),t("h3",{attrs:{id:"将一个对象作为-hashmap-的-key-需要实现什么操作-重写-hashcode-和-equals"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#将一个对象作为-hashmap-的-key-需要实现什么操作-重写-hashcode-和-equals"}},[a._v("#")]),a._v(" 将一个对象作为 HashMap 的 key，需要实现什么操作？（重写 hashcode() 和 equals()）")]),a._v(" "),t("h3",{attrs:{id:"list-和-set-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list-和-set-的区别"}},[a._v("#")]),a._v(" List 和 Set 的区别？")]),a._v(" "),t("h3",{attrs:{id:"set-可以是有序的吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set-可以是有序的吗"}},[a._v("#")]),a._v(" Set 可以是有序的吗？")]),a._v(" "),t("h3",{attrs:{id:"java-继承自-set-的子类有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-继承自-set-的子类有哪些"}},[a._v("#")]),a._v(" Java 继承自 Set 的子类有哪些？")]),a._v(" "),t("h3",{attrs:{id:"hashset-和-hashmap-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashset-和-hashmap-有什么区别"}},[a._v("#")]),a._v(" HashSet 和 HashMap 有什么区别？")]),a._v(" "),t("h3",{attrs:{id:"接口和抽象类的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口和抽象类的区别"}},[a._v("#")]),a._v(" 接口和抽象类的区别？")]),a._v(" "),t("h3",{attrs:{id:"面向对象的三大特性及多态的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的三大特性及多态的实现"}},[a._v("#")]),a._v(" 面向对象的三大特性及多态的实现？")]),a._v(" "),t("h3",{attrs:{id:"线程池用过吗-几个核心参数是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池用过吗-几个核心参数是什么"}},[a._v("#")]),a._v(" 线程池用过吗？几个核心参数是什么？")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230318224318411.png",alt:"image-20230318224318411"}})]),a._v(" "),t("ul",[t("li",[a._v("corePoolSize")]),a._v(" "),t("li",[a._v("maxmumPoolSize")]),a._v(" "),t("li",[a._v("keepAliveTime")]),a._v(" "),t("li",[a._v("TimeUnit")]),a._v(" "),t("li",[a._v("workQueue\n"),t("ul",[t("li",[a._v("ArrayBlockingQueue")]),a._v(" "),t("li",[a._v("LinkedBlickingQueue")]),a._v(" "),t("li",[a._v("SynchroniousQueue")]),a._v(" "),t("li",[a._v("PriorityBlockingQueue")])])]),a._v(" "),t("li",[a._v("ThreadFactory")]),a._v(" "),t("li",[a._v("RejectedExecutionHandler")])]),a._v(" "),t("h3",{attrs:{id:"任务到来时-线程池的工作流程是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任务到来时-线程池的工作流程是什么"}},[a._v("#")]),a._v(" 任务到来时，线程池的工作流程是什么？")]),a._v(" "),t("h3",{attrs:{id:"核心线程数是5-现在有4个核心线程-如果新来到一个任务-是利用空闲的线程还是创建新的线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心线程数是5-现在有4个核心线程-如果新来到一个任务-是利用空闲的线程还是创建新的线程"}},[a._v("#")]),a._v(" 核心线程数是5，现在有4个核心线程，如果新来到一个任务，是利用空闲的线程还是创建新的线程？")]),a._v(" "),t("h3",{attrs:{id:"什么时候用核心线程-什么时候要创建新的线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么时候用核心线程-什么时候要创建新的线程"}},[a._v("#")]),a._v(" 什么时候用核心线程，什么时候要创建新的线程？")]),a._v(" "),t("h3",{attrs:{id:"主线程-开启5个线程-让他们同时开始执行-主线程等它们两个执行完再结束-需要怎么实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主线程-开启5个线程-让他们同时开始执行-主线程等它们两个执行完再结束-需要怎么实现"}},[a._v("#")]),a._v(" 主线程，开启5个线程，让他们同时开始执行，主线程等它们两个执行完再结束，需要怎么实现？")]),a._v(" "),t("h3",{attrs:{id:"jvm-给对象分配内存的时候-会有多线程并发问题-怎么解决内存分配过程中的线程安全性呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm-给对象分配内存的时候-会有多线程并发问题-怎么解决内存分配过程中的线程安全性呢"}},[a._v("#")]),a._v(" JVM 给对象分配内存的时候，会有多线程并发问题，怎么解决内存分配过程中的线程安全性呢？")]),a._v(" "),t("h3",{attrs:{id:"java中有哪些机制能保证线程安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java中有哪些机制能保证线程安全"}},[a._v("#")]),a._v(" Java中有哪些机制能保证线程安全？")]),a._v(" "),t("h3",{attrs:{id:"synchronized-和-reentrantlock-的区别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-和-reentrantlock-的区别是什么"}},[a._v("#")]),a._v(" Synchronized 和 ReentrantLock 的区别是什么？")]),a._v(" "),t("h3",{attrs:{id:"简述一下cas算法以及它的优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简述一下cas算法以及它的优缺点"}},[a._v("#")]),a._v(" 简述一下CAS算法以及它的优缺点？")]),a._v(" "),t("h3",{attrs:{id:"在主线程中-new-一个异步线程-异步线程出现异常-主线程怎样才能-catch-到这些异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在主线程中-new-一个异步线程-异步线程出现异常-主线程怎样才能-catch-到这些异常"}},[a._v("#")]),a._v(" 在主线程中 new 一个异步线程，异步线程出现异常，主线程怎样才能 catch 到这些异常？")]),a._v(" "),t("h3",{attrs:{id:"怎么使用多线程-在什么场景使用-中间遇到了什么问题-怎么处理的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#怎么使用多线程-在什么场景使用-中间遇到了什么问题-怎么处理的"}},[a._v("#")]),a._v(" 怎么使用多线程，在什么场景使用，中间遇到了什么问题，怎么处理的？")]),a._v(" "),t("h3",{attrs:{id:"多线程数据同步有什么方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多线程数据同步有什么方法"}},[a._v("#")]),a._v(" 多线程数据同步有什么方法？")]),a._v(" "),t("h3",{attrs:{id:"简述-jvm-内存模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简述-jvm-内存模型"}},[a._v("#")]),a._v(" 简述 JVM 内存模型")]),a._v(" "),t("h3",{attrs:{id:"什么时候会触发垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么时候会触发垃圾回收机制"}},[a._v("#")]),a._v(" 什么时候会触发垃圾回收机制？")]),a._v(" "),t("h3",{attrs:{id:"双亲委派机制的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制的作用"}},[a._v("#")]),a._v(" 双亲委派机制的作用")]),a._v(" "),t("h3",{attrs:{id:"常见的-fullgc-场景有哪些-应该怎么避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的-fullgc-场景有哪些-应该怎么避免"}},[a._v("#")]),a._v(" 常见的 FullGC 场景有哪些？应该怎么避免？")]),a._v(" "),t("h3",{attrs:{id:"java-堆外内存是怎么回收的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-堆外内存是怎么回收的"}},[a._v("#")]),a._v(" Java 堆外内存是怎么回收的？")])])}),[],!1,null,null,null);t.default=e.exports}}]);