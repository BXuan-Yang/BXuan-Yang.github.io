(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{334:function(v,_,t){"use strict";t.r(_);var a=t(10),r=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"mysql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[v._v("#")]),v._v(" MySQL")]),v._v(" "),_("h2",{attrs:{id:"范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#范式"}},[v._v("#")]),v._v(" 范式")]),v._v(" "),_("h3",{attrs:{id:"范式的概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#范式的概念"}},[v._v("#")]),v._v(" 范式的概念")]),v._v(" "),_("p",[v._v("关系型数据库中，关于数据库表设计的基本原则或规则称为范式，范式是在设计数据库结构过程中需要遵循的规则和知道方法。")]),v._v(" "),_("ul",[_("li",[v._v("第一范式")]),v._v(" "),_("li",[v._v("第二范式")]),v._v(" "),_("li",[v._v("第三范式")]),v._v(" "),_("li",[v._v("巴斯·科德范式（BCNF）")]),v._v(" "),_("li",[v._v("第四范式")]),v._v(" "),_("li",[v._v("第五范式（完美范式）")])]),v._v(" "),_("p",[v._v("不过，有的时候为了提高某一些查询性能，我们还需要破坏范式规则，也就是反规范化。")]),v._v(" "),_("h3",{attrs:{id:"键的相关概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#键的相关概念"}},[v._v("#")]),v._v(" 键的相关概念")]),v._v(" "),_("ul",[_("li",[v._v("主键")])]),v._v(" "),_("p",[v._v("主键是表中的一个字段或多个字段，可以唯一标识一条纪录。主键是唯一的，不能为 null，用户可以从候选键中选择一个作为主键。")]),v._v(" "),_("ul",[_("li",[v._v("外键")])]),v._v(" "),_("p",[v._v("如果数据表 A 中的某个属性集不是 A 的主键，而是另外一个数据表 B 中的主键，那么这个属性集就是数据表 A 中的外键。")]),v._v(" "),_("ul",[_("li",[v._v("超键")])]),v._v(" "),_("p",[v._v("可以唯一标识元组的属性集叫做超键，超键可能包含主键和其他属性。")]),v._v(" "),_("ul",[_("li",[v._v("候选键")])]),v._v(" "),_("p",[v._v("如果超键不包括多余的属性，那么这个超键就是候选键，可以理解为最小的主键。")]),v._v(" "),_("ul",[_("li",[v._v("主属性")])]),v._v(" "),_("p",[v._v("包含在任何一个候选键上的属性叫做主属性。")]),v._v(" "),_("ul",[_("li",[v._v("非主属性")])]),v._v(" "),_("p",[v._v("指的是不包含在任何一个候选键中的属性。")]),v._v(" "),_("h3",{attrs:{id:"数据库三范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库三范式"}},[v._v("#")]),v._v(" 数据库三范式")]),v._v(" "),_("ul",[_("li",[v._v("第一范式：属性不可再分（"),_("strong",[v._v("保证原子性")]),v._v("）")]),v._v(" "),_("li",[v._v("第二范式：在第一范式的基础上，消除了非主属性对于码的部分函数依赖（"),_("strong",[v._v("消除部分依赖")]),v._v("）")]),v._v(" "),_("li",[v._v("第三范式：在第二范式的基础上，消除了非主属性对于码的传递函数依赖（"),_("strong",[v._v("消除传递依赖")]),v._v("）")])]),v._v(" "),_("h3",{attrs:{id:"第一范式-1nf"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一范式-1nf"}},[v._v("#")]),v._v(" 第一范式 1NF")]),v._v(" "),_("p",[v._v("属性（对应中表的字段）不能再被分割，每一列都是不可分割的原子数据项。也就是这个字段表示的只能是一个值，不能再分为多个其它的字段。1NF 是所有关系型数据库的最基本要求，也就是说关系型数据库中创建的表一定要满足第一范式。")]),v._v(" "),_("p",[v._v("eg：联系方式 =>（邮箱、联系电话）")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230408131216039.png",alt:"image-20230408131216039"}})]),v._v(" "),_("p",[v._v("根据第一范式，字段 CONTANT 联系方式可以划分为 邮箱和联系电话")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230408131327656.png",alt:"image-20230408131327656"}})]),v._v(" "),_("h3",{attrs:{id:"第二范式-2nf"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二范式-2nf"}},[v._v("#")]),v._v(" 第二范式 2NF")]),v._v(" "),_("p",[v._v("第二范式在第一范式的基础上，消除了非主属性对于码的部分函数依赖。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。")]),v._v(" "),_("p",[_("strong",[v._v("这里理解几个重要的概念")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("函数依赖")])])]),v._v(" "),_("p",[v._v("A–>B，如果通过 A 属性（属性组）的值，可以确定唯一的 B 属性的值，则称 B 依赖于 A")]),v._v(" "),_("p",[v._v("例如：学号----\x3e姓名 （学号、课程名称 的属性组）–> 分数")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("完全")]),v._v("函数依赖")])]),v._v(" "),_("p",[v._v("A–>B，如果 A 是一个属性组，则 B 属性值的确定需要依赖 A 属性组的中"),_("strong",[v._v("所有")]),v._v("的属性值")]),v._v(" "),_("p",[v._v("例如：（学号、课程名称）–> 分数：需要通过 学号+课程名称才能确定下来唯一的分数")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("部分")]),v._v("函数依赖")])]),v._v(" "),_("p",[v._v("A–>B，如果A是一个属性组，则 B 属性值的确定只需要依赖 A 属性组的中"),_("strong",[v._v("某一些")]),v._v("的属性值（第二范式就是消除这个）")]),v._v(" "),_("p",[v._v("例如：（学号 、课程名称）–> 姓名：姓名可以通过（学号 、课程名称）属性组中的学号得出")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("传递")]),v._v("函数依赖")])]),v._v(" "),_("p",[v._v("A – >B，B – >C，如果通过 A 属性（属性组）的值，可以确定唯一的 B 属性的值，再通过 B 属性（属性组）的值，可以唯一确定 C 属性的值，那么称 C "),_("strong",[v._v("传递依赖")]),v._v("于 A")]),v._v(" "),_("p",[v._v("例如： 学号 --\x3e 系名 ，系名 --\x3e 系主任")]),v._v(" "),_("ul",[_("li",[v._v("码")])]),v._v(" "),_("p",[v._v("如果在一张表中，一个属性或属性组，被其他所有的属性（非主属性）所完全函数依赖，则称这个属性（属性组）为该表的码。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230408131327656.png",alt:"image-20230408131327656"}})]),v._v(" "),_("p",[v._v("根据第二范式，可以发现通过 成绩Grade 依赖于 学生号STU_ID 和 课程号 COU_NO 才能唯一确定，所以可以将该表拆分成以下两表：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230408132908343.png",alt:"image-20230408132908343"}})]),v._v(" "),_("h3",{attrs:{id:"第三范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三范式"}},[v._v("#")]),v._v(" 第三范式")]),v._v(" "),_("p",[v._v("在第二范式的基础上，任何的非主属性不依赖于其他的非主属性（在第二范式基础上消除传递依赖）")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230408134120164.png",alt:"image-20230408134120164"}})]),v._v(" "),_("p",[v._v("例如： 学号 --\x3e 系名 ，系名 --\x3e 系主任")]),v._v(" "),_("p",[v._v("我们可以发现，在录入同一个系的学生的成绩时，系主任是一样的，即 学生号stu_id 确定 系stu_dept，系stu_dept 确定 系主任dean。存在传递函数依赖，所以在第三范式上删除；")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230408134149612.png",alt:"image-20230408134149612"}})]),v._v(" "),_("h3",{attrs:{id:"范式的优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#范式的优缺点"}},[v._v("#")]),v._v(" 范式的优缺点")]),v._v(" "),_("ul",[_("li",[v._v("优点：")])]),v._v(" "),_("p",[v._v("遵循范式（遵循数据的标准化）有助于消除数据库中的数据冗余。第三范式通常被认为在性能，扩展性和数据完整性方面达到了最好的平衡")]),v._v(" "),_("ul",[_("li",[v._v("缺点：")])]),v._v(" "),_("p",[v._v("降低了查询效率，因为范式等级越高，设计出来的表就越多，进行数据查询的时候就可能需要关联多张表，不仅代价昂贵，而且可能会使得一些索引失效。范式只是提出设计的标准，实际设计的时候，我们可能为了性能和读取效率违反范式的原则，通过增加少量的冗余或重复的数据来提高数据库的读取性能，减少关联查询，实现空间换时间的目的。")]),v._v(" "),_("h2",{attrs:{id:"索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[v._v("#")]),v._v(" 索引")]),v._v(" "),_("h3",{attrs:{id:"索引概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引概述"}},[v._v("#")]),v._v(" 索引概述")]),v._v(" "),_("p",[v._v("索引是一种数据结构，用于快速查询和检索数据的数据结构，本质上是排序好的。")]),v._v(" "),_("p",[v._v("常见的索引结构有：B 树、B+ 树、Hash、红黑树。")]),v._v(" "),_("h3",{attrs:{id:"索引优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引优缺点"}},[v._v("#")]),v._v(" 索引优缺点")]),v._v(" "),_("p",[v._v("优点：")]),v._v(" "),_("ul",[_("li",[v._v("使用索引可以大大加快 "),_("strong",[v._v("数据的检索速度")]),v._v("（大大减少检索的搜索量），这也是创建索引的主要原因")]),v._v(" "),_("li",[v._v("通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性")])]),v._v(" "),_("p",[v._v("缺点：")]),v._v(" "),_("ul",[_("li",[v._v("创建索引和维护索引需要耗费一定的时间。当表中的数据需要进行增删改的时候，如果数据有索引，索引也需要进行动态地修改，会减低 SQL 的执行效率")]),v._v(" "),_("li",[v._v("索引需要使用物理文件存储，也会耗费一定的空间")])]),v._v(" "),_("h3",{attrs:{id:"索引底层数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引底层数据结构"}},[v._v("#")]),v._v(" 索引底层数据结构")]),v._v(" "),_("h4",{attrs:{id:"hash-索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hash-索引"}},[v._v("#")]),v._v(" Hash 索引")]),v._v(" "),_("p",[v._v("哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。")]),v._v(" "),_("p",[_("strong",[v._v("为何能够通过 key 快速取出 value 呢？")])]),v._v(" "),_("p",[v._v("原因在于 "),_("strong",[v._v("哈希算法")]),v._v("（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。")]),v._v(" "),_("h4",{attrs:{id:"b-树-b-树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b-树-b-树"}},[v._v("#")]),v._v(" B 树 & B+ 树")]),v._v(" "),_("p",[v._v("B 树，也称为 B- 树，全称为 多路平衡查找树，B+ 树是 B 树的一种变体。B 树 和 B+ 树种的 B 是 Balanced 的意思。")]),v._v(" "),_("p",[_("strong",[v._v("B 树 和 B+ 树有什么异同呢？")])]),v._v(" "),_("ul",[_("li",[v._v("B 树的所有节点既存放 key，也存放 data。而 B+ 树只有叶子节点存放 key 和 data，其他内节点只存放 key")]),v._v(" "),_("li",[v._v("B 树的叶子节点都是独立的，B＋ 树的叶子节点有一条引用链指向与它乡邻的叶子节点")]),v._v(" "),_("li",[v._v("B 树的检索的过程相当于对范围内的每一个节点的关键字做二分查找，可能还没找到叶子节点，检索过程就结束了；B+ 树的检索过程就是从根节点找到叶子节点，叶子节点的顺序检索很明显")])]),v._v(" "),_("h3",{attrs:{id:"索引类型总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引类型总结"}},[v._v("#")]),v._v(" 索引类型总结")]),v._v(" "),_("p",[_("strong",[v._v("按照数据结构维度分")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("BTree 索引")]),v._v("：MySQL 默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 InnoDB 和 MyISAM 实现 BTree 索引都是使用的 B+ Tree，但是二者实现方式不一样")]),v._v(" "),_("li",[_("strong",[v._v("哈希索引")]),v._v("：类似键值对的结构，一次即可定位到数据")]),v._v(" "),_("li",[_("strong",[v._v("RTree 索引")]),v._v("：一般不使用，仅支持 geometry 数据类型，优势在于范围查找、效率较低，通常使用搜索引擎如 ES 代替")]),v._v(" "),_("li",[_("strong",[v._v("全文索引")]),v._v("：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR、TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ES 代替")])]),v._v(" "),_("p",[_("strong",[v._v("按照底层存储方式角度分")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("聚簇索引")]),v._v("（聚集索引）：索引结构和数据一起存放的索引，InnoDB 存储引擎中的主键索引就属于聚簇索引")]),v._v(" "),_("li",[_("strong",[v._v("非聚簇索引")]),v._v("（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引，MySQL 的 MyISAM 存储引擎，不管是主键还是非主键，使用的都是非聚簇索引。")])]),v._v(" "),_("p",[_("strong",[v._v("按照应用维度分")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("主键索引")]),v._v("：加速查询 + 列值唯一（不为 null）+ 一张表中只能有一个")]),v._v(" "),_("li",[_("strong",[v._v("普通索引")]),v._v("：加速查询")]),v._v(" "),_("li",[_("strong",[v._v("唯一索引")]),v._v("：加速查询 + 列值唯一（可为 null）")]),v._v(" "),_("li",[_("strong",[v._v("覆盖索引")]),v._v("：一个索引包含（覆盖）所有需要查询的字段")]),v._v(" "),_("li",[_("strong",[v._v("联合索引")]),v._v("：多列值组成一个索引，专门用于组合索引，其效率大于索引合并")]),v._v(" "),_("li",[_("strong",[v._v("全文索引")]),v._v("：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR、TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ES 代替")])]),v._v(" "),_("h3",{attrs:{id:"主键索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主键索引"}},[v._v("#")]),v._v(" 主键索引")]),v._v(" "),_("p",[v._v("数据库的主键列使用的就是主键索引。一张数据表中只能有一个主键，并且数据不能为 null，不能重复。")]),v._v(" "),_("p",[v._v("在 InnoDB 引擎存储的表中，如果没有显示地指定表的主键时，InnoDB 会自动检查表中是否有唯一索引并且不允许 null 值存在的字段，如果有，默认选择该字段作为主键索引。如果没有，InnoDB 会自动创建一个自增主键（6 byte）")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230409132409492.png",alt:"image-20230409132409492"}})]),v._v(" "),_("h3",{attrs:{id:"二级索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二级索引"}},[v._v("#")]),v._v(" 二级索引")]),v._v(" "),_("p",[v._v("二级索引又称为辅助索引，因为二级索引中的叶子节点存储的就是主键。也就是说可以通过二级索引，定位主键的位置。")]),v._v(" "),_("p",[v._v("唯一索引、普通索引、前缀索引等都属于二级索引")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("唯一索引(Unique Key)")]),v._v(" ：唯一索引也是一种约束。"),_("strong",[v._v("唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。")]),v._v(" 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。")]),v._v(" "),_("li",[_("strong",[v._v("普通索引(Index)")]),v._v(" ："),_("strong",[v._v("普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。")])]),v._v(" "),_("li",[_("strong",[v._v("前缀索引(Prefix)")]),v._v(" ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。")]),v._v(" "),_("li",[_("strong",[v._v("全文索引(Full Text)")]),v._v(" ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230409132811428.png",alt:"image-20230409132811428"}})]),v._v(" "),_("h3",{attrs:{id:"聚簇索引与非聚簇索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#聚簇索引与非聚簇索引"}},[v._v("#")]),v._v(" 聚簇索引与非聚簇索引")]),v._v(" "),_("p",[_("strong",[v._v("聚簇索引")]),v._v("：将数据存储与索引放在了一块，索引结构的叶子节点保存了行数据（InnoDB 主键就是聚簇索引）。")]),v._v(" "),_("p",[_("strong",[v._v("非聚簇索引")]),v._v("：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置（MyISAM 使用的都是非聚簇索引）。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/20190710211159462.png",alt:"img"}})]),v._v(" "),_("p",[v._v("非聚簇索引的叶子节点存储的是索引列的值，它的数据域是聚簇索引，即ID。聚簇索引叶子节点存储的是对应的数据，聚簇索引默认是主键。")]),v._v(" "),_("h2",{attrs:{id:"事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[v._v("#")]),v._v(" 事务")]),v._v(" "),_("h3",{attrs:{id:"什么是事务-什么是数据库事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是事务-什么是数据库事务"}},[v._v("#")]),v._v(" 什么是事务？什么是数据库事务？")]),v._v(" "),_("p",[_("strong",[v._v("事务")]),v._v("：事务是逻辑上的一组操作，要么都执行，要么都不执行。目的是为了保证数据的一致性。")]),v._v(" "),_("p",[_("strong",[v._v("数据库事务")]),v._v("：可以保证多个对数据库的操作构成一个逻辑上的整体")]),v._v(" "),_("p",[_("strong",[v._v("事务的特点")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("原子性")]),v._v(" "),_("li",[v._v("一致性")]),v._v(" "),_("li",[v._v("隔离性")]),v._v(" "),_("li",[v._v("持久性")])]),v._v(" "),_("h3",{attrs:{id:"事务想要做到什么效果"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务想要做到什么效果"}},[v._v("#")]),v._v(" 事务想要做到什么效果？")]),v._v(" "),_("p",[v._v("事务要做到的就是对于 "),_("strong",[v._v("数据的可靠性")]),v._v(" 以及 "),_("strong",[v._v("并发处理时候的安全性")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("可靠性")]),v._v("：数据库要保证 insert 或者 upadte 操作的时候抛异常或者数据库宕机的时候需要保证数据前后的一致性，于是就有了 undo log 和 redo log。")]),v._v(" "),_("p",[_("strong",[v._v("并发处理")]),v._v("：当多个并发请求过来的时候，如果全部都是读请求，那就不会对并发事务产生影响。但是加入其中有一个或者多个是对数据库中的数据进行修改操作的话，为了避免读到脏数据，就需要对事务之间的读写进行隔离，此时就需要用到 MySQL 的隔离级别。")]),v._v(" "),_("h3",{attrs:{id:"redo-log-与-undo-log-的介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redo-log-与-undo-log-的介绍"}},[v._v("#")]),v._v(" redo log 与 undo log 的介绍")]),v._v(" "),_("h4",{attrs:{id:"redo-log"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[v._v("#")]),v._v(" redo log")]),v._v(" "),_("p",[_("strong",[v._v("redo log概念")])]),v._v(" "),_("p",[v._v("redo log 称为重做日志，用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）和重做日志文件（redo log）。重做日志缓冲是存在于内存中，重做日志文件是存在于磁盘中。"),_("strong",[v._v("当事务提交之后，redo log 会记录所有的修改信息")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("redo log有什么作用？")])]),v._v(" "),_("p",[v._v("mysql 为了提升性能，不会讲每次的修改都实时地同步到磁盘中，而是会先存到 Buffer Pool（缓冲池）中，然后使用后台线程去做缓冲池和磁盘之间的同步。")]),v._v(" "),_("p",[v._v("假如，在这个时候修改信息已经存入到缓冲池中，但是 mysql 发生了宕机或者是断电，那么会发生什么？")]),v._v(" "),_("p",[v._v("如果没有 redo log，那么会直接丢失已经提交了事务的信息。但是此时引入了 redo log 来记录已成功提交的事务的修改数据信息，并且会将 redo log 文件持久化到磁盘，此时系统重启之后再次读取 redo log 就可以恢复新的数据。")]),v._v(" "),_("p",[_("strong",[v._v("总结")]),v._v("：redo log 是用来恢复数据的，用来保障已提交事务的持久化特性。")]),v._v(" "),_("h4",{attrs:{id:"undo-log"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#undo-log"}},[v._v("#")]),v._v(" undo log")]),v._v(" "),_("p",[_("strong",[v._v("undo log概念")])]),v._v(" "),_("p",[v._v("undo log 叫做回滚日志，用于记录数据被修改之前的信息，正好跟前面所说的重做日志所记录的相反。")]),v._v(" "),_("h3",{attrs:{id:"并发事务会带来哪些问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发事务会带来哪些问题"}},[v._v("#")]),v._v(" 并发事务会带来哪些问题？")]),v._v(" "),_("h4",{attrs:{id:"脏读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#脏读"}},[v._v("#")]),v._v(" 脏读")]),v._v(" "),_("p",[_("strong",[v._v("一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交")]),v._v("。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。")]),v._v(" "),_("h4",{attrs:{id:"丢失修改"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#丢失修改"}},[v._v("#")]),v._v(" 丢失修改")]),v._v(" "),_("p",[v._v("在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。")]),v._v(" "),_("h4",{attrs:{id:"不可重复读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不可重复读"}},[v._v("#")]),v._v(" 不可重复读")]),v._v(" "),_("p",[v._v("指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。"),_("strong",[v._v("这就发生了在一个事务内两次读到的数据是不一样的情况")]),v._v("，因此称为不可重复读。")]),v._v(" "),_("h4",{attrs:{id:"幻读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#幻读"}},[v._v("#")]),v._v(" 幻读")]),v._v(" "),_("p",[v._v("幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。")]),v._v(" "),_("h3",{attrs:{id:"事务的原子性是怎么实现的呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务的原子性是怎么实现的呢"}},[v._v("#")]),v._v(" 事务的原子性是怎么实现的呢？")]),v._v(" "),_("p",[v._v("MySQL 的事务原子性主要是通过 Undo Log（撤销日志）来实现的。")]),v._v(" "),_("p",[v._v("当进行一次事务操作的时候，MySQL 会首先在 Undo Log 中记录下事务操作前的数据状态。如果事务成功执行并提交，Undo Log 中的记录就可以被删除。但是如果在事务执行过程中出现错误，或者用户执行了 ROLLBACK 的操作，MySQL 就会利用 Undo Log 中的信息将数据恢复到事务开始前的状态，从而实现事务的原子性。")]),v._v(" "),_("p",[v._v("这就意味着，事务要么全部执行成功，要么不能执行成功，从而保证数据的一致性。")]),v._v(" "),_("h3",{attrs:{id:"事务的隔离性是怎么实现的呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务的隔离性是怎么实现的呢"}},[v._v("#")]),v._v(" 事务的隔离性是怎么实现的呢？")]),v._v(" "),_("p",[v._v("MySQL 的事务隔离性主要是通过锁机制和 MVCC（多版本并发控制）来实现。")]),v._v(" "),_("p",[v._v("1、锁机制：包括行锁和表锁。行锁可以精确到数据库中的某一行，而表锁则会锁定整个数据表。当一个事务在操作某个数据项时，会对其加锁，阻止其他事务对同一数据项的并发操作，从而实现隔离性。")]),v._v(" "),_("p",[v._v("2、多版本并发控制：这是 InnoDB 存储引擎特有的一种机制，它可以在不加锁的情况下创建数据在某一时间点的快照。在读取数据时，MVCC 会返回该时间点的数据版本，即使该数据后来被其他事务修改。这样，每个事务都有自己的数据视图，彼此之间不会互相影响，实现了隔离性。")]),v._v(" "),_("p",[v._v("MySQL 还提供四种隔离级别（读未提交、读已提交、可重复读、串行化）")]),v._v(" "),_("h3",{attrs:{id:"事务的一致性是怎么实现的呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务的一致性是怎么实现的呢"}},[v._v("#")]),v._v(" 事务的一致性是怎么实现的呢？")]),v._v(" "),_("p",[v._v("MySQL 实现事务一致性主要依赖其 InnoDB 存储引擎的 ACID 属性，其中 C 代表一致性。")]),v._v(" "),_("p",[v._v("1、使用锁机制：InnoDB 存储引擎支持行级锁和表级锁，通过锁机制来控制并发事务的访问冲突，确保每个事务都在一致性的状态下执行。")]),v._v(" "),_("p",[v._v("2、使用 MVCC：InnoDB 存储引擎通过 MVCC 来实现读已提交和可重复读两个隔离级别，确保事务的一致性视图，在事务开始时生成一个快照，事务在执行过程中看到的数据都是在这个快照中的数据。")]),v._v(" "),_("p",[v._v("3、使用 Undo 日志：InnoDB 存储引擎在修改数据前，会先将原始数据保存在 Undo 日志中，如果事务失败或者需要回滚，就可以利用 Undo 日志将数据恢复到原始状态，从而保证了数据的一致性。")]),v._v(" "),_("p",[v._v("4、使用 Redo 日志：Redo 日志用于保证事务的持久性，也间接保证了一致性。因为在系统崩溃需要恢复的时候，需要通过 Redo 日志来重做已提交的事务，保证这些事务的修改能够持久保存。")]),v._v(" "),_("h2",{attrs:{id:"myisam与innodb"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#myisam与innodb"}},[v._v("#")]),v._v(" MyISAM与InnoDB")]),v._v(" "),_("h3",{attrs:{id:"一、存储结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、存储结构"}},[v._v("#")]),v._v(" 一、存储结构")]),v._v(" "),_("p",[v._v("MyISAM：每个 MyISAM 在磁盘上存储成三个文件。分别为 表定义文件（.frm）、数据文件（.MYD）、索引文件（.MYI）。第一个文件的名字以表的名字开始，扩展名指出文件类型。")]),v._v(" "),_("p",[v._v("InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB 表的大小只受限于操作系统文件的大小，一般是 2GB")]),v._v(" "),_("h3",{attrs:{id:"二、存储空间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、存储空间"}},[v._v("#")]),v._v(" 二、存储空间")]),v._v(" "),_("p",[v._v("MyISAM：MyISAM 支持三种不同的存储格式：静态表（默认的存储方式，注意存储的数据末尾不能有空格，会被去掉）、动态表、压缩表。当表在创建并导入数据之后，不会再进行修改操作，可以使用压缩表来减少磁盘的空间占用")]),v._v(" "),_("p",[v._v("InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于告诉缓冲数据和索引")]),v._v(" "),_("h3",{attrs:{id:"三、可移植性、备份及恢复"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、可移植性、备份及恢复"}},[v._v("#")]),v._v(" 三、可移植性、备份及恢复")]),v._v(" "),_("p",[v._v("MyISAM：数据是以文件的形式存储的，所以在跨平台的数据转移中会很方便，在备份和恢复时可以单独针对某个表进行操作")]),v._v(" "),_("p",[v._v("InnoDB：免费的方案可以是拷贝数据文件、备份 binlog 或者使用 mysqldump，在数据量达到几十G的时候就很难操作。")])])}),[],!1,null,null,null);_.default=r.exports}}]);