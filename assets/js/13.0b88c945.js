(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{295:function(t,a,s){"use strict";s.r(a);var n=s(10),v=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"盘点常见的数据结构与算法基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#盘点常见的数据结构与算法基础"}},[t._v("#")]),t._v(" 盘点常见的数据结构与算法基础")]),t._v(" "),a("h2",{attrs:{id:"二叉树基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二叉树基础"}},[t._v("#")]),t._v(" 二叉树基础")]),t._v(" "),a("p",[a("strong",[t._v("1、二叉树的这种类")])]),t._v(" "),a("ul",[a("li",[t._v("满二叉树")]),t._v(" "),a("li",[t._v("完全二叉树")]),t._v(" "),a("li",[t._v("二叉搜索树")]),t._v(" "),a("li",[t._v("平衡二叉搜索树")])]),t._v(" "),a("p",[a("strong",[t._v("2、存储方式")])]),t._v(" "),a("ul",[a("li",[t._v("链式存储")]),t._v(" "),a("li",[t._v("线性存储")])]),t._v(" "),a("p",[a("strong",[t._v("3、遍历方式")])]),t._v(" "),a("ul",[a("li",[t._v("深度优先搜索（递归）\n"),a("ul",[a("li",[t._v("前序遍历")]),t._v(" "),a("li",[t._v("中序遍历")]),t._v(" "),a("li",[t._v("后序遍历")])])]),t._v(" "),a("li",[t._v("广度优先遍历\n"),a("ul",[a("li",[t._v("层序遍历（队列Queue）")])])])]),t._v(" "),a("p",[a("strong",[t._v("4、定义方式")])]),t._v(" "),a("h2",{attrs:{id:"回溯基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回溯基础"}},[t._v("#")]),t._v(" 回溯基础")]),t._v(" "),a("p",[t._v("回溯算法本质就是穷举，暴力搜索。")]),t._v(" "),a("p",[t._v("回溯算法一般能解决一下问题：")]),t._v(" "),a("ul",[a("li",[t._v("组合问题：N个数里面按一定规则找出k个数的集合")]),t._v(" "),a("li",[t._v("切割问题：一个字符串按一定规则有几种切割方式")]),t._v(" "),a("li",[t._v("子集问题：一个N个数的集合里有多少符合条件的子集")]),t._v(" "),a("li",[t._v("排列问题：N个数按一定规则全排列，有几种排列方式")]),t._v(" "),a("li",[t._v("棋盘问题：N皇后，解数独等等")])]),t._v(" "),a("p",[t._v("回溯法能解决的问题都是可以抽象为树形结构来解决的。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230323154201616.png",alt:"image-20230323154201616"}})]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("backTrack")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("参数"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("终止条件"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            添加到结果集中\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("选择：本层集合中元素（树中节点孩子的数量就是集合的大小）"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        处理节点"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtracking")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("路径，选择列表"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 递归")]),t._v("\n        回溯，撤销处理结果\n    \t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"贪心基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#贪心基础"}},[t._v("#")]),t._v(" 贪心基础")]),t._v(" "),a("p",[a("strong",[t._v("1、贪心基础")])]),t._v(" "),a("p",[t._v("贪心的本质就是从每一个阶段中选取最优解，从而达到全局最优解。")]),t._v(" "),a("p",[a("strong",[t._v("2、贪心解题步骤")])]),t._v(" "),a("ul",[a("li",[t._v("将问题分解为若干个子问题")]),t._v(" "),a("li",[t._v("找出适合的贪心策略")]),t._v(" "),a("li",[t._v("求解每一个子问题的最优解")]),t._v(" "),a("li",[t._v("将局部最优解堆叠成全局最优解")])]),t._v(" "),a("h2",{attrs:{id:"动态规划基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态规划基础"}},[t._v("#")]),t._v(" 动态规划基础")]),t._v(" "),a("p",[a("strong",[t._v("1、动态规划含义")])]),t._v(" "),a("p",[t._v("动态规划，简称 DP，如果某一个问题是有很多的重叠子问题的话，使用 DP 是最有效的。")]),t._v(" "),a("p",[t._v("动态规划中的每一个状态是从上一个状态推导出来的，区别于贪心，贪心是从局部最优中选出来的。")]),t._v(" "),a("p",[a("strong",[t._v("2、动态规划的解题步骤")])]),t._v(" "),a("ul",[a("li",[t._v("确定 dp 数组下标及含义")]),t._v(" "),a("li",[t._v("确定递推公式")]),t._v(" "),a("li",[t._v("dp数组初始化")]),t._v(" "),a("li",[t._v("遍历顺序")])]),t._v(" "),a("p",[a("strong",[t._v("3、如何进行 debug？")])]),t._v(" "),a("p",[t._v("打印 dp 数组进行查看")]),t._v(" "),a("h2",{attrs:{id:"背包问题基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背包问题基础"}},[t._v("#")]),t._v(" 背包问题基础")]),t._v(" "),a("p",[a("strong",[t._v("01 背包 & 完全背包")])]),t._v(" "),a("ul",[a("li",[t._v("01 背包：有 n 种物品，每种物品只有一个；")]),t._v(" "),a("li",[t._v("完全背包：有 n 种物品，每种物品有无数个；")])]),t._v(" "),a("p",[t._v("暴力搜索（回溯算法实现）")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("背包问题：")])]),t._v(" "),a("p",[t._v("① 背包的容量")]),t._v(" "),a("p",[t._v("② 物品的重量")]),t._v(" "),a("p",[t._v("③ 物品的价值")])]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("二维dp 数组的含义:")])]),t._v(" "),a("p",[t._v("dp[i] [j] 表示的是 [0, i] 物品任取然后放进容量为 j 的背包")]),t._v(" "),a("p",[t._v("1.不放物品i, 那么此时的 dp[i] [j] = dp[i - 1] [j]")]),t._v(" "),a("p",[t._v("2.放物品i, 那么此时的 dp[i] [j] = dp[i - weight[i]] [j] + value[i]")]),t._v(" "),a("p",[a("strong",[t._v("递推公式（状态转移方程）:")])]),t._v(" "),a("p",[t._v("dp[i] [j] = Math.max(dp[i - 1] [j], dp[i - weight[i]] [j] + value[i]);")]),t._v(" "),a("p",[a("strong",[t._v("dp数组初始化")])]),t._v(" "),a("p",[a("strong",[t._v("遍历顺序")]),t._v("(两层循环的遍历顺序是可以颠倒的)")]),t._v(" "),a("p",[t._v("// 物品")]),t._v(" "),a("p",[t._v("for ()")]),t._v(" "),a("p",[t._v("​\t// 重量")]),t._v(" "),a("p",[t._v("​\tfor ()")])]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("一维数组的含义")])]),t._v(" "),a("p",[t._v("dp[j]：表示容量为 j 的背包所能装下的最大的重量为 dp[j]")]),t._v(" "),a("p",[t._v("1.不放物品i，那么此时的 dp[j] = dp[j];")]),t._v(" "),a("p",[t._v("2.放物品i，那么此时的 dp[j] = dp[j - nums[i]] + value[i];")]),t._v(" "),a("p",[a("strong",[t._v("递推公式（状态转移方程）:")])]),t._v(" "),a("p",[t._v("dp[j] = max(dp[j], dp[j - nums[i]] + value[i]);")]),t._v(" "),a("p",[a("strong",[t._v("dp数组初始化")])]),t._v(" "),a("p",[t._v("全部初始化为0即可")]),t._v(" "),a("p",[a("strong",[t._v("遍历顺序")])]),t._v(" "),a("p",[t._v("// 物品")]),t._v(" "),a("p",[t._v("for ()")]),t._v(" "),a("p",[t._v("​\t// 重量，倒叙遍历是01，正序遍历是完全")]),t._v(" "),a("p",[t._v("​\tfor()")])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一维数组，01背包的遍历顺序")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" nums"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 物品")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" j "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" nmus"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 背包，每个物品只能放一次(倒序遍历)")]),t._v("\n        dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" nums"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("strong",[t._v("完全背包")])]),t._v(" "),a("blockquote",[a("p",[t._v("一维数组的含义")]),t._v(" "),a("p",[t._v("递推公式")]),t._v(" "),a("p",[t._v("dp 数组初始化")]),t._v(" "),a("p",[t._v("遍历顺序")])]),t._v(" "),a("h2",{attrs:{id:"前缀和-差分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前缀和-差分"}},[t._v("#")]),t._v(" 前缀和 & 差分")]),t._v(" "),a("h3",{attrs:{id:"前缀和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前缀和"}},[t._v("#")]),t._v(" 前缀和")]),t._v(" "),a("p",[t._v("定义：前缀和可以简单理解为【数列的前 n 项的和】，是一种重要的预处理方式，能大大降低查询的时间复杂度。")]),t._v(" "),a("h3",{attrs:{id:"二维-多维前缀和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二维-多维前缀和"}},[t._v("#")]),t._v(" 二维/多维前缀和")]),t._v(" "),a("p",[t._v("多维前缀和的普通求解方法几乎都是基于容斥原理")]),t._v(" "),a("p",[t._v("二维数组a：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1 2 4 3\n5 1 2 4\n6 3 5 9\n")])])]),a("p",[t._v("前缀和矩阵：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1  3  7  10\n6  9  15 22\n12 18 29 45\n")])])])])}),[],!1,null,null,null);a.default=v.exports}}]);