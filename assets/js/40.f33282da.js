(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{322:function(v,_,t){"use strict";t.r(_);var i=t(10),r=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"🚀开发框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#🚀开发框架"}},[v._v("#")]),v._v(" 🚀开发框架")]),v._v(" "),_("h2",{attrs:{id:"spring"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[v._v("#")]),v._v(" Spring")]),v._v(" "),_("h3",{attrs:{id:"什么是-spring-的依赖注入-依赖注入的基本原则以及好处"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-spring-的依赖注入-依赖注入的基本原则以及好处"}},[v._v("#")]),v._v(" 什么是 Spring 的依赖注入，依赖注入的基本原则以及好处？")]),v._v(" "),_("p",[v._v("依赖注入（Dependency Injection，简称DI）是 Spring 框架中的一种设计模式，用于实现控制反转（Inversion of Control，简称IoC）。它是一种将对象之间的依赖关系从硬编码中解耦的方法。通过依赖注入，Spring 框架可以在运行时自动为类的属性、构造函数或方法参数提供所需的依赖对象，从而实现对象之间的松耦合。")]),v._v(" "),_("p",[_("strong",[v._v("依赖注入的基本原则：")])]),v._v(" "),_("ol",[_("li",[v._v("高层模块不应该依赖低层模块。它们都应该依赖抽象。")]),v._v(" "),_("li",[v._v("抽象不应该依赖具体实现。具体实现应该依赖抽象。")])]),v._v(" "),_("p",[_("strong",[v._v("依赖注入的好处：")])]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("解耦")]),v._v("：依赖注入降低了组件之间的耦合度，使得组件可以独立地进行开发、测试和维护。通过将组件的创建和管理交给IoC容器，组件之间的依赖关系变得更加清晰，有助于提高代码的可维护性。")]),v._v(" "),_("li",[_("strong",[v._v("提高代码的可测试性")]),v._v("：依赖注入使得对组件进行单元测试变得更加容易。通过使用依赖注入，我们可以轻松地为组件提供模拟（Mock）的依赖对象，从而实现组件在隔离环境中的测试。")]),v._v(" "),_("li",[_("strong",[v._v("更好的代码重用")]),v._v("：由于组件之间的依赖关系变得更加清晰，这有助于提高代码的可重用性。组件可以在不同的上下文中重用，而无需对其进行修改。")]),v._v(" "),_("li",[_("strong",[v._v("更简洁的代码")]),v._v("：依赖注入使得代码更加简洁，因为组件不再需要直接处理依赖对象的创建和管理。这使得开发人员可以更加专注于组件的核心功能，从而提高开发效率。")]),v._v(" "),_("li",[_("strong",[v._v("更容易进行配置管理")]),v._v("：依赖注入允许我们将组件的配置与实现代码分离，从而使得配置管理变得更加容易。通过使用外部配置文件或注解，我们可以在不修改代码的情况下，调整组件之间的依赖关系。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230316085626065.png",alt:"image-20230316085626065"}})]),v._v(" "),_("h3",{attrs:{id:"spring-支持哪几种事务管理类型-spring-的事务实现方式和实现原理是"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-支持哪几种事务管理类型-spring-的事务实现方式和实现原理是"}},[v._v("#")]),v._v(" Spring 支持哪几种事务管理类型，Spring 的事务实现方式和实现原理是？")]),v._v(" "),_("p",[v._v("Spring 支持的事务管理类型包括：")]),v._v(" "),_("ol",[_("li",[v._v("编程式事务管理：在代码中显式地编写事务管理相关代码，如开启事务、提交事务、回滚事务等。")]),v._v(" "),_("li",[v._v("声明式事务管理：使用 AOP 技术，在代码中通过配置进行声明，从而实现对事务管理的控制。")]),v._v(" "),_("li",[v._v("注解式事务管理：基于声明式事务管理，使用注解的方式进行事务的管理。")])]),v._v(" "),_("p",[v._v("Spring 的事务实现方式采用了模板模式，通过模板模式实现了事务的封装。Spring 事务管理实现原理主要是通过 AOP 和代理模式来实现的。在使用声明式事务管理时，Spring 通过拦截器和代理对象来实现对方法调用的拦截和控制。当方法被调用时，Spring 会在方法调用前开启一个新的事务，如果方法执行成功，Spring 会提交事务，否则回滚事务。在使用注解式事务管理时，Spring 会扫描带有事务注解的方法，并在运行时使用动态代理为这些方法生成代理对象，在代理对象的方法调用前后进行事务管理的操作。")]),v._v(" "),_("h3",{attrs:{id:"讲一讲-spring-框架中-bean-的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#讲一讲-spring-框架中-bean-的生命周期"}},[v._v("#")]),v._v(" 讲一讲 Spring 框架中 Bean 的生命周期？")]),v._v(" "),_("p",[v._v("在 Spring 框架中，Bean 的生命周期包括以下几个阶段：")]),v._v(" "),_("ol",[_("li",[v._v("实例化（Instantiation）：在这个阶段，Spring 将根据配置文件或注解等方式创建 Bean 实例，并将其存储在容器中。")]),v._v(" "),_("li",[v._v("属性赋值（Populate Properties）：在这个阶段，Spring 将会自动将 Bean 的属性值从配置文件或注解等方式中注入到 Bean 实例中。")]),v._v(" "),_("li",[v._v("初始化（Initialization）：在这个阶段，Spring 会调用 Bean 实例的 init-method 方法，完成一些初始化的操作，例如建立数据库连接等。")]),v._v(" "),_("li",[v._v("使用（In Use）：在这个阶段，Bean 实例已经可以正常使用，供应用程序调用。")]),v._v(" "),_("li",[v._v("销毁（Destruction）：在这个阶段，Spring 会调用 Bean 实例的 destroy-method 方法，完成一些资源的释放和清理操作，例如关闭数据库连接等。")])]),v._v(" "),_("p",[v._v("具体的实现方式可以通过实现 BeanPostProcessor 和 BeanFactoryPostProcessor 接口来进行扩展。其中，BeanPostProcessor 接口定义了两个方法 postProcessBeforeInitialization 和 postProcessAfterInitialization，分别在 Bean 的初始化前后被调用，用于扩展 Bean 初始化的过程；BeanFactoryPostProcessor 接口则定义了一个方法 postProcessBeanFactory，用于在 Bean 工厂实例化 Bean 定义后对其进行修改。")]),v._v(" "),_("h3",{attrs:{id:"spring-中的-beanfactory-和-applicationcontext-有什么区别和联系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-中的-beanfactory-和-applicationcontext-有什么区别和联系"}},[v._v("#")]),v._v(" Spring 中的 BeanFactory 和 ApplicationContext 有什么区别和联系？")]),v._v(" "),_("h3",{attrs:{id:"什么是-aop-spring-aop-和-aspectj-aop-有什么区别-有哪些实现-aop-的方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-aop-spring-aop-和-aspectj-aop-有什么区别-有哪些实现-aop-的方式"}},[v._v("#")]),v._v(" 什么是 AOP？Spring AOP 和 AspectJ AOP 有什么区别？有哪些实现 AOP 的方式？")]),v._v(" "),_("p",[v._v("AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，它旨在解决软件开发中的横切关注点（cross-cutting concerns）问题。横切关注点是那些分布于多个模块或对象的功能，例如日志记录、安全检查、事务管理等。AOP通过将横切关注点与业务逻辑分离，从而提高了代码的模块化程度，使得开发更加简洁、易于维护。")]),v._v(" "),_("p",[v._v("Spring AOP和AspectJ AOP是两种不同的AOP实现。")]),v._v(" "),_("ol",[_("li",[v._v("Spring AOP：是Spring框架中的AOP实现，基于动态代理实现。Spring AOP主要用于解决Spring容器中Bean的横切关注点问题。由于它使用了动态代理，所以只支持方法级别的切面（即横切关注点只能织入方法的执行）。Spring AOP的性能略逊于AspectJ，但对于大部分应用来说，性能影响不大。")]),v._v(" "),_("li",[v._v("AspectJ AOP：是一个独立的、功能更强大的AOP实现，不仅支持方法级别的切面，还支持字段、构造器等其他切面。AspectJ可以通过编译时织入（编译时修改字节码）或加载时织入（在类加载时修改字节码）的方式实现AOP。Spring可以与AspectJ结合使用，以提供更强大的AOP功能。")])]),v._v(" "),_("p",[v._v("实现AOP的方式主要有以下几种：")]),v._v(" "),_("ol",[_("li",[v._v("动态代理：通过代理模式，为目标对象生成一个代理对象，然后在代理对象中实现横切关注点的织入。动态代理可以分为JDK动态代理（基于接口）和CGLIB动态代理（基于类）。")]),v._v(" "),_("li",[v._v("编译时织入：在编译阶段，通过修改字节码实现AOP。AspectJ的编译时织入就是这种方式。")]),v._v(" "),_("li",[v._v("类加载时织入：在类加载阶段，通过修改字节码实现AOP。AspectJ的加载时织入就是这种方式。")])]),v._v(" "),_("p",[v._v("AOP的实现方式取决于具体需求和技术选型。对于Spring应用来说，通常可以使用Spring AOP满足大部分需求，如果需要更强大的AOP功能，可以考虑使用AspectJ。")]),v._v(" "),_("h2",{attrs:{id:"分布式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式"}},[v._v("#")]),v._v(" 分布式")]),v._v(" "),_("h3",{attrs:{id:"什么是注册中心-如何实现一个注册中心"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是注册中心-如何实现一个注册中心"}},[v._v("#")]),v._v(" 什么是注册中心？如何实现一个注册中心？")]),v._v(" "),_("p",[v._v("注册中心（Service Registry）是微服务架构中的一个关键组件，负责管理服务实例的信息，包括服务实例的地址、端口、元数据等。它允许服务实例在启动时注册自己，并在关闭时注销。服务消费者可以通过查询注册中心来发现可用的服务提供者，并根据负载均衡策略选择合适的服务实例进行调用。")]),v._v(" "),_("p",[_("strong",[v._v("实现一个注册中心需要以下几个关键功能：")])]),v._v(" "),_("ol",[_("li",[v._v("服务注册：允许服务实例在启动时将自己的信息注册到注册中心，包括地址、端口、元数据等。")]),v._v(" "),_("li",[v._v("服务注销：允许服务实例在关闭时从注册中心注销自己。")]),v._v(" "),_("li",[v._v("服务发现：允许服务消费者查询可用的服务实例列表，以便找到合适的服务实例进行调用。")]),v._v(" "),_("li",[v._v("健康检查：注册中心需要定期检查已注册的服务实例的健康状况，以确保服务实例列表的准确性。如果发现某个服务实例不再可用，注册中心应将其从列表中移除。")])]),v._v(" "),_("p",[_("strong",[v._v("实现一个简单的注册中心可以参考以下步骤：")])]),v._v(" "),_("ol",[_("li",[v._v("选择一个合适的数据结构（例如哈希表）存储服务实例的信息。")]),v._v(" "),_("li",[v._v("实现一个HTTP API，允许服务实例在启动时向注册中心发送注册请求，将自己的信息添加到数据结构中。")]),v._v(" "),_("li",[v._v("实现一个HTTP API，允许服务实例在关闭时向注册中心发送注销请求，将自己的信息从数据结构中移除。")]),v._v(" "),_("li",[v._v("实现一个HTTP API，允许服务消费者查询可用的服务实例列表。")]),v._v(" "),_("li",[v._v("实现一个定时任务，定期检查已注册的服务实例的健康状况，如果发现某个服务实例不再可用，将其从数据结构中移除。")])]),v._v(" "),_("p",[v._v("然而，实现一个可靠、高性能、可扩展的注册中心是一个复杂的任务。在实际应用中，通常推荐使用现有的成熟的注册中心组件，例如Eureka、Consul、Zookeeper等。这些注册中心提供了丰富的功能，包括高可用性、数据持久化、动态配置等。")]),v._v(" "),_("h3",{attrs:{id:"有哪些主流的消息队列-它们分别有什么优缺点、各自的适用场景是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有哪些主流的消息队列-它们分别有什么优缺点、各自的适用场景是什么"}},[v._v("#")]),v._v(" 有哪些主流的消息队列，它们分别有什么优缺点、各自的适用场景是什么？")]),v._v(" "),_("p",[v._v("以下是几种主流的消息队列：")]),v._v(" "),_("ul",[_("li",[v._v("RabbitMQ\n"),_("ul",[_("li",[v._v("优点：可靠性高、性能优秀、支持多种协议、有完善的管理界面。")]),v._v(" "),_("li",[v._v("缺点：部署和维护较为复杂。")]),v._v(" "),_("li",[v._v("适用场景：适用于高可靠性、高吞吐量、多协议、多语言的分布式系统场景。")])])]),v._v(" "),_("li",[v._v("Kafka\n"),_("ul",[_("li",[v._v("优点：性能优秀、可扩展性好、可靠性高、支持多种数据处理模式。")]),v._v(" "),_("li",[v._v("缺点：管理界面不够完善、复杂度较高。")]),v._v(" "),_("li",[v._v("适用场景：适用于高吞吐量、高并发、数据处理流程复杂的场景，例如大数据处理、实时日志处理等。")])])]),v._v(" "),_("li",[v._v("ActiveMQ\n"),_("ul",[_("li",[v._v("优点：功能齐全、易于使用、支持多种协议。")]),v._v(" "),_("li",[v._v("缺点：性能相对较低、可靠性不如 RabbitMQ。")]),v._v(" "),_("li",[v._v("适用场景：适用于需要使用多种协议、支持多种消息类型的场景，例如 Web 服务、企业应用集成等。")])])]),v._v(" "),_("li",[v._v("RocketMQ\n"),_("ul",[_("li",[v._v("优点：性能优秀、可靠性高、支持海量数据存储和传输。")]),v._v(" "),_("li",[v._v("缺点：社区相对较小、功能不够完善。")]),v._v(" "),_("li",[v._v("适用场景：适用于海量数据存储和传输场景，例如电商、金融等领域。")])])]),v._v(" "),_("li",[v._v("Redis 优点：\n"),_("ul",[_("li",[v._v("速度极快、支持多种数据结构、支持事务操作、支持发布/订阅模式。")]),v._v(" "),_("li",[v._v("缺点：可靠性不如 RabbitMQ 和 Kafka。")]),v._v(" "),_("li",[v._v("适用场景：适用于对性能要求极高、需要使用多种数据结构和事务操作的场景，例如缓存、计数器、实时消息等。")])])])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("名称")]),v._v(" "),_("th",[v._v("优点")]),v._v(" "),_("th",[v._v("缺点")]),v._v(" "),_("th",[v._v("单机吞吐量")]),v._v(" "),_("th",[v._v("分布式")]),v._v(" "),_("th",[v._v("应用")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("ActiveMQ")]),v._v(" "),_("td",[v._v("时效性ms级，消息可靠性高")]),v._v(" "),_("td",[v._v("官方维护少、性能相对低")]),v._v(" "),_("td",[v._v("万级")]),v._v(" "),_("td"),v._v(" "),_("td",[v._v("Web服务器、企业应用集成 需要多种协议、多种消息类型的场景")])]),v._v(" "),_("tr",[_("td",[v._v("Kafka")]),v._v(" "),_("td",[v._v("不易丢失数据 支持多种数据处理模式")]),v._v(" "),_("td",[v._v("Load明显飙高，可能出现消息乱序 社区活跃度低")]),v._v(" "),_("td",[v._v("百万级")]),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("大数据、日志采集 高吞吐量、高并发、数据处理流程复杂的场景")])]),v._v(" "),_("tr",[_("td",[v._v("RocketMQ")]),v._v(" "),_("td",[_("strong",[v._v("消息零丢失")]),v._v(" 支持"),_("strong",[v._v("十亿级别消息堆积")])]),v._v(" "),_("td",[v._v("支持的客户端语言不多")]),v._v(" "),_("td",[v._v("十万级")]),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("金融互联网、秒杀 海量数据和传输场景")])]),v._v(" "),_("tr",[_("td",[v._v("RabbitMQ")]),v._v(" "),_("td",[_("strong",[v._v("高并发，支持多种语言")]),v._v(" 社区活跃度高")]),v._v(" "),_("td",[v._v("商业版收费")]),v._v(" "),_("td",[v._v("万级")]),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("数据量中小型 高可靠、多协议、多语言的分布式系统场景")])]),v._v(" "),_("tr",[_("td",[v._v("Redis")]),v._v(" "),_("td",[v._v("速度快、支持数据结构丰富、支持事务")]),v._v(" "),_("td",[v._v("可靠性不如RabbitMQ和Kafka")]),v._v(" "),_("td"),v._v(" "),_("td",[v._v("√")]),v._v(" "),_("td",[v._v("缓存、计数器、实时信息 对性能要求极高的场景")])])])]),v._v(" "),_("h3",{attrs:{id:"什么是-rpc-目前有哪些常见的-rpc-框架-实现-rpc-框架的核心原理是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-rpc-目前有哪些常见的-rpc-框架-实现-rpc-框架的核心原理是什么"}},[v._v("#")]),v._v(" 什么是 RPC？目前有哪些常见的 RPC 框架？实现 RPC 框架的核心原理是什么？")]),v._v(" "),_("p",[v._v("RPC（Remote Procedure Call）是一种远程调用协议，允许一台计算机通过网络调用另一台计算机上的服务或方法。它可以让开发人员像调用本地方法一样调用远程方法，将网络通信细节封装起来，提高了分布式系统中各个模块之间的耦合性。")]),v._v(" "),_("p",[v._v("目前常见的 RPC 框架有：")]),v._v(" "),_("ol",[_("li",[v._v("Dubbo：阿里巴巴开源的分布式 RPC 框架，支持多种协议和负载均衡策略。")]),v._v(" "),_("li",[v._v("gRPC：Google 开源的高性能 RPC 框架，支持多种语言。")]),v._v(" "),_("li",[v._v("Thrift：Facebook 开源的跨语言 RPC 框架，支持多种传输协议和数据编解码方式。")]),v._v(" "),_("li",[v._v("Spring Cloud Netflix：Spring Cloud 的子项目之一，提供了基于 Netflix OSS 开源组件的微服务解决方案，包括服务发现、负载均衡、熔断器等功能。")])]),v._v(" "),_("p",[v._v("RPC 框架的核心原理是基于网络传输协议实现的远程方法调用。RPC 框架通常由服务提供者和服务消费者两部分组成，服务提供者将本地方法暴露成远程服务，服务消费者通过远程代理对象调用远程方法。")]),v._v(" "),_("p",[v._v("在实现远程方法调用时，需要进行序列化和反序列化操作。序列化将对象转换为二进制数据流，以便于在网络中传输；反序列化则将接收到的二进制数据流转换为对象。")]),v._v(" "),_("p",[v._v("为了提高性能，一些 RPC 框架使用了二进制协议，如 Dubbo 使用的 Hessian2 协议和 gRPC 使用的 Protocol Buffers 协议，与基于文本的协议（如 XML 和 JSON）相比，二进制协议具有更小的传输体积和更高的解析速度，能够减少网络传输的开销。")]),v._v(" "),_("p",[v._v("RPC框架的核心原理是通过代理、序列化、网络传输、反序列化、反射等技术，实现远程过程调用的透明化。核心流程如下：")]),v._v(" "),_("ol",[_("li",[v._v("客户端通过代理对象（Proxy）调用远程服务，代理对象将调用信息（比如方法名、参数等）进行序列化（Serialzation），转换成字节流；")]),v._v(" "),_("li",[v._v("客户端通过网络传输（Transport）将序列化厚的字节流发送给服务端，服务端收到字节流后进行反序列化（Deserialization），还原成调用信息。")]),v._v(" "),_("li",[v._v("服务端通过反射（Reflection）根据调用信息找到对应的服务信息（Service）和方法（Method），并执行方法，得到返回结果。")]),v._v(" "),_("li",[v._v("服务端将返回结果进行序列化，转换成字节流，通过网络传输发送给客户端，客户端接收到字节流后，进行反序列化，还原成返回结果。")]),v._v(" "),_("li",[v._v("客户端通过代理对象返回结果给调用者，完成远程过程调用。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230316095920505.png",alt:"image-20230316095920505"}})]),v._v(" "),_("h3",{attrs:{id:"什么是分布式的-base-理论-与-cap-理论有什么联系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是分布式的-base-理论-与-cap-理论有什么联系"}},[v._v("#")]),v._v(" 什么是分布式的 BASE 理论，与 CAP 理论有什么联系？")]),v._v(" "),_("p",[_("strong",[v._v("BASE 理论")]),v._v("是分布式系统中用于描述数据一致性的一个概念。它是一个缩写，分别代表：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("基本可用（Basic Availability）")]),v._v("：分布式系统在出现故障时，依然能够保证系统的可用性，但可能会出现部分功能或性能降低的情况。")]),v._v(" "),_("li",[_("strong",[v._v("软状态（Soft State）")]),v._v("：由于分布式系统中各个节点的状态可能会有一定的延迟，系统允许在一定时间内存在数据不一致的情况。")]),v._v(" "),_("li",[_("strong",[v._v("最终一致性（Eventual Consistency）")]),v._v("：在一段时间内，分布式系统中的数据可能不一致，但最终会达到一致状态。这个过程可能需要一定的时间。")])]),v._v(" "),_("p",[_("strong",[v._v("CAP 理论")]),v._v("是另一个关于分布式系统的理论，它指出在分布式系统中，不能同时满足以下三个属性：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("一致性（Consistency）")]),v._v("：在分布式系统中的所有节点，在同一时刻具有相同的数据。")]),v._v(" "),_("li",[_("strong",[v._v("可用性（Availability）")]),v._v("：分布式系统在任何时刻都能对外提供服务，响应用户请求。")]),v._v(" "),_("li",[_("strong",[v._v("分区容错性（Partition Tolerance）")]),v._v("：分布式系统在遇到网络分区（部分节点之间通信中断）的情况下仍然能够正常运行。")])]),v._v(" "),_("p",[v._v("BASE 理论和 CAP 理论之间的关系是：BASE 理论实际上是对 CAP 理论的一种实践和解释。在 CAP 理论中，由于无法同时满足三个属性，因此在实际的分布式系统设计中，通常需要在一致性和可用性之间做出权衡。BASE 理论就是这种权衡的一种体现，它强调基本的可用性、软状态和最终一致性，而不是追求强一致性。在很多场景中，采用 BASE 理论能够带来更高的系统可用性和更好的性能表现。")])])}),[],!1,null,null,null);_.default=r.exports}}]);