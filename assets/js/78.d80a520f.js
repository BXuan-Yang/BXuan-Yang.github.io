(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{357:function(_,v,t){"use strict";t.r(v);var a=t(10),s=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"软件测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软件测试"}},[_._v("#")]),_._v(" 软件测试")]),_._v(" "),v("h2",{attrs:{id:"测试基础知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#测试基础知识"}},[_._v("#")]),_._v(" 测试基础知识")]),_._v(" "),v("h3",{attrs:{id:"一、测试流程概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、测试流程概述"}},[_._v("#")]),_._v(" 一、测试流程概述")]),_._v(" "),v("p",[_._v("软件测试流程包括：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("测试计划")]),_._v("：测试计划是根据 "),v("strong",[_._v("用户需求报告")]),_._v(" 中关于功能要求和性能指标的 规格说明书，定义相应的测试需求报告，使得随后所有的测试工作都围绕测试需求进行，同时适当选择测试内容，合理安排测试人员")]),_._v(" "),v("li",[v("strong",[_._v("测试设计")]),_._v("：测试设计是指将测试计划阶段制定的测试需求分解，细化为若干个可执行的测试过程，并为每个测试过程选择适当的测试用例")]),_._v(" "),v("li",[v("strong",[_._v("测试开发")]),_._v("：测试开发是指建立可重复使用的自动测试的过程")]),_._v(" "),v("li",[v("strong",[_._v("测试执行")]),_._v("：测试执行是指执行测试开发阶段建立的自动测试过程，一般有 单元测试、集成测试、确认测试 等步骤组成")]),_._v(" "),v("li",[v("strong",[_._v("测试评估")]),_._v("：测试评估是指结合量化的测试覆盖阈及缺陷跟踪报告，对应用软件的质量和开发团队的工作进度以及工作效率进行综合评价")])]),_._v(" "),v("p",[_._v("其中测试执行主要由以下步骤组成：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("单元测试")]),_._v("：通过对每个最小的软件模块进行测试，对源代码的每一个程序单元实行测试，来检查各个程序模块是否正确地实现了规定的功能，确保其能正常进行工作")]),_._v(" "),v("li",[v("strong",[_._v("集成测试")]),_._v("：对已测试过的模块进行组装集成，目的在于检验与软件设计相关的程序结构问题")]),_._v(" "),v("li",[v("strong",[_._v("确认测试")]),_._v("：检验软件是否满足需求规格说明中的功能和性能需求，确定软件配置完全、正确，并检验软件产品能否与实际运行环境中整个系统的其他部分协调工作")]),_._v(" "),v("li",[v("strong",[_._v("验收测试")]),_._v("：主要让用户对软件进行测试")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230330193851049.png",alt:"image-20230330193851049"}})]),_._v(" "),v("h3",{attrs:{id:"二、单元测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、单元测试"}},[_._v("#")]),_._v(" 二、单元测试")]),_._v(" "),v("h4",{attrs:{id:"_1、定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、定义"}},[_._v("#")]),_._v(" 1、定义")]),_._v(" "),v("p",[_._v("单元测试用于判断一小段代码的某个特定条件或场景下某个特定函数的行为，主要测试软件设计的最小单元在 "),v("strong",[_._v("语法、格式、逻辑")]),_._v(" 等方面的缺陷以及是否符合功能、性能等需求，程序的多个模块可以并行地进行单元测试工作")]),_._v(" "),v("h4",{attrs:{id:"_2、内容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、内容"}},[_._v("#")]),_._v(" 2、内容")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("模块接口测试")]),_._v("：通过对被测试模块的数据流进行测试，检查进出模块的数据是否正确，因此必须对模块接口，包括参数表、全程数据、文件输入输出操作进行测试")]),_._v(" "),v("li",[v("strong",[_._v("局部数据结构测试")]),_._v("：测试用例检查局部数据结构的完整性，如数据类型说明、初始化、缺省值等方面的问题")]),_._v(" "),v("li",[v("strong",[_._v("执行路径测试")]),_._v("：对模块中重要的路径进行测试，对基本执行路径和循环进行测试往往可以发现大量路径错误，测试用例必须能够发现由于计算错误、不正确的判断或不正常的控制流而产生的错误")]),_._v(" "),v("li",[v("strong",[_._v("错误处理测试")]),_._v("：检查模块的错误处理功能是否包含错误或者缺陷，例如，是否拒绝不合理的输入等")]),_._v(" "),v("li",[v("strong",[_._v("边界条件测试")]),_._v("：必须采用边界值分析方法来设计测试用例，测试在为限制数据处理而设定的边界处，测试模块是否能正常工作")])]),_._v(" "),v("h4",{attrs:{id:"_3、步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、步骤"}},[_._v("#")]),_._v(" 3、步骤")]),_._v(" "),v("p",[_._v("一般单元测试需要辅助模块去帮助完成测试，辅助模块分为两种：")]),_._v(" "),v("ul",[v("li",[_._v("驱动模块：用来模拟被测试模块的上一级模块，相当于被测模块的主程序，用于接收测试数据，并把这些数据传送给被测模块，启动被测模块并输出结果")]),_._v(" "),v("li",[_._v("桩模块：用来模拟被测试模块工作过程中所调用的模块")])]),_._v(" "),v("h3",{attrs:{id:"三、集成测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、集成测试"}},[_._v("#")]),_._v(" 三、集成测试")]),_._v(" "),v("h4",{attrs:{id:"_1、定义-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、定义-2"}},[_._v("#")]),_._v(" 1、定义")]),_._v(" "),v("p",[_._v("将经过单元测试的模块连接起来，组成所规定的软件系统的过程称为集成，集成测试就是针对这个过程，按模块之间的依赖接口的关系图进行测试。")]),_._v(" "),v("h4",{attrs:{id:"_2、任务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、任务"}},[_._v("#")]),_._v(" 2、任务")]),_._v(" "),v("p",[_._v("主要任务是解决如下问题：")]),_._v(" "),v("ul",[v("li",[_._v("将各模块连接起来，检查模块相互调")]),_._v(" "),v("li",[_._v("将各个子功能组合起来，检查能否到达预期要求的各项功能")]),_._v(" "),v("li",[_._v("一个模块的功能是否会对另一个模块的功能产生不利的影响")]),_._v(" "),v("li",[_._v("全局数据结构是否有问题")]),_._v(" "),v("li",[_._v("单个模块的误差积累起来，从而达到不可接受的程度")])]),_._v(" "),v("h4",{attrs:{id:"_3、方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、方法"}},[_._v("#")]),_._v(" 3、方法")]),_._v(" "),v("p",[_._v("集成测试的方法，包括：")]),_._v(" "),v("ul",[v("li",[_._v("非增量式集成测试方法")]),_._v(" "),v("li",[_._v("增量式集成测试方法")])]),_._v(" "),v("h2",{attrs:{id:"常用的测试方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用的测试方法"}},[_._v("#")]),_._v(" 常用的测试方法")]),_._v(" "),v("h3",{attrs:{id:"黑盒测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#黑盒测试"}},[_._v("#")]),_._v(" 黑盒测试")]),_._v(" "),v("h4",{attrs:{id:"概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[_._v("#")]),_._v(" 概念")]),_._v(" "),v("p",[_._v("又称 功能测试 或者 基于需求的测试")]),_._v(" "),v("h4",{attrs:{id:"主要测试方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主要测试方法"}},[_._v("#")]),_._v(" 主要测试方法")]),_._v(" "),v("p",[_._v("主要的测试方法有 "),v("strong",[_._v("边界值分析法、等价类划分法、错误推断法")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("边界值分析法")]),_._v("：根据经验，大多数问题发生在数据的边界值。使用该方法需要\n"),v("ul",[v("li",[_._v("确定测试单元输入信号的边界值")]),_._v(" "),v("li",[_._v("用 等于边界值、略小于边界值、略大于边界值 去编写测试用例进行测试")])])]),_._v(" "),v("li",[v("strong",[_._v("等价类划分法")]),_._v("：把输入信号地范围划分为若干个子集，在每个子集中选取有少量")]),_._v(" "),v("li",[v("strong",[_._v("错误推断法")]),_._v("：根据以往经验，某些场景或者工况容易产生问题，针对性地设置用例进行测试")])]),_._v(" "),v("p",[_._v("黑盒测试过程中 "),v("strong",[_._v("边界值分析法是必不可少的")]),_._v("，也是查找能力最强的。其次可以辅助使用 等价类划分法 编写一些用例。最后使用 错误推断法 补充一些用例。")]),_._v(" "),v("h4",{attrs:{id:"优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[_._v("#")]),_._v(" 优缺点")]),_._v(" "),v("p",[v("strong",[_._v("优点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("比较简单，不需要了解程序内部的代码及实现")]),_._v(" "),v("li",[_._v("从用户的角度出发，能很容易的知道用户需要用到哪些功能、会遇到哪些问题")]),_._v(" "),v("li",[_._v("做软件自动化测试的时候可能比较方便")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("不能覆盖所有的代码，覆盖率比较低，大概只能到总代码量的 30 %")]),_._v(" "),v("li",[_._v("自动化测试的复用性比较低")])]),_._v(" "),v("h3",{attrs:{id:"白盒测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#白盒测试"}},[_._v("#")]),_._v(" 白盒测试")]),_._v(" "),v("h4",{attrs:{id:"概念-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概念-2"}},[_._v("#")]),_._v(" 概念")]),_._v(" "),v("p",[_._v("又称 结构测试 或者 逻辑驱动测试。白盒测试又分为 静态 和 动态 两种。")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("静态")]),_._v("：是指不运行待测试的程序，通过代码检测、静态结构分析 等通过工程师的逻辑思维去检查代码是否存在问题的方法")]),_._v(" "),v("li",[v("strong",[_._v("动态")]),_._v("：是指运行待测试程序进行测试的方法的统称")])]),_._v(" "),v("p",[v("strong",[_._v("白盒测试的目的")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("对程序模块的所有独立的执行路径至少测试一次")]),_._v(" "),v("li",[_._v("对所有的逻辑判定，取 ”真“ 与 ”假“ 的两种情况都至少测试一次")]),_._v(" "),v("li",[_._v("在循环的边界和运行的界限内执行循环体")]),_._v(" "),v("li",[_._v("测试内部数据结构的有效性等")])]),_._v(" "),v("h4",{attrs:{id:"主要测试方法-覆盖方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主要测试方法-覆盖方法"}},[_._v("#")]),_._v(" 主要测试方法（覆盖方法）")]),_._v(" "),v("p",[v("strong",[_._v("覆盖率：")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("语句覆盖")]),_._v("：所有的 ”语句“ 都要覆盖一遍。就是设计若干个测试用例，运行被测程序，使得每一个执行语句至少执行一次")]),_._v(" "),v("li",[v("strong",[_._v("判定覆盖")]),_._v("：包含语句覆盖。每个判断 T、F 各一次。使设计的测试用例保证程序中 "),v("strong",[_._v("每个判断的每个取值分支都至少经历一次")]),_._v("。")]),_._v(" "),v("li",[v("strong",[_._v("条件覆盖")]),_._v("：包含语句覆盖。每个条件 T、F 各一次是指选择足够的测试用例，使得运行这些测试用例时，判定中 "),v("strong",[_._v("每个条件的所有可能结果至少出现一次")]),_._v("，但未必能覆盖全部分支。")]),_._v(" "),v("li",[v("strong",[_._v("判定条件覆盖")]),_._v("：包含判定覆盖、条件覆盖。说白了就是我们设计的测试用例可以使得判断中 "),v("strong",[_._v("每个条件的所有的可能取值至少执行一次")]),_._v("（条件覆盖），同时 "),v("strong",[_._v("每个判断本身所有的结果，也要至少执行一次")]),_._v("（判定覆盖）。判断条件覆盖同时满足了判定覆盖和条件覆盖，弥补了两者的不足，但是判定条件覆盖并未考虑条件的组合情况。")]),_._v(" "),v("li",[v("strong",[_._v("条件组合覆盖")]),_._v("：每个条件的每种组合。在白盒测试方法中，选择足够的测试用例，使得所有判定中 "),v("strong",[_._v("各个条件判断结果的所有组合至少出现一次")]),_._v("，满足这种覆盖标准称为条件组合覆盖。说白了就是我们设计的测试用例应该使得每个判定中的各种可能组合都至少出现一次。显然，满足条件组合覆盖则满足判定覆盖、条件覆盖和判定条件覆盖。")]),_._v(" "),v("li",[v("strong",[_._v("路径覆盖")]),_._v("：所有路径至少执行一次。")])]),_._v(" "),v("p",[_._v("语句覆盖 是在所有的测试方法中最弱的一种覆盖。")]),_._v(" "),v("p",[_._v("判定覆盖 和 条件覆盖 比 语句覆盖 强，满足 判定条件覆盖 的测试用例一定满足 语句覆盖、判定覆盖、条件覆盖。")]),_._v(" "),v("p",[_._v("路径覆盖 是比较强的一种覆盖方式，但是未必能考虑 判定条件结果的组合，并不能代替 条件覆盖 和 条件组合覆盖。")]),_._v(" "),v("h4",{attrs:{id:"优缺点-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优缺点-2"}},[_._v("#")]),_._v(" 优缺点")]),_._v(" "),v("p",[v("strong",[_._v("优点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("帮助软件测试人员增大代码的覆盖率")]),_._v(" "),v("li",[_._v("提高代码的质量，能发现代码中隐藏的问题")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("程序运行会有很多不同的路径，很难测试所有的运行路径")]),_._v(" "),v("li",[_._v("白盒测试基于代码，只能测试开发人员做的对不对，而不能知道设计的功能需求是否正确")]),_._v(" "),v("li",[_._v("系统比较庞大的话，白盒测试需要的测试开销可能会非常大")])]),_._v(" "),v("h3",{attrs:{id:"单元测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单元测试"}},[_._v("#")]),_._v(" 单元测试")]),_._v(" "),v("p",[_._v("在做单元测试的时候，覆盖度是衡量测试是否全面、是否可靠的关键指标。覆盖度 分为 语句覆盖、判定覆盖、条件覆盖、判定条件覆盖")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("语句覆盖")]),_._v("：设计测试用例，使得被测程序中的 "),v("strong",[_._v("每个语句都至少被执行一遍")]),_._v("。")]),_._v(" "),v("li",[v("strong",[_._v("判定覆盖")]),_._v("：又叫做分支覆盖，要求 "),v("strong",[_._v("程序中的每个判断的每个可能的结果都被执行一遍")]),_._v("，即每个判断的 T、F 结果都至少被执行一遍。")]),_._v(" "),v("li",[v("strong",[_._v("条件覆盖")]),_._v("：程序中每个判定的 "),v("strong",[_._v("每个条件的所有可能值都至少被执行一次")]),_._v("。")]),_._v(" "),v("li",[v("strong",[_._v("判定条件覆盖")]),_._v("：要求设计足够的测试用例，判定的 "),v("strong",[_._v("每个条件的所有可能必须出现至少一次（条件覆盖）")]),_._v("，并且 "),v("strong",[_._v("每个判定的每个条件要独立地影响判定结果（判定覆盖）")]),_._v("。")])]),_._v(" "),v("h3",{attrs:{id:"集成测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集成测试"}},[_._v("#")]),_._v(" 集成测试")]),_._v(" "),v("p",[_._v("介于 单元测试 和 系统测试 之间，验证检查各个模块接口是否能正常连接使用")]),_._v(" "),v("h3",{attrs:{id:"系统测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#系统测试"}},[_._v("#")]),_._v(" 系统测试")]),_._v(" "),v("p",[_._v("经过集成测试之后，进行功能测试以及接口测试、性能测试等等，将所有的功能都运行一遍，保证整个产品的质量")]),_._v(" "),v("h3",{attrs:{id:"验收测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#验收测试"}},[_._v("#")]),_._v(" 验收测试")]),_._v(" "),v("p",[_._v("系统测试全部通过后，由产品、开发等完成最终用户体验。分为 正式验收测试、alpha 测试、beta 测试。")]),_._v(" "),v("h3",{attrs:{id:"回归测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回归测试"}},[_._v("#")]),_._v(" 回归测试")]),_._v(" "),v("p",[_._v("针对修复过的 BUG，再进行一次测试，避免 BUG 的重复出现。")]),_._v(" "),v("h2",{attrs:{id:"遇到-bug-如何解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#遇到-bug-如何解决"}},[_._v("#")]),_._v(" 遇到 Bug 如何解决")]),_._v(" "),v("h3",{attrs:{id:"定位-bug-原因之前"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定位-bug-原因之前"}},[_._v("#")]),_._v(" 定位 Bug 原因之前")]),_._v(" "),v("p",[_._v("1、保存 bug 产生记录")]),_._v(" "),v("p",[_._v("2、排除低级的问题：如 hosts 不对、网络不通、工具影响等问题")]),_._v(" "),v("p",[_._v("3、排除数据类问题：脏数据导致脏读等")]),_._v(" "),v("h3",{attrs:{id:"定位问题思路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定位问题思路"}},[_._v("#")]),_._v(" 定位问题思路")]),_._v(" "),v("p",[v("strong",[_._v("排查问题的思路")]),_._v("：")]),_._v(" "),v("p",[_._v("用户环境层面 - 展示层面 - 逻辑控制层面 - 服务层面 - 数据库层面")]),_._v(" "),v("h4",{attrs:{id:"用户环境层面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户环境层面"}},[_._v("#")]),_._v(" 用户环境层面")]),_._v(" "),v("p",[_._v("主要指的是 基础环境是否可以使用。比如：")]),_._v(" "),v("ul",[v("li",[_._v("网络是否可以 ping 通")]),_._v(" "),v("li",[_._v("ip 和 端口设置是否正确")]),_._v(" "),v("li",[_._v("jdk 版本是否符合标准")]),_._v(" "),v("li",[_._v("网络是否设置了代理")]),_._v(" "),v("li",[_._v("测试环境是否切换了分支等")])]),_._v(" "),v("h4",{attrs:{id:"用户展示层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户展示层"}},[_._v("#")]),_._v(" 用户展示层")]),_._v(" "),v("p",[_._v("用户在使用过程中，通过查看等操作发现的一些问题：")]),_._v(" "),v("ul",[v("li",[_._v("页面样式")]),_._v(" "),v("li",[_._v("交互过程中的 js 提示")]),_._v(" "),v("li",[_._v("终端控制的提示信息")]),_._v(" "),v("li",[_._v("文版的展示是否正确")])]),_._v(" "),v("h4",{attrs:{id:"逻辑控制层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#逻辑控制层"}},[_._v("#")]),_._v(" 逻辑控制层")]),_._v(" "),v("p",[_._v("用户操作过程中，业务的处理逻辑有没有按照前期的设计实施。或者中间环节出现异常，比如缓存服务器（如redis）、消息中间件（如rabbitMQ）、数据存取中间件等。")]),_._v(" "),v("h4",{attrs:{id:"服务层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务层"}},[_._v("#")]),_._v(" 服务层")]),_._v(" "),v("p",[_._v("服务层往往检查服务器的配置，如可能是tomcat配置、nginx配置、jdbc配置等的问题。测试人员最好能够了解下它们的各项配置。")]),_._v(" "),v("h4",{attrs:{id:"数据库层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库层"}},[_._v("#")]),_._v(" 数据库层")]),_._v(" "),v("p",[_._v("可能出现测试环境和正式环境数据库版本不同，前后端数据格式、长度限制不同。用户操作完成后，交易流程非常顺畅，这样也不代表整个交易没有问题，还需要测试人员检查数据库登记的表和字段是否正确")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("如果发现登记的字段与预期的结果不一致，则可以查看日志，检查请求报文送的字段是否正确，是否与前台填写的一致")])]),_._v(" "),v("li",[v("p",[_._v("有的一个操作会登记多张表，所以要检查多张表登记或者更新的是否正确，测试人员也需要对被测系统的数据表结构熟悉")])])]),_._v(" "),v("h4",{attrs:{id:"经验法则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#经验法则"}},[_._v("#")]),_._v(" 经验法则")]),_._v(" "),v("p",[_._v("有经验的测试人员对于有部分bug已经见过多次，能够很快找到根源，直奔主题，迅速报告或者解决bug")]),_._v(" "),v("h3",{attrs:{id:"定位问题的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定位问题的方法"}},[_._v("#")]),_._v(" 定位问题的方法")]),_._v(" "),v("h4",{attrs:{id:"常用的定位策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用的定位策略"}},[_._v("#")]),_._v(" 常用的定位策略")]),_._v(" "),v("p",[_._v("常用的定位策略分为三类："),v("strong",[_._v("原始类")]),_._v("、"),v("strong",[_._v("回溯类")]),_._v("、"),v("strong",[_._v("排除类")])]),_._v(" "),v("ul",[v("li",[_._v("原始类定位方法")])]),_._v(" "),v("p",[_._v("原始类定位方法是最常用也是最低效的方法，只有在万般无奈的情况下才使用它，主要思想是“通过计算机找错”。")]),_._v(" "),v("ul",[v("li",[_._v("回溯法")])]),_._v(" "),v("p",[_._v("回溯法能成功地用于程序的排错。方法是从出现bug征兆处开始，人工地沿控制流程往回追踪，直至发现出错的根源，不幸的是程序变大后，可能的回溯路线显著增加，以致人工进行完全回溯到望而不可及。")]),_._v(" "),v("ul",[v("li",[_._v("排除法")])]),_._v(" "),v("p",[_._v("基于归纳和演绎原理，采用“分治”的概念。")]),_._v(" "),v("p",[_._v("首先确定所有与bug出现有关的所有数据，设想一个导致bug的原因，用这些数据证明或反驳它。或者一次列出所有可能的原因，通过测试一一排除。只要某次测试结果说明某种假设已呈现倪端，则立即精化数据，乘胜追击")]),_._v(" "),v("h4",{attrs:{id:"查看状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#查看状态码"}},[_._v("#")]),_._v(" 查看状态码")]),_._v(" "),v("p",[_._v("4xx 状态码：一般表示是客户端问题，")]),_._v(" "),v("h2",{attrs:{id:"bug-的生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bug-的生命周期"}},[_._v("#")]),_._v(" Bug 的生命周期")]),_._v(" "),v("p",[_._v("发现 bug -> 提交 bug -> 验证 bug")]),_._v(" "),v("h2",{attrs:{id:"软件测试的基本流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软件测试的基本流程"}},[_._v("#")]),_._v(" 软件测试的基本流程")]),_._v(" "),v("p",[v("strong",[_._v("基本测试流程")]),_._v("：")]),_._v(" "),v("p",[_._v("分析测试需求 - 制定测试计划 - 设计测试用例 - 执行测试 - 编写测试报告")]),_._v(" "),v("h3",{attrs:{id:"_1、分析测试需求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、分析测试需求"}},[_._v("#")]),_._v(" 1、分析测试需求")]),_._v(" "),v("p",[_._v("测试人员在制定测试计划之前需要先对软件需求进行分析，以便对要开发的软件产品有一个清晰的认识，从而明确测试对象以及测试工作的范围和测试重点。在分析需求时还可以获取一些测试数据，作为测试计划的基本依据，为后续的测试打好基础。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/46a72c90ac9fa0e04187a923f5034d33.png",alt:"img"}})]),_._v(" "),v("p",[_._v("测试需求分析其实也是对软件需求进行测试，测试人员可以发现软件需求中不合理的地方，如需求描述是否完整、准确无歧义，需求优先级安排是否合理等。测试人员一般会根据软件开发需求文档制作一个软件需求规格说明书检查列表，按照各个检查项对软件需求进行分析校验，如表所示。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230416220607345.png",alt:"image-20230416220607345"}})]),_._v(" "),v("p",[_._v('表列出了需要对软件需求进行什么样的检查，测试人员按照检查项逐条检查和判断，如果满足要求则选择 “是”，如果不满足要求则选择 “否”，如果某个检查项不适用则选择 “NA"。表只是一个通用的软件需求规格说明书检查列表，在实际测试中，要根据具体的测试项目进行适当的增减或修改。')]),_._v(" "),v("p",[_._v("在分析测试需求时要注意，被确定的测试需求必须是可核实的，测试需求必须有一个可观察、可评测的结果。无法核实的需求就不是测试需求。测试需求分析还要与客户进行交流，以澄清某些混淆，确保测试人员与客户尽早地对项目达成共识。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/a54765ad17ff539ab68a70ba1c151762.png",alt:"img"}})]),_._v(" "),v("h3",{attrs:{id:"_2、制定测试计划"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、制定测试计划"}},[_._v("#")]),_._v(" 2、制定测试计划")]),_._v(" "),v("p",[_._v("测试工作贯穿于整个软件开发生命周期，是一项庞大而复杂的工作，"),v("strong",[_._v("需要制订一个完整且详细的测试计划作为指导")]),_._v("。测试计划是整个测试工作的导航图，但它并不是一成不变的，随着项目推进或需求变更，测试计划也会不断发生改变，因此测试计划的制订是随着项目发展不断调整、逐步完善的过程。")]),_._v(" "),v("p",[_._v("测试计划一般要做好以下工作安排。")]),_._v(" "),v("p",[_._v("① "),v("strong",[_._v("确定测试范围")]),_._v("：明确哪些对象是需要测试的，哪些对象不是需要测试的。")]),_._v(" "),v("p",[_._v("②"),v("strong",[_._v("制订测试策略")]),_._v("：测试策略是测试计划中最重要的部分，它将要测试的内容划分出不同的优先级，并确定测试重点。根据测试模块的特点和测试类型(如功能测试、性能测试)选定测试环境和测试方法(如人工测试、自动化测试)。")]),_._v(" "),v("p",[_._v("③"),v("strong",[_._v("安排测试资源")]),_._v("：通过衡量测试难度、时间、工作量等因素对测试资源进行合理安排，包括人员分配、工具配置等。")]),_._v(" "),v("p",[_._v("④"),v("strong",[_._v("安排测试进度")]),_._v("：根据软件开发计划、产品的整体计划来安排测试工作的进度，同时还要考虑各部分工作的变化。在安排工作进度时，最好在各项测试工作之间预留一个缓冲时间以应对计划变更。")]),_._v(" "),v("p",[_._v("⑤"),v("strong",[_._v("预估测试风险")]),_._v("：罗列出测试工作过程中可能会出现的不确定因素，并制订应对策略。")]),_._v(" "),v("h3",{attrs:{id:"_3、设计测试用例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、设计测试用例"}},[_._v("#")]),_._v(" 3、设计测试用例")]),_._v(" "),v("p",[_._v("测试用例（Test Case）指的是一套详细的测试方案，包括 "),v("strong",[_._v("测试环境、测试步骤、测试数据和预期结果")]),_._v("。")]),_._v(" "),v("p",[v("strong",[_._v("测试用例编写的原则是尽量以最少的测试用例达到最大测试覆盖率")]),_._v("。测试用例常用的设计方法包括：等价类划分法、边界值分析法、因果图与判定表法、正交实验设计法、逻辑覆盖法等。")]),_._v(" "),v("h3",{attrs:{id:"_4、执行测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、执行测试"}},[_._v("#")]),_._v(" 4、执行测试")]),_._v(" "),v("p",[v("strong",[_._v("执行测试就是按照测试用例进行测试的过程")]),_._v("，这是测试人员最主要的活动阶段。在执行测试时要 "),v("strong",[_._v("根据测试用例的优先级进行")]),_._v("。测试执行过程看似简单，只要按照测试用例完成测试工作即可，但实则并不如此。测试用例的数目非常多，测试人员需要完成所有测试用例的执行，每一个测试用例都可能会发现很多缺陷，测试人员要做好测试记录与跟踪，衡量缺陷的质量并编写缺陷报告。")]),_._v(" "),v("p",[v("strong",[_._v("当提交后的缺陷被开发人员修改之后，测试人员需要进行回归测试")]),_._v("。如果系统对测试用例产生了缺陷免疫，测试人员则需要编写新的测试用例。在单元测试、集成测试、系统测试、验收测试各个阶段都要进行功能测试、性能测试等，这个工作量无疑是巨大的。除此之外，测试人员还需要对文档资料，如用户手册、安装手册、使用说明等进行测试。因此不要简单地认为执行测试就是按部就班地完成任务，可以说这个阶段是测试人员最重要的工作阶段。")]),_._v(" "),v("h3",{attrs:{id:"_5、编写测试报告"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、编写测试报告"}},[_._v("#")]),_._v(" 5、编写测试报告")]),_._v(" "),v("p",[_._v("测试报告是对一个测试活动的总结，对项目测试过程进行归纳，对测试数据进行统计，对项目的测试质量进行客观评价。不同公司的测试报告模板虽不相同，但测试报告的编写要点都是一样的，一般都是先对软件进行简单介绍，然后说明这份报告是对该产品的测试过程进行总结，对测试质量进行评价。")]),_._v(" "),v("p",[v("strong",[_._v("一份完整的测试报告必须包含以下几个要点。")])]),_._v(" "),v("ul",[v("li",[_._v("引言：描述测试报告编写目的、报告中出现的专业术语解释及参考资料等。")]),_._v(" "),v("li",[_._v("测试概要：介绍项目背景、测试时间、测试地点及测试人员等信息。")]),_._v(" "),v("li",[_._v("测试内容及执行情况：描述本次测试模块的版本、测试类型，使用的测试用例设计方法及测试通过覆盖率，依据测试的通过情况提供对测试执行过程的评估结论，并给出测试执行活动的改进建议，以供后续测试执行活动借鉴参考。")]),_._v(" "),v("li",[_._v("缺陷统计与分析：统计本次测试所发现的缺陷数目、类型等，分析缺陷产生的原因，给出规避措施等建议，同时还要记录残留缺陷与未解决问题。")]),_._v(" "),v("li",[_._v("测试结论与建议：从需求符合度、功能正确性、性能指标等多个维度对版本质量进行总体评价，给出具体明确的结论。")]),_._v(" "),v("li",[_._v("测试报告的数据是真实的，每一条结论的得出都要有评价依据，不能是主观臆想的。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/9c1d13266187e6b173dc8193e3ae3398.png",alt:"img"}})])])}),[],!1,null,null,null);v.default=s.exports}}]);