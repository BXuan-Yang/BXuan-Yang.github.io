(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{348:function(v,_,s){"use strict";s.r(_);var e=s(10),t=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"redis基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis基础"}},[v._v("#")]),v._v(" Redis基础")]),v._v(" "),_("p",[v._v("键值型数据库 -> NoSql")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20220428015948135.png",alt:"image-20220428015948135"}})]),v._v(" "),_("h2",{attrs:{id:"初识redis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#初识redis"}},[v._v("#")]),v._v(" 初识Redis")]),v._v(" "),_("h4",{attrs:{id:"认识nosql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#认识nosql"}},[v._v("#")]),v._v(" 认识NoSql")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("SQL")]),v._v("：关系型数据库")]),v._v(" "),_("ul",[_("li",[v._v("数据结构：结构化(Structured)")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20220504215333723.png",alt:"image-20220504215333723"}})]),v._v(" "),_("ul",[_("li",[v._v("数据关联：关联的")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20220504215516535.png",alt:"image-20220504215516535"}})]),v._v(" "),_("ul",[_("li",[v._v("查询方式：SQL查询")]),v._v(" "),_("li",[v._v("事务特性：ACID")]),v._v(" "),_("li",[v._v("存储方式：磁盘")]),v._v(" "),_("li",[v._v("扩展性：垂直")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("NoSql")]),v._v("：非关系型数据库")]),v._v(" "),_("ul",[_("li",[v._v("数据结构：非结构化\n"),_("ul",[_("li",[_("strong",[v._v("键值类型")]),v._v("：Redis")]),v._v(" "),_("li",[_("strong",[v._v("文档类型")]),v._v("：MongoDB")]),v._v(" "),_("li",[_("strong",[v._v("列类型")]),v._v("：HBase")]),v._v(" "),_("li",[_("strong",[v._v("Graph")]),v._v("类型：Neo4j")])])])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20220504215449571.png",alt:"image-20220504215449571"}})]),v._v(" "),_("ul",[_("li",[v._v("数据关联：非关联的")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20220504215614019.png",alt:"image-20220504215614019"}})]),v._v(" "),_("ul",[_("li",[v._v("查询方式：非SQL查询")]),v._v(" "),_("li",[v._v("事务特性： 基本一致，无事务 BASE")]),v._v(" "),_("li",[v._v("存储方式：内存")]),v._v(" "),_("li",[v._v("扩展性：水平")]),v._v(" "),_("li",[v._v("类型\n"),_("ul",[_("li",[v._v("键值型 Key-Value")]),v._v(" "),_("li",[v._v("Document文档型")]),v._v(" "),_("li",[v._v("Graph")])])])])])]),v._v(" "),_("p",[v._v("特征：")]),v._v(" "),_("ul",[_("li",[v._v("键值型(Key-value)：支持不同数据结构，功能丰富")]),v._v(" "),_("li",[v._v("单线程，每个命令具备原子性")]),v._v(" "),_("li",[v._v("低延迟，速度快("),_("strong",[v._v("基于内存")]),v._v("、IO多路复用、良好的编码)")]),v._v(" "),_("li",[v._v("支持数据持久化")]),v._v(" "),_("li",[v._v("支持主从集群、分片集群")]),v._v(" "),_("li",[v._v("多语言客户端")])]),v._v(" "),_("h3",{attrs:{id:"redis常见命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis常见命令"}},[v._v("#")]),v._v(" Redis常见命令")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Key-value的数据库")]),v._v(" "),_("ul",[_("li",[v._v("key一般是String类型，value的类型多种多样")]),v._v(" "),_("li",[_("strong",[v._v("String、Hash、List、Set、SortedSet")]),v._v("、(GEO、BitMap、HyperLog)")])])]),v._v(" "),_("li",[_("p",[v._v("Redis的通用命令（help keys 可查看命令的基本用法）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("KEYS：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("查看符合模板的所有key(类似模糊查询)")])]),v._v(" "),_("li",[_("div",{staticClass:"language-sql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("KEYS")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("*")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("KEYS")]),v._v(" a"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("*")]),v._v("\n")])])])]),v._v(" "),_("li",[_("p",[v._v("不建议在生产环境设备上使用")])])])]),v._v(" "),_("li",[_("p",[v._v("DEL：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("删除一个/多个指定的KEY")])]),v._v(" "),_("li",[_("div",{staticClass:"language-sql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[v._v("DEL k1 k2 k3\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("integer")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("3")]),v._v("\n")])])])])])]),v._v(" "),_("li",[_("p",[v._v("EXISTS：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("判断指定的KEY是否存在")])]),v._v(" "),_("li",[_("div",{staticClass:"language-sql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("EXISTS")]),v._v(" name\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("integer")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v("\n")])])])])])]),v._v(" "),_("li",[_("p",[v._v("EXPIRE：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("给KEY设置有效期，到期自动删除")])]),v._v(" "),_("li",[_("p",[v._v("eg：短信验证码")])]),v._v(" "),_("li",[_("div",{staticClass:"language-sql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[v._v("EXPIRE name "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("5")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("integer")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v("\n")])])])])])]),v._v(" "),_("li",[_("p",[v._v("TTL：")]),v._v(" "),_("ul",[_("li",[v._v("查看KEY有效期(-2 -> 已被移除，-1 -> 永久有效)")])])])])]),v._v(" "),_("li",[_("p",[v._v("String类型常见命令和基本用法")]),v._v(" "),_("ul",[_("li",[v._v("String常见的数据结构\n"),_("ul",[_("li",[v._v("String：普通字符串")]),v._v(" "),_("li",[v._v("int：整数类型，可自增、自减操作")]),v._v(" "),_("li",[v._v("float：浮点数类型，可自增、自减操作")]),v._v(" "),_("li",[v._v("不管是哪种格式，底层都是字节数组形式进行存储，只是编码方式不同，字符串类型的最大空间不能超过512m")])])]),v._v(" "),_("li",[v._v("String常见命令\n"),_("ul",[_("li",[v._v("SET：添加或者修改")]),v._v(" "),_("li",[v._v("GET：取出")]),v._v(" "),_("li",[v._v("MSET：批量添加")]),v._v(" "),_("li",[v._v("MGET：批量获取")]),v._v(" "),_("li",[v._v("INCR：自增")]),v._v(" "),_("li",[v._v("INCRBY：指定整型自增指定增长步长")]),v._v(" "),_("li",[v._v("INCRBYFLOAT：浮点数自增并指定增长步长")]),v._v(" "),_("li",[v._v("SETNX：添加String键值对。前提是不存在")]),v._v(" "),_("li",[v._v("SETEX：添加String键值对，并且指定有效期")])])])])]),v._v(" "),_("li",[_("p",[v._v("如何区分不同类型的KEY")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("KEY允许多个单词形成层级结构，单词之间用：隔开，格式如下：")])]),v._v(" "),_("li",[_("div",{staticClass:"language-sql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[v._v("项目名:业务名:类型:id\nBXuan:"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("user")]),v._v(":"),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v("\nBXuan:product:"),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v("\n")])])])])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20220505014117532.png",alt:"image-20220505014117532"}})])]),v._v(" "),_("li",[_("p",[v._v("Hash类型常见命令和基本用法")]),v._v(" "),_("ul",[_("li",[v._v("散列，value是一个无序字典，类似java中的HashMap")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20220505014620796.png",alt:"image-20220505014620796"}})]),v._v(" "),_("ul",[_("li",[v._v("Hash常见命令\n"),_("ul",[_("li",[v._v("HSET key field value：添加或者修改hash类型中的key的field的值")]),v._v(" "),_("li",[v._v("HGET key field：获取一个或者多个field的值")]),v._v(" "),_("li",[v._v("HMSET：批量添加多个hash类型key的field的值")]),v._v(" "),_("li",[v._v("HMGET：批量获取多个hash类型key的field的值")]),v._v(" "),_("li",[v._v("HGETALL：获取一个hash的key中所有的field的值")]),v._v(" "),_("li",[v._v("HKEYS：获取一个hash类型中key中的所有field")]),v._v(" "),_("li",[v._v("HVALS：获取一个hash类型中key中的所有value")]),v._v(" "),_("li",[v._v("HINCRBY：让一个hash类型key的字段值自增并指定步长")]),v._v(" "),_("li",[v._v("HSETNX：添加一个hash类型的key的field值，前提是这个field不存在")])])])])]),v._v(" "),_("li",[_("p",[v._v("List类型")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("特征（与java LinkedList相似）")]),v._v(" "),_("p",[v._v("有序、元素可重复、插入和删除快、查询速度一般、常用来存储有序序列")])]),v._v(" "),_("li",[_("p",[v._v("List常见命令")]),v._v(" "),_("ul",[_("li",[v._v("LPUSH key element：向列表左侧插入一个或者多个元素")]),v._v(" "),_("li",[v._v("LPOP key：移除并返回左侧的第一个元素，没有则返回nil")]),v._v(" "),_("li",[v._v("RPUSH key element：向列表的右侧插入一个或者多个元素")]),v._v(" "),_("li",[v._v("RPOP key：移除并返回右侧的第一个元素，没有则返回nil")]),v._v(" "),_("li",[v._v("LRANGE key star end：返回一段角标范围内的所有元素")]),v._v(" "),_("li",[v._v("BLPOP和BRPOP（阻塞式获取）：与上述LPOP及RPOP类似，只不过在没有元素时等待指定的时间，而不是直接返回nil")])])])])]),v._v(" "),_("li",[_("p",[v._v("Set类型")]),v._v(" "),_("ul",[_("li",[v._v("特征")])]),v._v(" "),_("p",[v._v("HashSet、无序、元素不可重复、查找快、支持交集、并集、差集等功能")]),v._v(" "),_("ul",[_("li",[v._v("Set常见命令\n"),_("ul",[_("li",[v._v("SADD key member：向set中添加一个或者多个元素")]),v._v(" "),_("li",[v._v("SREM key member：移除set中的元素")]),v._v(" "),_("li",[v._v("SCARD key：返回set中元素的个数")]),v._v(" "),_("li",[v._v("SISMEMBER key member：判断一个元素是否存在于set中")]),v._v(" "),_("li",[v._v("SMEMBERS：获取set中的所有元素")]),v._v(" "),_("li",[v._v("SINTER key1 key2：求key1与key2的交集")]),v._v(" "),_("li",[v._v("SDIFF key1 key2：求key1与key2的差集")]),v._v(" "),_("li",[v._v("SUNION key1 key2：求key1与key2的并集")])])])])]),v._v(" "),_("li",[_("p",[v._v("SortedSet类型")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("可排序集合")])]),v._v(" "),_("li",[_("p",[v._v("特征")]),v._v(" "),_("p",[v._v("可排序、元素不重复、查询速度快")])]),v._v(" "),_("li",[_("p",[v._v("SortedSet常见命令：")]),v._v(" "),_("ul",[_("li",[v._v("ZADD key member：添加一个或者多个元素，如果score存在就更新其值")]),v._v(" "),_("li",[v._v("ZREM key member：删除一个指定元素")]),v._v(" "),_("li",[v._v("ZSCORE key member：获取sorted set的指定元素的score值")]),v._v(" "),_("li",[v._v("SRANK key member：获取sorted set的指定元素的排名")]),v._v(" "),_("li",[v._v("ZCARD key：获取sorted set中的元素的个数")]),v._v(" "),_("li",[v._v("ZCOUNT key min max：统计score值在给定范围内的所有元素的个数")]),v._v(" "),_("li",[v._v("ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值")]),v._v(" "),_("li",[v._v("ZRANGE key min max：按照score排序后，获取指定排名范围内的元素")]),v._v(" "),_("li",[v._v("ZRANGEBYSCORE key min max：按照score排序后，获取指定的score范围内的元素")]),v._v(" "),_("li",[v._v("ZDIFF、ZINTER、ZUNION：求差集、交集、并集")])])])])])]),v._v(" "),_("h3",{attrs:{id:"redis的java客户端"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis的java客户端"}},[v._v("#")]),v._v(" Redis的Java客户端")]),v._v(" "),_("h4",{attrs:{id:"jedis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jedis"}},[v._v("#")]),v._v(" Jedis")]),v._v(" "),_("ul",[_("li",[v._v("使用Jedis连接池代替Jedis的直连操作")])]),v._v(" "),_("h4",{attrs:{id:"springdataredis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#springdataredis"}},[v._v("#")]),v._v(" SpringDataRedis")]),v._v(" "),_("ul",[_("li",[v._v("SpringData是Spring中数据操作的模块，包含各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis\n"),_("ul",[_("li",[v._v("提供了对不同Redis客户端的整合（Lettuce和Jedis）")]),v._v(" "),_("li",[v._v("提供了RedisTemplate统一API来操作Redis")]),v._v(" "),_("li",[v._v("支持Redis的发布订阅模型")]),v._v(" "),_("li",[v._v("支持Redis哨兵和Redis集群")]),v._v(" "),_("li",[v._v("支持基于Lettuce的响应式编程")]),v._v(" "),_("li",[v._v("支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化")]),v._v(" "),_("li",[v._v("支持基于Redis的JDKCollection实现")])])])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20220506003223605.png",alt:"image-20220506003223605"}})]),v._v(" "),_("h2",{attrs:{id:"持久性redis-数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#持久性redis-数据结构"}},[v._v("#")]),v._v(" 持久性Redis 数据结构")]),v._v(" "),_("h3",{attrs:{id:"redis-有哪些常用的数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-有哪些常用的数据结构"}},[v._v("#")]),v._v(" Redis 有哪些常用的数据结构？")]),v._v(" "),_("ul",[_("li",[v._v("5 种基础数据结构：String、List、Hash、Set、Zset")]),v._v(" "),_("li",[v._v("3 种特殊数据结构：HyperLogLogs、Bitmap、Geospatial")])]),v._v(" "),_("h4",{attrs:{id:"string"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[v._v("#")]),v._v(" String")]),v._v(" "),_("p",[v._v("应用场景")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("需要存储常规数据的场景")]),v._v("：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。")]),v._v(" "),_("li",[_("strong",[v._v("需要计数的场景")]),v._v("：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。")]),v._v(" "),_("li",[_("strong",[v._v("分布式锁")]),v._v("：利用 "),_("code",[v._v("SETNX key value")]),v._v(" 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。")])]),v._v(" "),_("h4",{attrs:{id:"list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[v._v("#")]),v._v(" List")]),v._v(" "),_("p",[v._v("应用场景")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("信息流展示")]),v._v("：最新文章、最新动态")]),v._v(" "),_("li",[_("strong",[v._v("消息队列")]),v._v("：Redis 5.0 新增数据结构 Stream 更适合做消息队列")])]),v._v(" "),_("h4",{attrs:{id:"hash"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[v._v("#")]),v._v(" Hash")]),v._v(" "),_("p",[v._v("应用场景")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("对象数据存储场景")]),v._v("：用户信息、商品信息、文章信息、购物车信息。")])]),v._v(" "),_("h4",{attrs:{id:"set"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[v._v("#")]),v._v(" Set")]),v._v(" "),_("p",[v._v("应用场景")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("存放的数据不能重复的场景")]),v._v("：网站 UV 统计（数据量巨大的场景还是 "),_("code",[v._v("HyperLogLog")]),v._v("更适合一些）、文章点赞、动态点赞等场景。")])]),v._v(" "),_("h4",{attrs:{id:"sorted-set"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sorted-set"}},[v._v("#")]),v._v(" Sorted Set")]),v._v(" "),_("p",[v._v("应用场景")]),v._v(" "),_("ul",[_("li",[v._v("需要随机获取数据源中的元素根据某个权重进行排序的场景：排行榜等")])]),v._v(" "),_("h4",{attrs:{id:"bitmap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bitmap"}},[v._v("#")]),v._v(" Bitmap")]),v._v(" "),_("p",[v._v("应用场景")]),v._v(" "),_("ul",[_("li",[v._v("需要保存状态信息（0/1）的场景：用户签到、用户行为统计等")])]),v._v(" "),_("h4",{attrs:{id:"hyperloglog"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hyperloglog"}},[v._v("#")]),v._v(" HyperLogLog")]),v._v(" "),_("p",[v._v("应用场景")]),v._v(" "),_("ul",[_("li",[v._v("数据量巨大（百万、千万级别以上）的计数场景：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计")])]),v._v(" "),_("h4",{attrs:{id:"geospatial-index"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#geospatial-index"}},[v._v("#")]),v._v(" Geospatial index")]),v._v(" "),_("p",[v._v("应用场景：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("需要管理使用地理空间数据的场景")]),v._v("：附近的人、附近的饭店等")])]),v._v(" "),_("h2",{attrs:{id:"redis-线程模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-线程模型"}},[v._v("#")]),v._v(" Redis 线程模型")]),v._v(" "),_("h3",{attrs:{id:"什么是-redis-单线程模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-redis-单线程模型"}},[v._v("#")]),v._v(" 什么是 Redis 单线程模型？")]),v._v(" "),_("p",[v._v("Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，这套事件处理模型对应的是 Redis 中的文件事件处理器。由于文件事件处理器是单线程方式运行的，所以我们一般说 Redis 是单线程模型。")]),v._v(" "),_("p",[v._v("虽然文件事件处理器是以单线程模式运行的，但是是通过 "),_("strong",[v._v("I/O 多路复用程序")]),v._v("来监听多个套接字。")]),v._v(" "),_("h3",{attrs:{id:"既然是单线程-那怎么监听大量的客户端连接呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#既然是单线程-那怎么监听大量的客户端连接呢"}},[v._v("#")]),v._v(" 既然是单线程，那怎么监听大量的客户端连接呢？")]),v._v(" "),_("p",[v._v("Redis 通过 I/O 多路复用来监听客户端的大量连接，然后将感兴趣的事件以及类型注册到内核中并监听每个事件是否发生。")]),v._v(" "),_("h3",{attrs:{id:"redis-6-0-之前为什么不使用多线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-6-0-之前为什么不使用多线程"}},[v._v("#")]),v._v(" Redis 6.0 之前为什么不使用多线程？")]),v._v(" "),_("p",[v._v("主要原因有三点：")]),v._v(" "),_("ul",[_("li",[v._v("单线程编程较为简单并且容易维护")]),v._v(" "),_("li",[v._v("多线程环境下容易发生死锁、线程上下文切换等场景，会影响性能")]),v._v(" "),_("li",[v._v("Redis 的性能瓶颈不在 CPU，在于内存和网络的性能")])]),v._v(" "),_("h3",{attrs:{id:"redis-6-0-之后为什么又引入了多线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-6-0-之后为什么又引入了多线程"}},[v._v("#")]),v._v(" Redis 6.0 之后为什么又引入了多线程？")]),v._v(" "),_("p",[_("strong",[v._v("Redis6.0 引入多线程主要是为了提高网络 IO 读写性能")]),v._v("，也仅仅只是在网络数据的读写操作上使用罢了，对于执行命令仍然是单线程执行。")]),v._v(" "),_("h2",{attrs:{id:"redis-内存管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-内存管理"}},[v._v("#")]),v._v(" Redis 内存管理")]),v._v(" "),_("h3",{attrs:{id:"redis-给缓存数据设置过期时间有啥用处"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-给缓存数据设置过期时间有啥用处"}},[v._v("#")]),v._v(" Redis 给缓存数据设置过期时间有啥用处？")]),v._v(" "),_("p",[v._v("因为 "),_("strong",[v._v("内存是有限")]),v._v(" 的，如果缓存中的所有数据都是一直保存的话，直接 Out of memory。")]),v._v(" "),_("p",[v._v("Redis 中除了字符串类型有自己独立设置过期时间的命令 setnx 之外，其他方法都要依靠 expire 命令来设置过期时间，使用 persist 可以移除一个键的过期时间。")]),v._v(" "),_("h3",{attrs:{id:"redis-是如何判断数据是否过期的呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-是如何判断数据是否过期的呢"}},[v._v("#")]),v._v(" Redis 是如何判断数据是否过期的呢？")]),v._v(" "),_("p",[v._v("Redis 是通过 "),_("strong",[v._v("过期字典")]),v._v("（可以看成是 hash 表）来保存过期的时间。过期字典的键指向 Redis 数据库中的某个 key，过期字典的值是 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间。")]),v._v(" "),_("h3",{attrs:{id:"redis-过期的数据的删除策略是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-过期的数据的删除策略是什么"}},[v._v("#")]),v._v(" Redis 过期的数据的删除策略是什么？")]),v._v(" "),_("p",[v._v("常用的过期数据的淘汰策略有两个：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("惰性删除")]),v._v("：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。")]),v._v(" "),_("li",[_("strong",[v._v("定期删除")]),v._v("：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。")])]),v._v(" "),_("p",[v._v("定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 "),_("strong",[v._v("定期删除+惰性/懒汉式删除")]),v._v(" 。")]),v._v(" "),_("h3",{attrs:{id:"redis-内存淘汰机制了解吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-内存淘汰机制了解吗"}},[v._v("#")]),v._v(" Redis 内存淘汰机制了解吗？")]),v._v(" "),_("p",[v._v("Redis 提供 6 种数据淘汰策略：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("volatile-lru（least recently used）")]),v._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰；")]),v._v(" "),_("li",[_("strong",[v._v("volatile-ttl")]),v._v("：从已设置过期时间的数据集中挑选将要过期的数据淘汰；")]),v._v(" "),_("li",[_("strong",[v._v("volatile-random")]),v._v("：从已设置过期时间的数据集中任意选择数据淘汰；")]),v._v(" "),_("li",[_("strong",[v._v("allkeys-lru（least recently used）")]),v._v("：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）；")]),v._v(" "),_("li",[_("strong",[v._v("allkeys-random")]),v._v("：从数据集（server.db[i].dict）中任意选择数据淘汰；")]),v._v(" "),_("li",[_("strong",[v._v("no-eviction")]),v._v("：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！；")])]),v._v(" "),_("p",[v._v("4.0 版本后增加以下两种：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("volatile-lfu（least frequently used）")]),v._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰")]),v._v(" "),_("li",[_("strong",[v._v("allkeys-lfu（least frequently used）")]),v._v("：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key")])]),v._v(" "),_("h2",{attrs:{id:"redis-持久化机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化机制"}},[v._v("#")]),v._v(" Redis 持久化机制")]),v._v(" "),_("h3",{attrs:{id:"怎么保证-redis-宕机之后再次重启数据可以进行恢复"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#怎么保证-redis-宕机之后再次重启数据可以进行恢复"}},[v._v("#")]),v._v(" 怎么保证 Redis 宕机之后再次重启数据可以进行恢复？")]),v._v(" "),_("p",[v._v("Redis 支持持久化，一种是快照（RDB）、另一种是只追加文件（AOF）")]),v._v(" "),_("h3",{attrs:{id:"什么是rdb-快照-持久化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是rdb-快照-持久化"}},[v._v("#")]),v._v(" 什么是RDB（快照）持久化？")]),v._v(" "),_("p",[v._v("Redis 可以通过创建快照来 "),_("strong",[v._v("获得存储在内存里面的数据在某个时间点上的副本")]),v._v(" ，Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（"),_("strong",[v._v("Redis 主从结构，主要用来提高 Redis 性能")]),v._v("），还可以将快照留在原地以便重启服务器的时候使用。")]),v._v(" "),_("p",[_("strong",[v._v("快照持久化是 Redis 默认采用的持久化方式")]),v._v("。")]),v._v(" "),_("h3",{attrs:{id:"redis-中的-rdb-创建快照时会阻塞线程吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-中的-rdb-创建快照时会阻塞线程吗"}},[v._v("#")]),v._v(" Redis 中的 RDB 创建快照时会阻塞线程吗？")]),v._v(" "),_("p",[v._v("Redis 提供了两个命令来生成 RDB 快照文件：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("save")]),v._v(" : 主线程执行，会阻塞主线程；")]),v._v(" "),_("li",[_("code",[v._v("bgsave")]),v._v(" : 子线程执行，不会阻塞主线程，默认选项")])]),v._v(" "),_("h3",{attrs:{id:"什么是-aof-只追加文件-持久化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-aof-只追加文件-持久化"}},[v._v("#")]),v._v(" 什么是 AOF（只追加文件） 持久化？")]),v._v(" "),_("p",[v._v("与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。")]),v._v(" "),_("p",[v._v("默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启。")]),v._v(" "),_("p",[v._v("开启 AOF 持久化后，Redis 每执行一条会"),_("strong",[v._v("更改 Redis 中的数据")]),v._v(" 的命令，就会将命令写入 server.aof_buf 中，然后根据 appendfsync 配置来决定何时将数据同步到硬盘的 AOF 文件。")]),v._v(" "),_("p",[v._v("在 Redis 中存在三种不同的 AOF 持久化方式：")]),v._v(" "),_("ul",[_("li",[v._v("appendfsync always 每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度")]),v._v(" "),_("li",[v._v("appendfsync everysec 每秒钟同步一次，显式地将多个写命令同步到硬盘")]),v._v(" "),_("li",[v._v("appendfsync no 让操作系统决定何时进行同步")])]),v._v(" "),_("h3",{attrs:{id:"aof-日志是如何实现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aof-日志是如何实现的"}},[v._v("#")]),v._v(" AOF 日志是如何实现的？")]),v._v(" "),_("p",[v._v("关系型数据库（如 MySQL）通常都是执行命令之前记录日志（目的是为了方便故障的恢复）。而 Redis AOF 持久化机制是在执行完命令之后再记录日志，为什么要这么安排？")]),v._v(" "),_("ul",[_("li",[v._v("避免额外的检查开销，"),_("strong",[v._v("AOF 记录日志不会对命令进行语法检查")]),v._v("；")]),v._v(" "),_("li",[v._v("在命令执行完之后再记录，不会阻塞当前的命令执行。")])]),v._v(" "),_("p",[v._v("这样也带来了风险：")]),v._v(" "),_("ul",[_("li",[v._v("如果"),_("strong",[v._v("刚执行完命令 Redis 就宕机会导致对应的修改丢失")]),v._v("；")]),v._v(" "),_("li",[v._v("可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）")])]),v._v(" "),_("h3",{attrs:{id:"aof-重写了解吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写了解吗"}},[v._v("#")]),v._v(" AOF 重写了解吗？")]),v._v(" "),_("p",[v._v("当 AOF 变得太大的时候，Redis 会在后台自动重写 AOF 然后产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一致，但是体积更小。")]),v._v(" "),_("h3",{attrs:{id:"如何选择-rdb-和-aof"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何选择-rdb-和-aof"}},[v._v("#")]),v._v(" 如何选择 RDB 和 AOF？")]),v._v(" "),_("p",[_("strong",[v._v("RDB 比 AOF 优秀的地方")]),v._v(" ：")]),v._v(" "),_("ul",[_("li",[v._v("RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。")]),v._v(" "),_("li",[v._v("使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。")])]),v._v(" "),_("p",[_("strong",[v._v("AOF 比 RDB 优秀的地方")]),v._v(" ：")]),v._v(" "),_("ul",[_("li",[v._v("RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。")]),v._v(" "),_("li",[v._v("RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。")]),v._v(" "),_("li",[v._v("AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行"),_("code",[v._v("FLUSHALL")]),v._v("命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。")])]),v._v(" "),_("h2",{attrs:{id:"使用redis实现消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用redis实现消息队列"}},[v._v("#")]),v._v(" 使用Redis实现消息队列")]),v._v(" "),_("h3",{attrs:{id:"list-实现消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#list-实现消息队列"}},[v._v("#")]),v._v(" List 实现消息队列")]),v._v(" "),_("h3",{attrs:{id:"订阅发布模型-实现消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#订阅发布模型-实现消息队列"}},[v._v("#")]),v._v(" 订阅发布模型 实现消息队列")]),v._v(" "),_("p",[v._v("消息模型有两种：")]),v._v(" "),_("ul",[_("li",[v._v("点对点发布")])]),v._v(" "),_("p",[v._v("List实现的其实就是点对点发布模型")]),v._v(" "),_("ul",[_("li",[v._v("发布订阅")])]),v._v(" "),_("p",[v._v("Redis 可以通过 PUBLISH、SUBSCRIBE 等命令实现发布订阅模式，这个模式提供两种信息机制，分别是 "),_("strong",[v._v("订阅/发布到频道/模式")]),v._v("。")]),v._v(" "),_("h3",{attrs:{id:"streams-实现消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#streams-实现消息队列"}},[v._v("#")]),v._v(" Streams 实现消息队列")]),v._v(" "),_("p",[v._v("Redis 发布订阅 (pub/sub) 有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。而且也没有 Ack 机制来保证数据的可靠性，假设一个消费者都没有，那消息就直接被丢弃了。")]),v._v(" "),_("p",[v._v("Redis 5.0 版本新增一个更强大的数据结构 - Stream。提供消息的持久化和主从复制功能，以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。")]),v._v(" "),_("p",[v._v("它就像是个只能追加内容的"),_("strong",[v._v("消息链表")]),v._v("，把所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。而且消息是持久化的。")]),v._v(" "),_("h2",{attrs:{id:"使用redis实现分布式锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用redis实现分布式锁"}},[v._v("#")]),v._v(" 使用Redis实现分布式锁")]),v._v(" "),_("h3",{attrs:{id:"什么是分布式锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是分布式锁"}},[v._v("#")]),v._v(" 什么是分布式锁？")]),v._v(" "),_("p",[v._v("在单机多线程来说，在 Java 中，我们通过  ReentryLock 类、synchronized 关键字来控制一个 JVM 中的多个线程对本地共享资源的访问。")]),v._v(" "),_("p",[v._v("在分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上，如果此时多个 JVM 同时共享同一份资源的话，那么使用本地锁是没办法实现资源的互斥访问的，此时就需要运用到分布式锁。")]),v._v(" "),_("p",[v._v("一个基本的分布式锁起码得满足以下条件：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("互斥")]),v._v("：在任意一个线程内，锁只能被一个线程所拥有")]),v._v(" "),_("li",[_("strong",[v._v("高可用性")]),v._v("：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。")]),v._v(" "),_("li",[_("strong",[v._v("可重入")]),v._v("：一个节点获取了锁之后，还可以再次获取锁。")])]),v._v(" "),_("h3",{attrs:{id:"基于-redis-实现分布式锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基于-redis-实现分布式锁"}},[v._v("#")]),v._v(" 基于 Redis 实现分布式锁")]),v._v(" "),_("h4",{attrs:{id:"如何使用-redis-实现分布式锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何使用-redis-实现分布式锁"}},[v._v("#")]),v._v(" 如何使用 Redis 实现分布式锁？")]),v._v(" "),_("p",[v._v("分布式锁的核心在于 "),_("strong",[v._v("互斥")]),v._v("，在 Redis 中，SETNX 即 SET if Not EXists (对应 Java 中的 setIfAbsent 方法)。即是如果 key 不存在的话，才会设置 key；如果是 key 已经存在的话，SETNX 啥也不做。需要释放锁的话，直接通过 DEL 命令删除对应的 key 即可。")]),v._v(" "),_("p",[v._v("为了防止删到其它的锁，我们还是建议使用 "),_("strong",[v._v("Lua 脚本")]),v._v("（实现 Redis 操作的原子性）通过 key 对应的 value 来进行判断。")]),v._v(" "),_("h4",{attrs:{id:"为什么要给锁设定一个过期的时间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么要给锁设定一个过期的时间"}},[v._v("#")]),v._v(" 为什么要给锁设定一个过期的时间？")]),v._v(" "),_("p",[v._v("为了避免锁没办法进行释放，我们想到的一个解决办法就是：给锁对应的 key 设置一个过期的时间。")]),v._v(" "),_("h4",{attrs:{id:"如何实现锁的续期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何实现锁的续期"}},[v._v("#")]),v._v(" 如何实现锁的续期？")]),v._v(" "),_("p",[v._v("Java 中使用 Redisson 实现。Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel 、Redis Cluster 等多种部署架构。")]),v._v(" "),_("p",[v._v("Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 "),_("strong",[v._v("Watch Dog（ 看门狗）")]),v._v("，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。")]),v._v(" "),_("p",[v._v("如果使用 Redis 实现分布式锁的话，推荐直接使用 Redisson 实现。")]),v._v(" "),_("h4",{attrs:{id:"如何实现可重入锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何实现可重入锁"}},[v._v("#")]),v._v(" 如何实现可重入锁？")]),v._v(" "),_("p",[v._v("可重入锁指的是在"),_("strong",[v._v("一个线程内可以多次获取到同一把锁")]),v._v("。像Java中的 "),_("strong",[v._v("synchronized")]),v._v(" 和 "),_("strong",[v._v("ReentryLock")]),v._v(" 都是属于可重入锁。")]),v._v(" "),_("p",[v._v("**可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。**为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。")]),v._v(" "),_("p",[v._v("实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 "),_("strong",[v._v("Redisson")]),v._v(" ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。")]),v._v(" "),_("h4",{attrs:{id:"redis-如何解决集群模式下的分布式锁的可靠性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-如何解决集群模式下的分布式锁的可靠性"}},[v._v("#")]),v._v(" Redis 如何解决集群模式下的分布式锁的可靠性？")]),v._v(" "),_("p",[v._v("针对这个问题，Redis 之父 antirez 设计了 "),_("a",{attrs:{href:"https://redis.io/topics/distlock",target:"_blank",rel:"noopener noreferrer"}},[v._v("Redlock 算法"),_("OutboundLink")],1),v._v(" 来解决。")]),v._v(" "),_("p",[v._v("Redlock 算法的思想是"),_("strong",[v._v("让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"redis-事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-事务"}},[v._v("#")]),v._v(" Redis 事务")]),v._v(" "),_("h3",{attrs:{id:"redis-支持原子性吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-支持原子性吗"}},[v._v("#")]),v._v(" Redis 支持原子性吗？")]),v._v(" "),_("p",[v._v("事务四大特性：")]),v._v(" "),_("p",[v._v("原子性、隔离性、一致性、持久性")]),v._v(" "),_("p",[v._v("Redis 事务在运行错误的情况下，除了执行过程中出现的错误的命令，其他的命令都是能正常执行的，并且 Redis 是不支持回滚操作的。因此，Redis 事务不支持原子性（也不支持持久性）")]),v._v(" "),_("p",[v._v("可以将 Redis 中的事务就理解为 ："),_("strong",[v._v("Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。")])]),v._v(" "),_("h3",{attrs:{id:"如何解决-redis-中事务机制出现的缺陷"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何解决-redis-中事务机制出现的缺陷"}},[v._v("#")]),v._v(" 如何解决 Redis 中事务机制出现的缺陷？")]),v._v(" "),_("p",[v._v("Lua脚本，脚本中的 Redis 命令会一次性执行完成，很大程度上减少了网络的开销（Redis 事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。使用 Lua 一次批量执行多个命令就可以了）。")]),v._v(" "),_("h2",{attrs:{id:"redis-性能优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-性能优化"}},[v._v("#")]),v._v(" Redis 性能优化")]),v._v(" "),_("h2",{attrs:{id:"redis-生产问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-生产问题"}},[v._v("#")]),v._v(" Redis 生产问题")]),v._v(" "),_("h3",{attrs:{id:"缓存穿透"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[v._v("#")]),v._v(" 缓存穿透")]),v._v(" "),_("p",[v._v("大量请求的 key 是不合理的，不是有效的 key，既不存在于缓存中，也不存在于数据库中。那么，这些请求就直接请求到了数据库上，没有经过缓存层，直接给数据库造成了巨大的压力，导致数据库宕机。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230304223503269.png",alt:"image-20230304223503269"}})]),v._v(" "),_("p",[v._v("解决方法：")]),v._v(" "),_("ul",[_("li",[v._v("缓存无效 key")])]),v._v(" "),_("p",[v._v("不能从根本上解决问题。")]),v._v(" "),_("ul",[_("li",[v._v("布隆过滤器")])]),v._v(" "),_("p",[_("a",{attrs:{href:"https://javaguide.cn/cs-basics/data-structure/bloom-filter/",target:"_blank",rel:"noopener noreferrer"}},[v._v("《不了解布隆过滤器？一文给你整的明明白白！》"),_("OutboundLink")],1)]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230304223641763.png",alt:"image-20230304223641763"}})]),v._v(" "),_("h3",{attrs:{id:"缓存击穿"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[v._v("#")]),v._v(" 缓存击穿")]),v._v(" "),_("p",[v._v("请求的 key 对应的是热点数据，但是此时不存在缓存里面，而是存在于数据库上（很大原因是因为缓存中的那份 key 已经过期），会直接给数据库造成巨大的压力，导致数据库宕机。")]),v._v(" "),_("p",[v._v("例子：秒杀过程中秒杀商品过期！！")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230304223942996.png",alt:"image-20230304223942996"}})]),v._v(" "),_("p",[v._v("解决方法：")]),v._v(" "),_("ul",[_("li",[v._v("将热点数据设置为永不过期（性能差）或过期时间设置长一些；")]),v._v(" "),_("li",[v._v("提前将热点数据进行预热，并设置有效的、合理的过期时间；")]),v._v(" "),_("li",[v._v("锁机制，保证每次只有一个请求落到数据库上，但是这样效率会大大降低；")])]),v._v(" "),_("h3",{attrs:{id:"缓存雪崩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[v._v("#")]),v._v(" 缓存雪崩")]),v._v(" "),_("p",[_("strong",[v._v("缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力")]),v._v("，导致数据库宕机。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230304224224894.png",alt:"image-20230304224224894"}})]),v._v(" "),_("p",[v._v("解决方法：")]),v._v(" "),_("ul",[_("li",[v._v("针对 Redis 服务不可用\n"),_("ul",[_("li",[v._v("采用 Redis 集群")]),v._v(" "),_("li",[v._v("限流，避免同时引入大量请求")])])]),v._v(" "),_("li",[v._v("针对热点数据缓存失效\n"),_("ul",[_("li",[v._v("对缓存数据设置更合理的缓存时间（针对雪崩来说应该设置不一样的时间）")]),v._v(" "),_("li",[v._v("设置二级缓存")])])])]),v._v(" "),_("h2",{attrs:{id:"如何保证数据库与缓存的一致性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何保证数据库与缓存的一致性"}},[v._v("#")]),v._v(" 如何保证数据库与缓存的一致性？")]),v._v(" "),_("p",[v._v("一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("强一致性")]),v._v("：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大；")]),v._v(" "),_("li",[_("strong",[v._v("弱一致性")]),v._v("：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态；")]),v._v(" "),_("li",[_("strong",[v._v("最终一致性")]),v._v("：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型；")])]),v._v(" "),_("h3",{attrs:{id:"三个经典的缓存模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三个经典的缓存模式"}},[v._v("#")]),v._v(" "),_("strong",[v._v("三个经典的缓存模式")])]),v._v(" "),_("p",[v._v("缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据"),_("strong",[v._v("不一致性")]),v._v("的问题。一般我们是如何使用缓存呢？有三种经典的缓存使用模式：")]),v._v(" "),_("ul",[_("li",[v._v("Cache-Aside Pattern（旁路缓存模式）")]),v._v(" "),_("li",[v._v("Read-Through/Write-through（读写穿透模式）")]),v._v(" "),_("li",[v._v("Write-behind")])]),v._v(" "),_("h4",{attrs:{id:"cache-aside-pattern-旁路缓存模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-aside-pattern-旁路缓存模式"}},[v._v("#")]),v._v(" Cache-Aside Pattern（旁路缓存模式）")]),v._v(" "),_("p",[v._v("Cache-Aside Pattern，即 "),_("strong",[v._v("旁路缓存模式")]),v._v("，它的提出是为了尽可能地解决缓存与数据库的数据不一致问题。是我们平时比较经常使用的一种缓存读写模式，适合读请求比较多的场景。")]),v._v(" "),_("p",[_("strong",[v._v("读流程")]),v._v("：")]),v._v(" "),_("ol",[_("li",[v._v("读的时候，先读缓存，缓存命中的话，直接返回数据")]),v._v(" "),_("li",[v._v("缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应。")])]),v._v(" "),_("p",[_("strong",[v._v("写流程")]),v._v("：")]),v._v(" "),_("p",[v._v("更新的时候，先"),_("strong",[v._v("更新数据库，然后再删除缓存")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("缺陷")]),v._v("：")]),v._v(" "),_("ol",[_("li",[v._v("首次请求数据，数据可能不存在缓存中（将数据进行提前预热）")]),v._v(" "),_("li",[v._v("写操作比较频繁的话，缓存会频繁被删除，影响读请求的缓存命中率")])]),v._v(" "),_("h4",{attrs:{id:"read-through-write-through-pattern-读写穿透"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#read-through-write-through-pattern-读写穿透"}},[v._v("#")]),v._v(" Read-Through/Write-Through Pattern（读写穿透）")]),v._v(" "),_("p",[_("strong",[v._v("Read/Write-Through")]),v._v(" 模式中，服务端把缓存作为主要数据存储，从缓存中读取数据并将其写入其中。应用程序跟缓存交互，都是通过 "),_("strong",[v._v("抽象缓存层")]),v._v(" 完成的。")]),v._v(" "),_("p",[_("strong",[v._v("Read-Through")]),v._v(" 的简要流程如下")]),v._v(" "),_("ol",[_("li",[v._v("从缓存读取数据，读到直接返回")]),v._v(" "),_("li",[v._v("如果读取不到的话，从数据库加载，写入缓存后，再返回响应。")])]),v._v(" "),_("p",[_("strong",[v._v("Write-Through")]),v._v("模式下，当发生写请求时，也是由"),_("strong",[v._v("缓存抽象层")]),v._v("完成数据源和缓存数据的更新,流程如下：")]),v._v(" "),_("h4",{attrs:{id:"write-behind-pattern-异步缓存写入"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#write-behind-pattern-异步缓存写入"}},[v._v("#")]),v._v(" Write-behind Pattern（异步缓存写入）")]),v._v(" "),_("p",[_("strong",[v._v("Write-behind")]),v._v(" 跟Read-Through/Write-Through有相似的地方，都是由"),_("strong",[v._v("Cache Provider")]),v._v("来负责缓存和数据库的读写。它们又有个很大的不同："),_("strong",[v._v("Read/Write-Through")]),v._v("是同步更新缓存和数据的，"),_("strong",[v._v("Write-Behind")]),v._v("则是只更新缓存，不直接更新数据库，通过"),_("strong",[v._v("批量异步")]),v._v("的方式来更新数据库。")]),v._v(" "),_("h3",{attrs:{id:"操作缓存的时候-到底是删除缓存呢-还是更新缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#操作缓存的时候-到底是删除缓存呢-还是更新缓存"}},[v._v("#")]),v._v(" "),_("strong",[v._v("操作缓存的时候，到底是删除缓存呢，还是更新缓存？")])]),v._v(" "),_("p",[v._v("日常开发中，我们一般使用的就是"),_("strong",[v._v("Cache-Aside")]),v._v("模式。那为什么是先删除缓存而不是直接更新缓存呢？")]),v._v(" "),_("p",[_("strong",[v._v("下面来看这个例子")]),v._v("：")]),v._v(" "),_("p",[v._v("线程A发起写请求")]),v._v(" "),_("p",[v._v("线程B也发起写请求")]),v._v(" "),_("p",[v._v("下面进行了这些操作")]),v._v(" "),_("p",[v._v("1、线程A更新数据库")]),v._v(" "),_("p",[v._v("2、线程B更新数据库")]),v._v(" "),_("p",[v._v("3、线程B更新了缓存")]),v._v(" "),_("p",[v._v("4、线程A更新了缓存")]),v._v(" "),_("p",[v._v("从上面四步的结果可以看出，缓存更新完之后，缓存存在的值就是A的值（也就是老的数据，而新的值B的缓存值就被覆盖了，并且此时数据库与缓存之间的值也出现了不同一的状态）")]),v._v(" "),_("p",[_("strong",[v._v("更新缓存相对于删除缓存")]),v._v("，还有两点劣势：")]),v._v(" "),_("ul",[_("li",[v._v("如果写入的缓存值，是经过复杂计算才得到的话。更新缓存频率高的话，就浪费性能啦。")]),v._v(" "),_("li",[v._v("在写数据库场景多，读数据场景少的情况下，数据很多时候还没被读取到，又被更新了，这也浪费了性能(实际上，写多的场景，用缓存也不是很划算的)")])]),v._v(" "),_("h3",{attrs:{id:"双写的情况下-先操作数据库还是先操作缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双写的情况下-先操作数据库还是先操作缓存"}},[v._v("#")]),v._v(" "),_("strong",[v._v("双写的情况下，先操作数据库还是先操作缓存？")])]),v._v(" "),_("p",[_("code",[v._v("Cache-Aside")]),v._v("缓存模式中，有些小伙伴还是会有疑问，在写请求过来的时候，为什么是"),_("strong",[v._v("先操作数据库呢")]),v._v("？为什么"),_("strong",[v._v("不先操作缓存")]),v._v("呢？")]),v._v(" "),_("p",[v._v("假设有A、B两个请求，请求A做更新操作，请求B做查询读取操作。")]),v._v(" "),_("ol",[_("li",[v._v("线程A发起一个写操作，第一步del cache（因为现在假设写操作是先操作缓存，也就是删除缓存）")]),v._v(" "),_("li",[v._v("此时线程B发起一个读操作，cache miss，缓存丢失")]),v._v(" "),_("li",[v._v("线程B继续读DB，读出来一个老数据")]),v._v(" "),_("li",[v._v("然后线程B把老数据设置入cache")]),v._v(" "),_("li",[v._v("线程A写入DB最新的数据")]),v._v(" "),_("li",[v._v("此时就会出现缓存中的数据与数据库中的数据不一致的状况")])])])}),[],!1,null,null,null);_.default=t.exports}}]);