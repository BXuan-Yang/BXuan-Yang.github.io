(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{319:function(v,_,t){"use strict";t.r(_);var a=t(10),r=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"🚀系统设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#🚀系统设计"}},[v._v("#")]),v._v(" 🚀系统设计")]),v._v(" "),_("h2",{attrs:{id:"设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[v._v("#")]),v._v(" 设计模式")]),v._v(" "),_("h3",{attrs:{id:"装饰者模式和代理模式有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#装饰者模式和代理模式有什么区别"}},[v._v("#")]),v._v(" 装饰者模式和代理模式有什么区别？")]),v._v(" "),_("h3",{attrs:{id:"单例模式是怎么实现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单例模式是怎么实现的"}},[v._v("#")]),v._v(" 单例模式是怎么实现的？")]),v._v(" "),_("h3",{attrs:{id:"什么是工厂模式-使用工厂模式有什么好处-工厂模式有哪些分类-各自的应用场景是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是工厂模式-使用工厂模式有什么好处-工厂模式有哪些分类-各自的应用场景是什么"}},[v._v("#")]),v._v(" 什么是工厂模式？使用工厂模式有什么好处？工厂模式有哪些分类？各自的应用场景是什么？")]),v._v(" "),_("p",[v._v("工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种封装对象创建过程的方法。工厂模式将对象的创建和使用分离，让一个专门的工厂类负责创建对象实例，而不是在代码中直接使用"),_("code",[v._v("new")]),v._v("操作符。这有助于降低代码的耦合度，提高可维护性和可扩展性。")]),v._v(" "),_("p",[_("strong",[v._v("使用工厂模式的好处：")])]),v._v(" "),_("ol",[_("li",[v._v("降低耦合度：工厂模式将对象的创建与使用分离，使得客户端代码不直接依赖具体的类，降低了耦合度。")]),v._v(" "),_("li",[v._v("提高可扩展性：当需要添加或修改产品类时，只需修改工厂类，而不需要修改客户端代码，提高了系统的可扩展性。")]),v._v(" "),_("li",[v._v("提高可维护性：通过集中管理对象的创建，提高了代码的可维护性。")]),v._v(" "),_("li",[v._v("提高代码复用性：工厂类可以被多个客户端代码复用，减少了重复代码。")])]),v._v(" "),_("p",[v._v("工厂模式可以分为以下几类：")]),v._v(" "),_("ol",[_("li",[v._v("简单工厂模式（Simple Factory Pattern）：一个工厂类根据传入的参数决定创建哪个具体产品类的实例。简单工厂模式适用于产品种类较少且不易变化的场景。 应用场景：例如，一个简单的图形绘制工具，可以根据传入的参数创建不同类型的图形（如圆形、矩形等）。")]),v._v(" "),_("li",[v._v("工厂方法模式（Factory Method Pattern）：定义一个接口或抽象类来创建对象，将实际创建对象的工作推迟到子类中。工厂方法模式适用于产品种类较多且可能增加的场景。 应用场景：例如，一个日志记录器，可以根据不同的需求（如文件日志、数据库日志等）使用不同的工厂子类创建相应的日志记录器实例。")]),v._v(" "),_("li",[v._v("抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。抽象工厂模式适用于产品族的场景。 应用场景：例如，跨平台UI框架，可以为不同平台（如Windows、macOS等）提供不同的UI控件实现，通过抽象工厂来创建对应平台的一系列UI控件。")])]),v._v(" "),_("p",[v._v("各种工厂模式的应用场景取决于实际需求，需要根据具体问题来选择合适的工厂模式。")]),v._v(" "),_("h3",{attrs:{id:"设计模式可以分为哪几类-一共有多少种主流的设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式可以分为哪几类-一共有多少种主流的设计模式"}},[v._v("#")]),v._v(" 设计模式可以分为哪几类？一共有多少种主流的设计模式？")]),v._v(" "),_("p",[v._v("设计模式可以分为三类：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("创建型模式")]),v._v("：这类模式关注对象创建的机制，包括单例模式、工厂模式、抽象工厂模式、建造者模式和原型模式等。")]),v._v(" "),_("li",[_("strong",[v._v("结构型模式")]),v._v("：这类模式关注对象之间的组合关系，包括适配器模式、装饰器模式、代理模式、组合模式、桥接模式、外观模式和享元模式等。")]),v._v(" "),_("li",[_("strong",[v._v("行为型模式")]),v._v("：这类模式关注对象之间的通信方式和协作方式，包括模板方法模式、策略模式、命令模式、职责链模式、状态模式、观察者模式、中介者模式和访问者模式等。")])]),v._v(" "),_("p",[v._v("目前主流的设计模式有23种，它们分别是：")]),v._v(" "),_("ol",[_("li",[v._v("单例模式")]),v._v(" "),_("li",[v._v("工厂方法模式")]),v._v(" "),_("li",[v._v("抽象工厂模式")]),v._v(" "),_("li",[v._v("建造者模式")]),v._v(" "),_("li",[v._v("原型模式")]),v._v(" "),_("li",[v._v("适配器模式")]),v._v(" "),_("li",[v._v("装饰器模式")]),v._v(" "),_("li",[v._v("代理模式")]),v._v(" "),_("li",[v._v("外观模式")]),v._v(" "),_("li",[v._v("桥接模式")]),v._v(" "),_("li",[v._v("组合模式")]),v._v(" "),_("li",[v._v("享元模式")]),v._v(" "),_("li",[v._v("策略模式")]),v._v(" "),_("li",[v._v("模板方法模式")]),v._v(" "),_("li",[v._v("观察者模式")]),v._v(" "),_("li",[v._v("迭代器模式")]),v._v(" "),_("li",[v._v("职责链模式")]),v._v(" "),_("li",[v._v("命令模式")]),v._v(" "),_("li",[v._v("备忘录模式")]),v._v(" "),_("li",[v._v("状态模式")]),v._v(" "),_("li",[v._v("访问者模式")]),v._v(" "),_("li",[v._v("中介者模式")]),v._v(" "),_("li",[v._v("解释器模式")])]),v._v(" "),_("h2",{attrs:{id:"系统设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统设计"}},[v._v("#")]),v._v(" 系统设计")]),v._v(" "),_("h3",{attrs:{id:"如何在-10-亿个数据中找到最大的-1-万个-提示-最小堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何在-10-亿个数据中找到最大的-1-万个-提示-最小堆"}},[v._v("#")]),v._v(" 如何在 10 亿个数据中找到最大的 1 万个？（提示：最小堆）")]),v._v(" "),_("p",[v._v("在 10 亿个数据中找到最大的 1 万个，可以使用最小堆（Min-Heap）算法来实现。")]),v._v(" "),_("p",[v._v("最小堆是一种特殊的二叉树结构，每个节点的值都小于或等于其左右子节点的值。在使用最小堆来查找最大的 1 万个数据时，可以先创建一个大小为 1 万的最小堆，然后将 10 亿个数据逐个加入堆中。当堆的大小超过了 1 万时，将堆顶元素（即最小值）弹出，再将当前元素加入堆中。当遍历完所有数据后，堆中剩余的 1 万个元素就是最大的 1 万个数据。")]),v._v(" "),_("p",[v._v("这种方法的时间复杂度为 O(n log k)，其中 n 是数据总数，k 是要查找的元素数量。因为要维护一个大小为 1 万的最小堆，所以空间复杂度也为 O(k)。")])])}),[],!1,null,null,null);_.default=r.exports}}]);