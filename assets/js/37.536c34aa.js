(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{321:function(v,e,_){"use strict";_.r(e);var s=_(10),i=Object(s.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"🚀redis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#🚀redis"}},[v._v("#")]),v._v(" 🚀Redis")]),v._v(" "),e("h3",{attrs:{id:"redis-为什么这么快"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-为什么这么快"}},[v._v("#")]),v._v(" Redis 为什么这么快？")]),v._v(" "),e("p",[v._v("Redis 之所以快，主要有以下几个方面的原因：")]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("内存存储")]),v._v("：Redis 的数据都是存储在内存中的，相比于硬盘存储的数据库，内存存储速度更快。")]),v._v(" "),e("li",[e("strong",[v._v("单线程模型")]),v._v("：Redis 使用单线程模型处理所有的请求，避免了多线程之间的线程切换和竞争等开销，提高了处理请求的效率。")]),v._v(" "),e("li",[e("strong",[v._v("非阻塞 I/O")]),v._v("：Redis 使用非阻塞 I/O 处理网络通信，当一个客户端请求到来时，Redis 不会一直等待客户端的响应，而是会先处理其它的请求，这样就避免了 I/O 阻塞带来的性能问题。")]),v._v(" "),e("li",[e("strong",[v._v("精简高效的数据结构")]),v._v("：Redis 内置了多种高效的数据结构，如哈希表、跳表等，这些数据结构的实现非常精简高效，减少了 Redis 对内存和 CPU 的占用，从而提高了 Redis 的性能。")]),v._v(" "),e("li",[e("strong",[v._v("持久化策略")]),v._v("：Redis 支持多种持久化策略，如 RDB（快照）和 AOF（追加式文件）等，这些策略可以将内存中的数据保存到硬盘中，以保证数据的持久性和安全性。同时，Redis 可以将数据以压缩的方式存储在硬盘中，减少了硬盘的占用，提高了数据的读写速度。")])]),v._v(" "),e("p",[v._v("综上所述，Redis 之所以快，主要得益于其内存存储、单线程模型、非阻塞 I/O、高效的数据结构和灵活的持久化策略等方面的设计和实现。")]),v._v(" "),e("h3",{attrs:{id:"redis-有哪些数据类型-基础数据结构有几种-你还知道哪些-redis-的高级数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-有哪些数据类型-基础数据结构有几种-你还知道哪些-redis-的高级数据结构"}},[v._v("#")]),v._v(" Redis 有哪些数据类型？基础数据结构有几种？你还知道哪些 Redis 的高级数据结构？")]),v._v(" "),e("p",[v._v("Redis 支持多种数据类型，不同的数据类型可以满足不同的需求。下面是 Redis 中常用的数据类型：")]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("String")]),v._v("（字符串）：Redis 中最基本的数据类型，可以存储任何形式的数据，例如整数、浮点数、二进制数据等。")]),v._v(" "),e("li",[e("strong",[v._v("Hash")]),v._v("（哈希）：Redis 中的一种键值对类型，可以存储多个键值对，每个键值对又是一个键值对结构。")]),v._v(" "),e("li",[e("strong",[v._v("List")]),v._v("（列表）：Redis 中的一个有序列表类型，可以存储多个元素，每个元素都有一个索引，支持多种列表操作，例如插入、删除、查找等。")]),v._v(" "),e("li",[v._v("Set（集合）：Redis 中的一种无序集合类型，可以存储多个元素，每个元素都是唯一的，支持多种集合操作，例如交集、并集、差集等。")]),v._v(" "),e("li",[v._v("Sorted Set（有序集合）：Redis 中的一种有序集合类型，可以存储多个元素，每个元素都有一个分值，支持根据分值进行排序和查询等操作。")])]),v._v(" "),e("p",[e("strong",[v._v("Redis 的基础数据结构有三种：字符串、列表和哈希")]),v._v("，其他的数据类型都是基于这三种数据结构进行扩展和衍生的。例如，Redis 的 Set 数据类型就是基于字符串实现的。")]),v._v(" "),e("p",[v._v("除了基础数据结构之外，Redis 还提供了多种高级数据结构，例如：")]),v._v(" "),e("ol",[e("li",[v._v("HyperLogLog：一种基数估计算法，用于估计一个数据集合的基数。")]),v._v(" "),e("li",[v._v("GeoHash：一种地理位置编码算法，可以对地理位置信息进行编码和查询。")]),v._v(" "),e("li",[v._v("Pub/Sub：一种消息队列机制，可以实现消息的订阅和发布。")]),v._v(" "),e("li",[v._v("Bitmaps：一种位图数据结构，可以进行高效的位运算，用于统计用户在线时长、网站访问量等。")]),v._v(" "),e("li",[v._v("Lua 脚本：Redis 中可以使用 Lua 脚本进行扩展和定制，可以实现一些复杂的业务逻辑和算法。")])]),v._v(" "),e("h3",{attrs:{id:"redis-6-0-之后为何引入了多线程-6-0-之前为什么不使用多线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-6-0-之后为何引入了多线程-6-0-之前为什么不使用多线程"}},[v._v("#")]),v._v(" Redis 6.0 之后为何引入了多线程？6.0 之前为什么不使用多线程？")]),v._v(" "),e("p",[v._v("在 Redis 6.0 之前，Redis 只采用单线程的方式处理所有的请求，这种单线程架构的好处就是实现简单，没有锁的竞争和线程上下文切换等等的开销，可以让 Redis 在单个 CPU 上安心地运行。")]),v._v(" "),e("p",[v._v("在 Redis 6.0 之后，引入多线程主要是为了进一步提高 Redis 的吞吐量和性能，使其能更好的处理大规模的数据的场景。相较于单线程的模型，多线程的模型主要是能在处理大规模数据的时候充分利用多核 CPU 的优势，从而提高性能。")]),v._v(" "),e("p",[v._v("Redis 通过在核心中添加一个 I/O线程池 来实现多线程的功能。这个 I/O线程池包含多个 I/O线程，每个线程都可以独立地进行读写操作，通过这种方式，可以将网络 I/O 操作从主线程中分离出来，从而使主线程可以专注于处理 Redis 的核心功能，例如数据处理和命令执行。 在 Redis 6.0 之前采用单线程而不是用多线程主要有以下几个原因：")]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("单线程模型简单高效")]),v._v("：单线程模型避免了多线程之间的竞争和锁的开销，从而使得 Redis 在单核 CPU 上的性能非常出色；")]),v._v(" "),e("li",[e("strong",[v._v("避免锁竞争和死锁问题")]),v._v("：多线程之间的锁竞争和死锁问题是非常复杂和难以调试的，因此单线程模型在一定程度上减少了系统的复杂度；")]),v._v(" "),e("li",[e("strong",[v._v("内存访问局部性")]),v._v("：单线程模型能够保证 Redis 在内存中的数据访问具有局部性，这样可以充分利用 CPU 的缓存，提高系统的性能；")]),v._v(" "),e("li",[e("strong",[v._v("简化并发编程")]),v._v("：多线程编程是非常困难和复杂的，需要处理诸如线程同步、锁竞争、死锁、数据一致性等问题，而单线程模型避免了这些问题，使得 Redis 的开发和维护变得更加简单和高效。")])]),v._v(" "),e("h3",{attrs:{id:"讲一下-redis-中的内存淘汰机制、有哪些内存淘汰策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#讲一下-redis-中的内存淘汰机制、有哪些内存淘汰策略"}},[v._v("#")]),v._v(" 讲一下 Redis 中的内存淘汰机制、有哪些内存淘汰策略？")]),v._v(" "),e("p",[v._v("Redis 是一种基于内存的键值数据库，由于内存有限，当 Redis 占用的内存达到上限时，就需要进行内存淘汰，以腾出一些内存空间。")]),v._v(" "),e("p",[e("strong",[v._v("Redis 中的内存淘汰机制包括：")])]),v._v(" "),e("ol",[e("li",[v._v("定期删除：Redis 可以设置一个定时器，定期扫描键空间中的键，并删除已经过期的键。")]),v._v(" "),e("li",[v._v("惰性删除：当一个键过期时，Redis 不会立即删除该键，而是等到该键被访问时再删除。")]),v._v(" "),e("li",[v._v("内存淘汰策略：当 Redis 内存占用达到上限时，会根据内存淘汰策略来选择一些键进行删除，以腾出更多的内存空间。")])]),v._v(" "),e("p",[e("strong",[v._v("Redis 中的内存淘汰策略包括：")])]),v._v(" "),e("ol",[e("li",[v._v("noeviction：禁止删除键，即不做任何操作。")]),v._v(" "),e("li",[v._v("allkeys-lru：从所有的键中选择最近最少使用的键进行删除。")]),v._v(" "),e("li",[v._v("allkeys-random：从所有的键中随机选择一些键进行删除。")]),v._v(" "),e("li",[v._v("volatile-lru：从已设置过期时间的键中选择最近最少使用的键进行删除。")]),v._v(" "),e("li",[v._v("volatile-random：从已设置过期时间的键中随机选择一些键进行删除。")]),v._v(" "),e("li",[v._v("volatile-ttl：从已设置过期时间的键中选择剩余时间最短的键进行删除。")])]),v._v(" "),e("p",[v._v("4.0 版本后增加以下两种：")]),v._v(" "),e("ol",[e("li",[v._v("volatile-lfu（least frequently used）：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰")]),v._v(" "),e("li",[v._v("allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key")])]),v._v(" "),e("p",[v._v("其中，noeviction 策略是最简单的策略，但可能会导致 Redis 内存占满，并导致 Redis 无法正常工作。其他策略则会根据不同的算法进行键的选择和删除，以尽可能地保留重要的键。")]),v._v(" "),e("p",[v._v("总之，Redis 中的内存淘汰机制是保证 Redis 正常运行的重要机制之一，内存淘汰策略则根据不同的场景选择合适的策略来删除不必要的键，以腾出更多的内存空间。")]),v._v(" "),e("h3",{attrs:{id:"如何使用-redis-实现分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何使用-redis-实现分布式锁"}},[v._v("#")]),v._v(" 如何使用 Redis 实现分布式锁？")]),v._v(" "),e("p",[v._v("（"),e("strong",[v._v("关键词：原子性、setnx、setex、Redission、lua脚本")]),v._v("）")]),v._v(" "),e("p",[v._v("使用 Redis 实现分布式锁的基本思路就是使用 Redis 的原子性操作来确保多个客户端之间只有一个客户端可以成功获取锁。")]),v._v(" "),e("ol",[e("li",[v._v("获取锁：客户端尝试获取锁，可以使用Redis的"),e("code",[v._v("SET")]),v._v("命令结合"),e("code",[v._v("NX")]),v._v("和"),e("code",[v._v("EX")]),v._v("选项来实现。"),e("code",[v._v("SET")]),v._v("命令用于设置一个键值对，"),e("code",[v._v("NX")]),v._v("选项表示只有在键不存在时才设置，"),e("code",[v._v("EX")]),v._v("选项表示设置一个过期时间（单位为秒）。 示例："),e("code",[v._v("SET lock_key unique_value NX EX 30")]),v._v("。这个命令表示如果"),e("code",[v._v("lock_key")]),v._v("不存在，就设置它的值为"),e("code",[v._v("unique_value")]),v._v("，并设置30秒的过期时间。如果设置成功，表示获取锁成功；如果设置失败，表示锁已被其他客户端持有，需要等待或重试。")]),v._v(" "),e("li",[v._v("持有锁：在持有锁的客户端执行临界区代码。在此期间，其他客户端无法获取锁。")]),v._v(" "),e("li",[v._v("释放锁：在临界区代码执行完毕后，需要释放锁以供其他客户端使用。为了避免误解锁的情况（例如，由于执行时间过长导致锁过期，然后被其他客户端获取），在释放锁时需要检查锁的值是否与获取锁时设置的值相同。这可以通过Redis的"),e("code",[v._v("EVAL")]),v._v("命令来实现，使用Lua脚本进行原子性操作。 示例："),e("code",[v._v("EVAL \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\" 1 lock_key unique_value")]),v._v("。这个命令表示检查"),e("code",[v._v("lock_key")]),v._v("的值是否为"),e("code",[v._v("unique_value")]),v._v("，如果是，则删除"),e("code",[v._v("lock_key")]),v._v("以释放锁；否则不执行任何操作。")])]),v._v(" "),e("p",[v._v("通过以上步骤，可以实现一个基本的Redis分布式锁。在实际应用中，还需要考虑一些其他因素，例如获取锁的重试策略、锁的续期等。")]),v._v(" "),e("h3",{attrs:{id:"redis-持久化机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化机制"}},[v._v("#")]),v._v(" Redis 持久化机制")]),v._v(" "),e("h3",{attrs:{id:"redis-缓存雪崩、缓存击穿、缓存穿透分别是什么-应该如何避免"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-缓存雪崩、缓存击穿、缓存穿透分别是什么-应该如何避免"}},[v._v("#")]),v._v(" Redis 缓存雪崩、缓存击穿、缓存穿透分别是什么？应该如何避免？")])])}),[],!1,null,null,null);e.default=i.exports}}]);