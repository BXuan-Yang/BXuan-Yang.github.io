<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TCP | BXuan随笔</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="欢迎来到 BXuan 的✨个人网站✨👏👏👏！">
    
    <link rel="preload" href="/assets/css/0.styles.72717b73.css" as="style"><link rel="preload" href="/assets/js/app.c7952645.js" as="script"><link rel="preload" href="/assets/js/2.53ba99d7.js" as="script"><link rel="preload" href="/assets/js/60.497110a7.js" as="script"><link rel="prefetch" href="/assets/js/10.4ab63f7a.js"><link rel="prefetch" href="/assets/js/11.982bd386.js"><link rel="prefetch" href="/assets/js/12.0b6105e0.js"><link rel="prefetch" href="/assets/js/13.0b88c945.js"><link rel="prefetch" href="/assets/js/14.32b6e670.js"><link rel="prefetch" href="/assets/js/15.1651a6b7.js"><link rel="prefetch" href="/assets/js/16.55e08c05.js"><link rel="prefetch" href="/assets/js/17.6d98ee08.js"><link rel="prefetch" href="/assets/js/18.fc4ae118.js"><link rel="prefetch" href="/assets/js/19.ea630d0e.js"><link rel="prefetch" href="/assets/js/20.6151654c.js"><link rel="prefetch" href="/assets/js/21.1ddadd96.js"><link rel="prefetch" href="/assets/js/22.6e312c0e.js"><link rel="prefetch" href="/assets/js/23.ab691b41.js"><link rel="prefetch" href="/assets/js/24.6667f20a.js"><link rel="prefetch" href="/assets/js/25.517e4303.js"><link rel="prefetch" href="/assets/js/26.c92294b8.js"><link rel="prefetch" href="/assets/js/27.30245c81.js"><link rel="prefetch" href="/assets/js/28.83f84f64.js"><link rel="prefetch" href="/assets/js/29.2ebf177e.js"><link rel="prefetch" href="/assets/js/3.c16bd42d.js"><link rel="prefetch" href="/assets/js/30.15f1115b.js"><link rel="prefetch" href="/assets/js/31.271bb831.js"><link rel="prefetch" href="/assets/js/32.a3ffc84b.js"><link rel="prefetch" href="/assets/js/33.837c492d.js"><link rel="prefetch" href="/assets/js/34.6535b864.js"><link rel="prefetch" href="/assets/js/35.a9f35d11.js"><link rel="prefetch" href="/assets/js/36.58c71fa7.js"><link rel="prefetch" href="/assets/js/37.536c34aa.js"><link rel="prefetch" href="/assets/js/38.dca08340.js"><link rel="prefetch" href="/assets/js/39.20e843ec.js"><link rel="prefetch" href="/assets/js/4.d6c515d3.js"><link rel="prefetch" href="/assets/js/40.f33282da.js"><link rel="prefetch" href="/assets/js/41.0afdb83a.js"><link rel="prefetch" href="/assets/js/42.68f5e469.js"><link rel="prefetch" href="/assets/js/43.65a3e240.js"><link rel="prefetch" href="/assets/js/44.0429a345.js"><link rel="prefetch" href="/assets/js/45.61c6d807.js"><link rel="prefetch" href="/assets/js/46.69ea8e4b.js"><link rel="prefetch" href="/assets/js/47.21cbd519.js"><link rel="prefetch" href="/assets/js/48.b46e7243.js"><link rel="prefetch" href="/assets/js/49.8f93a744.js"><link rel="prefetch" href="/assets/js/5.65846da7.js"><link rel="prefetch" href="/assets/js/50.323a9f2b.js"><link rel="prefetch" href="/assets/js/51.731382e7.js"><link rel="prefetch" href="/assets/js/52.429c91e1.js"><link rel="prefetch" href="/assets/js/53.6ad30434.js"><link rel="prefetch" href="/assets/js/54.c2c209db.js"><link rel="prefetch" href="/assets/js/55.36509a79.js"><link rel="prefetch" href="/assets/js/56.442c1774.js"><link rel="prefetch" href="/assets/js/57.104714c1.js"><link rel="prefetch" href="/assets/js/58.d1eb3d61.js"><link rel="prefetch" href="/assets/js/59.7642ee42.js"><link rel="prefetch" href="/assets/js/6.1cca85df.js"><link rel="prefetch" href="/assets/js/61.9456cece.js"><link rel="prefetch" href="/assets/js/62.4acf84cc.js"><link rel="prefetch" href="/assets/js/63.649869e0.js"><link rel="prefetch" href="/assets/js/64.a9a2a5e7.js"><link rel="prefetch" href="/assets/js/65.caf50992.js"><link rel="prefetch" href="/assets/js/66.a082df91.js"><link rel="prefetch" href="/assets/js/67.77906dd6.js"><link rel="prefetch" href="/assets/js/68.b187b7a3.js"><link rel="prefetch" href="/assets/js/69.d4e466ec.js"><link rel="prefetch" href="/assets/js/7.e19e61cb.js"><link rel="prefetch" href="/assets/js/70.d3e767af.js"><link rel="prefetch" href="/assets/js/71.b195f372.js"><link rel="prefetch" href="/assets/js/72.394bd04d.js"><link rel="prefetch" href="/assets/js/73.cca17919.js"><link rel="prefetch" href="/assets/js/74.91e1d2ef.js"><link rel="prefetch" href="/assets/js/75.6f26e213.js"><link rel="prefetch" href="/assets/js/76.9ae90df7.js"><link rel="prefetch" href="/assets/js/77.1220dc5d.js"><link rel="prefetch" href="/assets/js/78.d80a520f.js"><link rel="prefetch" href="/assets/js/79.d22d4bb9.js"><link rel="prefetch" href="/assets/js/8.c222cd7c.js"><link rel="prefetch" href="/assets/js/9.55b8fde2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.72717b73.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="BXuan随笔" class="logo"> <span class="site-name can-hide">BXuan随笔</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/network/" class="nav-link router-link-active">
  🍔计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog/os/" class="nav-link">
  🍟操作系统
</a></li><li class="dropdown-item"><!----> <a href="/blog/algo/" class="nav-link">
  🍕数据结构与算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link">
  🌭Java
</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">
  🍿Go
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件开发" class="dropdown-title"><span class="title">软件开发</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件开发" class="mobile-dropdown-title"><span class="title">软件开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          🌮数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/blog/redis/" class="nav-link">
  Redis
</a></li></ul></li><li class="dropdown-item"><h4>
          🥪开发框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/frame/spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-subitem"><a href="/blog/frame/springboot/" class="nav-link">
  SpringBoot
</a></li></ul></li><li class="dropdown-item"><h4>
          🥟架构设计
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/schemadesigner/" class="nav-link">
  设计模式
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件测试" class="dropdown-title"><span class="title">软件测试</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件测试" class="mobile-dropdown-title"><span class="title">软件测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/softwaretest/baseOfSoftwareTest/" class="nav-link">
  🥓软件测试基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章阅读" class="dropdown-title"><span class="title">文章阅读</span> <span class="arrow down"></span></button> <button type="button" aria-label="文章阅读" class="mobile-dropdown-title"><span class="title">文章阅读</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/interview/all.html" class="nav-link">
  💪面经汇总
</a></li><li class="dropdown-item"><!----> <a href="/blog/other/" class="nav-link">
  🧀其他阅读
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/BXuan-Yang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github🙋‍♂️
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/network/" class="nav-link router-link-active">
  🍔计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog/os/" class="nav-link">
  🍟操作系统
</a></li><li class="dropdown-item"><!----> <a href="/blog/algo/" class="nav-link">
  🍕数据结构与算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link">
  🌭Java
</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">
  🍿Go
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件开发" class="dropdown-title"><span class="title">软件开发</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件开发" class="mobile-dropdown-title"><span class="title">软件开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          🌮数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/blog/redis/" class="nav-link">
  Redis
</a></li></ul></li><li class="dropdown-item"><h4>
          🥪开发框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/frame/spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-subitem"><a href="/blog/frame/springboot/" class="nav-link">
  SpringBoot
</a></li></ul></li><li class="dropdown-item"><h4>
          🥟架构设计
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/schemadesigner/" class="nav-link">
  设计模式
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件测试" class="dropdown-title"><span class="title">软件测试</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件测试" class="mobile-dropdown-title"><span class="title">软件测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/softwaretest/baseOfSoftwareTest/" class="nav-link">
  🥓软件测试基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章阅读" class="dropdown-title"><span class="title">文章阅读</span> <span class="arrow down"></span></button> <button type="button" aria-label="文章阅读" class="mobile-dropdown-title"><span class="title">文章阅读</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/interview/all.html" class="nav-link">
  💪面经汇总
</a></li><li class="dropdown-item"><!----> <a href="/blog/other/" class="nav-link">
  🧀其他阅读
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/BXuan-Yang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github🙋‍♂️
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/network/HTTP.html" class="sidebar-link">HTTP</a></li><li><a href="/blog/network/TCP.html" aria-current="page" class="active sidebar-link">TCP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#对于-tcp-基本的认识" class="sidebar-link">对于 TCP 基本的认识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp-头格式" class="sidebar-link">TCP 头格式</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#为什么需要tcp协议-其工作在哪一层" class="sidebar-link">为什么需要TCP协议？其工作在哪一层？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#什么是tcp" class="sidebar-link">什么是TCP？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#什么是-udp" class="sidebar-link">什么是 UDP？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#什么是tcp连接" class="sidebar-link">什么是TCP连接？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#如何确定一个唯一的tcp连接" class="sidebar-link">如何确定一个唯一的TCP连接？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#有一个ip的服务端监听了一个端口-其tcp连接数最大是多少" class="sidebar-link">有一个IP的服务端监听了一个端口，其TCP连接数最大是多少？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#udp-和-tcp-有什么区别" class="sidebar-link">UDP 和 TCP 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp和udp的应用场景" class="sidebar-link">TCP和UDP的应用场景？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#为什么-udp-头部没有「首部长度」字段-而-tcp-头部有「首部长度」字段呢" class="sidebar-link">为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp和udp可以使用同一个端口吗" class="sidebar-link">TCP和UDP可以使用同一个端口吗？</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp-建立连接" class="sidebar-link">TCP 建立连接</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp-三次握手的过程" class="sidebar-link">TCP 三次握手的过程？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#为什么是三次握手-不是两次或者四次" class="sidebar-link">为什么是三次握手，不是两次或者四次？</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp-断开连接" class="sidebar-link">TCP 断开连接</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp-四次挥手的过程" class="sidebar-link">TCP 四次挥手的过程</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#第一次挥手丢失-会发生什么" class="sidebar-link">第一次挥手丢失，会发生什么？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#第二次挥手丢失-会发生什么" class="sidebar-link">第二次挥手丢失，会发生什么？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#第三次挥手丢失-会发生什么" class="sidebar-link">第三次挥手丢失，会发生什么？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#第四次挥手丢失-会发生什么" class="sidebar-link">第四次挥手丢失，会发生什么？</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp-ip网络模型" class="sidebar-link">TCP/IP网络模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#为什么需要网络模型" class="sidebar-link">为什么需要网络模型？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#为什么网络模型需要分层呢" class="sidebar-link">为什么网络模型需要分层呢？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#应用层" class="sidebar-link">应用层</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#传输层" class="sidebar-link">传输层</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#网络层" class="sidebar-link">网络层</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#网络接口层" class="sidebar-link">网络接口层</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#相关链接" class="sidebar-link">相关链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#osi-七层模型" class="sidebar-link">OSI 七层模型</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp-重传机制、滑动窗口、流量控制、拥塞控制" class="sidebar-link">TCP 重传机制、滑动窗口、流量控制、拥塞控制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#重传机制" class="sidebar-link">重传机制</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#滑动窗口" class="sidebar-link">滑动窗口</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#流量控制" class="sidebar-link">流量控制</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#拥塞控制" class="sidebar-link">拥塞控制</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp-ip-和-tcp、ip-有什么关系" class="sidebar-link">TCP/IP 和 TCP、IP 有什么关系？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp-分段与-udp-ip-分片" class="sidebar-link">TCP 分段与 UDP/IP 分片</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#tcp粘包和拆包的问题" class="sidebar-link">TCP粘包和拆包的问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#什么是-tcp粘包和拆包-呢" class="sidebar-link">什么是 TCP粘包和拆包 呢？</a></li><li class="sidebar-sub-header"><a href="/blog/network/TCP.html#如何解决-tcp粘包和拆包-问题呢" class="sidebar-link">如何解决 TCP粘包和拆包 问题呢？</a></li></ul></li></ul></li><li><a href="/blog/network/what_happen_url.html" class="sidebar-link">输入一个网址直到网页显示的期间，发生了什么？</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="tcp"><a href="#tcp" class="header-anchor">#</a> TCP</h1> <h2 id="对于-tcp-基本的认识"><a href="#对于-tcp-基本的认识" class="header-anchor">#</a> 对于 TCP 基本的认识</h2> <h3 id="tcp-头格式"><a href="#tcp-头格式" class="header-anchor">#</a> TCP 头格式</h3> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230418155437745.png" alt="image-20230418155437745"></p> <p><strong>序列号</strong>：在建立连接时由<strong>计算机生成的随机数</strong>作为其初始值，通过 <strong>SYN 包</strong>传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p> <p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p> <p><strong>控制位：</strong></p> <ul><li><em><strong>ACK</strong></em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li> <li><em><strong>RST</strong></em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li> <li><em><strong>SYN</strong></em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li> <li><em><strong>FIN</strong></em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul> <h3 id="为什么需要tcp协议-其工作在哪一层"><a href="#为什么需要tcp协议-其工作在哪一层" class="header-anchor">#</a> 为什么需要TCP协议？其工作在哪一层？</h3> <p>TCP 协议是工作在传输层上的一个协议。它能保证数据在传输层上进行安全地、可靠地传输。所以为什么需要 TCP 协议的存在呢？</p> <p>因为在网络层中的 IP 协议，是不可靠的，它不能保证网络包的交付是否能安全、按序号地到达，也不能保证网络包数据的完整性。此时就需要其上层的传输层来保证网络包的安全交付。（能确保接收端接收的网络包是 <strong>无损坏、无间隔、非冗余和按序的</strong>）</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310085947419.png" alt="image-20230310085947419"></p> <h3 id="什么是tcp"><a href="#什么是tcp" class="header-anchor">#</a> 什么是TCP？</h3> <p>TCP（又称 <strong>传输控制协议</strong>）是 <strong>面向连接的、可靠的、基于字节流</strong> 的传输层通信协议。</p> <ul><li><strong>面向连接</strong>：一定是「<strong>一对一</strong>」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li> <li><strong>可靠的</strong>：无论网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li> <li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统「分组」成多个的 TCP 报文</strong>，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul> <h3 id="什么是-udp"><a href="#什么是-udp" class="header-anchor">#</a> 什么是 UDP？</h3> <p><strong>UDP</strong>（又称 <strong>用户数据报协议</strong>），协议的特点是 <strong>无连接、不可靠、面向数据报</strong> 的，整个过程就像是寄信的一个过程，每次接收和发送数据都是整体发送（不会进行分片）</p> <ul><li><strong>无连接</strong>：知道接收端的 IP 以及端口号就可以进行传输，不需要建立连接；</li> <li><strong>不可靠</strong>：没有重传机制、确认机制。如果是因为网络故障没法发送给给对方，UDP 也不会给应用层返回任何错误信息；</li> <li><strong>面向数据报</strong>：不能够灵活地控制读写数据的次数以及数量</li></ul> <h3 id="什么是tcp连接"><a href="#什么是tcp连接" class="header-anchor">#</a> 什么是TCP连接？</h3> <p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接</strong>。</p> <p>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端端达成上述三个信息的共识。</p> <ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li> <li><strong>序列号</strong>：用来解决乱序问题等</li> <li><strong>窗口大小</strong>：用来做流量控制</li></ul> <h3 id="如何确定一个唯一的tcp连接"><a href="#如何确定一个唯一的tcp连接" class="header-anchor">#</a> 如何确定一个唯一的TCP连接？</h3> <p>通过一个 <strong>TCP 四元组</strong> 就可以唯一确定一个 TCP 连接：</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310090120931.png" alt="image-20230310090120931"></p> <p>源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。（IP 地址）</p> <p>源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p> <h3 id="有一个ip的服务端监听了一个端口-其tcp连接数最大是多少"><a href="#有一个ip的服务端监听了一个端口-其tcp连接数最大是多少" class="header-anchor">#</a> 有一个IP的服务端监听了一个端口，其TCP连接数最大是多少？</h3> <p>服务端通常固定在某个本地端口上监听，等待客户端的连接请求。</p> <p>因此，客户端 IP 和 端口是可变的，其计算公式如下：</p> <p><strong>TCP最大连接数 = 客户端 IP 数 * 客户端端口数</strong></p> <p>服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p> <ul><li><p>文件描述符限制</p> <p>每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：</p> <ul><li><strong>系统级</strong>：当前系统可打开的最大数量，通过 cat /proc/sys/fs/file-max 查看；</li> <li><strong>用户级</strong>：指定用户可打开的最大数量，通过 cat /etc/security/limits.conf 查看；</li> <li><strong>进程级</strong>：单个进程可打开的最大数量，通过 cat /proc/sys/fs/nr_open 查看；</li></ul></li> <li><p><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</p></li></ul> <h3 id="udp-和-tcp-有什么区别"><a href="#udp-和-tcp-有什么区别" class="header-anchor">#</a> UDP 和 TCP 有什么区别？</h3> <p>1、连接</p> <ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立一对一连接。</li> <li>UDP 是不需要连接的，只要知道目标 IP 以及 端口号 就可以立马传输数据。</li></ul> <p>2、服务对象</p> <ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li> <li>UDP 支持 <strong>一对一、一对多、多对多</strong> 的交互通信</li></ul> <p>3、可靠性</p> <ul><li><strong>TCP 是可靠交付数据的</strong>，数据可以无差错、不丢失、不重复、按序到达。</li> <li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul> <p>4、拥塞控制、流量控制</p> <ul><li>TCP 有 <strong>拥塞控制和流量控制</strong> 机制，保证数据传输的安全性。</li> <li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul> <p>5、首部开销</p> <ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的，最大是 60 个字节。</li> <li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul> <p>6、传输方式</p> <ul><li>TCP 是流式传输（基于字节流传输），没有边界，但保证顺序和可靠。</li> <li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul> <p>7、分片不同</p> <ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li> <li>UDP 的数据大小如果大于 MTU 大小，则会<strong>在网络层进行分片</strong>，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/d7df0cbcf0e14108b686630c647a3700.png" alt="img"></p> <h3 id="tcp和udp的应用场景"><a href="#tcp和udp的应用场景" class="header-anchor">#</a> TCP和UDP的应用场景？</h3> <p>由于 <strong>TCP 是面向连接，能保证数据的可靠性交付</strong>，因此经常用于：</p> <ul><li><code>FTP</code> 文件传输；</li> <li>HTTP / HTTPS；</li></ul> <p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p> <ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li> <li>视频、音频等多媒体通信；</li> <li>广播通信；</li></ul> <h3 id="为什么-udp-头部没有「首部长度」字段-而-tcp-头部有「首部长度」字段呢"><a href="#为什么-udp-头部没有「首部长度」字段-而-tcp-头部有「首部长度」字段呢" class="header-anchor">#</a> 为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</h3> <p>因为 TCP 的首部长度是不确定的，是一个 <strong>可变长</strong> 的「选项」字段，但是 UDP 头部长度则是<strong>不会变化</strong>的，所以 TCP 需要有一个字段来声明 首部长度，而 UDP 无需多一个字段去记录 UDP 的首部长度。</p> <h3 id="tcp和udp可以使用同一个端口吗"><a href="#tcp和udp可以使用同一个端口吗" class="header-anchor">#</a> TCP和UDP可以使用同一个端口吗？</h3> <p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。</p> <p>在网络层中，通过 IP 地址来寻找网络中互连的主机或路由器。</p> <p>在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p> <p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p> <p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p> <p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p> <p>因此，TCP/UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310090418909.png" alt="image-20230310090418909"></p> <h2 id="tcp-建立连接"><a href="#tcp-建立连接" class="header-anchor">#</a> TCP 建立连接</h2> <h3 id="tcp-三次握手的过程"><a href="#tcp-三次握手的过程" class="header-anchor">#</a> TCP 三次握手的过程？</h3> <p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手来进行的</strong>。</p> <p>三次握手的过程如下图：</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230414144846601.png" alt="image-20230414144846601"></p> <ul><li>在刚开始的时候，客户端 和 服务端都是处于 <strong>CLOSE</strong> 状态。先是 服务器主动监听某个端口，处于 LISTEN 状态。</li> <li>客户端随机初始化序号 client_isn，将此序号至于 TCP 首部的 序列号 字段中，同时把 SYN 标志位置设置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据信息，接着 客户端 进入 SYN_SENT 状态。</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230414151621002.png" alt="image-20230414151621002"></p> <ul><li>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的 序列号（server_isn），然后将此序号填入 TCP 首部的 【序列号】字段中，其次将 TCP 首部的【确认应答号】字段填入 client_isn + 1，接着把 SYN 和 ACK 标志位置设置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN_RCVD 状态。</li></ul> <p>在上面的过程中，第三次是可以携带数据的，前两次是没有携带数据的。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230314210442026.png" alt="image-20230314210442026"></p> <h3 id="为什么是三次握手-不是两次或者四次"><a href="#为什么是三次握手-不是两次或者四次" class="header-anchor">#</a> 为什么是三次握手，不是两次或者四次？</h3> <p>我们知道了什么是 <strong>TCP 连接</strong>：</p> <ul><li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket、序列号和窗口大小</strong>称为连接。</li></ul> <p>所以，重要的是<strong>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。</strong></p> <p>接下来，以三个方面分析三次握手的原因：</p> <ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li> <li>三次握手才可以同步双方的初始序列号</li> <li>三次握手才可以避免资源浪费</li></ul> <h2 id="tcp-断开连接"><a href="#tcp-断开连接" class="header-anchor">#</a> TCP 断开连接</h2> <h3 id="tcp-四次挥手的过程"><a href="#tcp-四次挥手的过程" class="header-anchor">#</a> TCP 四次挥手的过程</h3> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p> <ul><li>客户端打算关闭连接（准备进行四次挥手），首先发送一个 TCP 首部 <strong>FIN</strong> 标志位 被设置为 1 的报文，之后客户端进入 <strong>FIN_WAIT_1</strong> 的状态。</li> <li>服务端收到该报文后，就向客户端发送 <strong>ACK</strong> 应答报文，之后服务端进入 <strong>CLOSED_WAIT</strong> 状态。</li> <li>客户端收到服务端的 ACK 应答报文之后，进入 <strong>FIN_WAIT_2</strong> 状态。</li> <li>等待服务端处理完数据之后，也向客户端发送 FIN 报文，之后服务端进入 <strong>LAST_ACK</strong> 状态。</li> <li>客户端收到服务端的 FIN 报文后，回复一个 ACK 应答报文，之后进入 <strong>TIME_WAIT</strong> 状态。</li> <li>服务端收到客户端的 ACK 报文之后，进入 CLOSE 状态，至此服务端已经完成连接的关闭。</li> <li>客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。</li></ul> <p>从上面的过程中可以得知，服务端通常需要等待 数据的发送和处理，所以服务端的 ACK 和 FIN 报文一般都会分开发送，所以就需要四次挥手。</p> <p>注意：<strong>主动关闭连接的，才有 TIME_WAIT 状态</strong>。</p> <h3 id="第一次挥手丢失-会发生什么"><a href="#第一次挥手丢失-会发生什么" class="header-anchor">#</a> 第一次挥手丢失，会发生什么？</h3> <p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务器断开连接，此时客户端的状态是 FIN_WAIT_1。</p> <p>正常情况下，如果能及时地收到服务端（被动关闭方）的 ACK，那么客户端的状态很快就会变成 FIN_WAIT_2（等再次收到服务端的 FIN 报文的时候，客户端的状态就会再次变化变成 TIME_WAIT）。</p> <p>如果第一次挥手丢失了，那么客户端迟迟收不到服务端的 ACK，此时就会触发 超时重传机制，重发 FIN 报文，重发次数由 tcp_orphan_retries 控制。</p> <p><strong>当客户端重发 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，就直接进入 close 状态</strong>。</p> <p>假设这里的 重发次数由 tcp_orphan_retries 为 3：</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230413201220038.png" alt="image-20230413201220038"></p> <h3 id="第二次挥手丢失-会发生什么"><a href="#第二次挥手丢失-会发生什么" class="header-anchor">#</a> 第二次挥手丢失，会发生什么？</h3> <p>当服务端收到客户端的第一次挥手后，会先回复给客户端一个 ACK 报文，此时服务端的状态会进入 CLOSE_WAIT 状态。</p> <p>ACK 报文是不会重传的，那么此时如果第二次挥手丢失（也就是服务端回答出的 ACK 报文丢失），此时客户端就会再次触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者是到达最大重传次数 tcp_orphan_retries 。</p> <p>假设这里的 最大重传次数 tcp_orphan_retries 为 2：</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230413201125538.png" alt="image-20230413201125538"></p> <p>如果当 客户端 收到第二次，也就是 服务端 成功发出了 ACK 应答报文并被接收，此时 客户端 就会处于 FIN_WAIT_2 的状态，在这个状态需要等 服务端 发送 FIN 报文（也就是开启第三次挥手才会关闭）。</p> <p>对于 <strong>close 函数</strong> 关闭的连接，由于无法再发送和接收数据，所以 FIN_WAIT_2 的状态不能持续太久，<strong>而 tcp_fin_timeout 控制了这个状态下连接的持续时长，默认值是 60 秒</strong>。这就意味着对于调用 close 函数关闭的连接，如果在 60 秒内还没有收到 服务端的 FIN 报文，客户端 的连接就会直接关闭。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230413202246823.png" alt="image-20230413202246823"></p> <p>但是对于 <strong>shutdown 函数</strong> 关闭的连接，制定了只关闭发送数据的方向，没有关闭接收数据的方向，意味着 客户端 可以接收数据但是不可以发送数据。此时，如果 客户端 一直没收到第三次挥手，那么 客户端 的连接一直处于 FIN_WAIT_2 的状态（tcp_fin_timeout 无法控制 shutdowm 函数的关闭）。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230413202532077.png" alt="image-20230413202532077"></p> <h3 id="第三次挥手丢失-会发生什么"><a href="#第三次挥手丢失-会发生什么" class="header-anchor">#</a> 第三次挥手丢失，会发生什么？</h3> <p>当 服务端 收到 客户端 的 FIN 报文后，服务端内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态，此时它在等待着 <strong>应用进程调用 close 函数关闭连接</strong>。此时 服务器内核 是没有权利来代替进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。</p> <p>服务端此时是处于 CLOSE_WAIT 状态，调用了 close 函数，内核就会发出 FIN 报文，同时连接是进入 LAST_ACK 状态，等待客户端返回 ACK 报文来确认连接关闭。如果迟迟收不到 ACK，那么服务端就会重发 FIN 报文，重发的次数仍旧是由 最大重传次数 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的控制方式是一样的。</p> <p>下面假设 tcp_orphan_retries = 3：</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230413233305054.png" alt="image-20230413233305054"></p> <ol><li>当服务端重发 第三次挥手的 FIN 报文的次数达到了 tcp_orphan_retries 的次数之后，达到了最大重传次数，于是会再继续等待一段时间（时间为上一次重传超时时间的 2 倍），如果还是没有收到客户端传来的 ACK 报文，那么服务端会自动断开连接。</li> <li>客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态，是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手报文（FIN 报文），那么客户端会选择自动断开连接。</li></ol> <h3 id="第四次挥手丢失-会发生什么"><a href="#第四次挥手丢失-会发生什么" class="header-anchor">#</a> 第四次挥手丢失，会发生什么？</h3> <p>客户端收到服务端的第三次挥手的 FIN 报文，正常就会回复给服务端 ACK 报文（也就是第四次挥手发送的报文），此时客户端进入 TIME_WAIT 状态。</p> <p>在 Linux 系统中，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。然后，服务端 在没有收到 ACK 报文之前，还是一直处于 LAST_ACK 状态。</p> <p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然是由 tcp_orphan_retries 参数来控制。</p> <p>下面假设 tcp_orphan_retries 为 2：</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230413234707848.png" alt="image-20230413234707848"></p> <ol><li>当服务端重传第三次挥手报文达 2 时，由于 tcp_orphan_retries 为 2，达到了最大重传次数。那么再继续等待一段时间（即是上一次重传超时时间的 2 倍），如果还是没有能及时收到客户端第四次的挥手报文（ACK 报文），服务端就会自动断开连接</li> <li>客户端在收到第三次握手的时候，就会进入 TIME_WAIT 状态，同时开启时长为 2MSL 的定时器，如果途中再次受到了第三次挥手的报文（服务端传的 FIN 报文），那么计时器会重置。当等待的时长超过 2MSL 时长后，客户端就会自动断开连接。</li></ol> <h2 id="tcp-ip网络模型"><a href="#tcp-ip网络模型" class="header-anchor">#</a> TCP/IP网络模型</h2> <h3 id="为什么需要网络模型"><a href="#为什么需要网络模型" class="header-anchor">#</a> 为什么需要网络模型？</h3> <p>在对于同一台设备之间的进程通信，可以有很多种方式，如 <strong>管道、消息队列、共享内存、信号量</strong> 等方式；</p> <p>但是对于不同设备上的进程间的通信，就需要网络之间的通信。然而设备是多样性的，所以要兼容多种设备，就必须协盛出一套通用的网络协议。</p> <h3 id="为什么网络模型需要分层呢"><a href="#为什么网络模型需要分层呢" class="header-anchor">#</a> 为什么网络模型需要分层呢？</h3> <p>主要是为了降低复杂度、统一标准、工程模块化、快速发展、易于学习等目的；</p> <h3 id="应用层"><a href="#应用层" class="header-anchor">#</a> 应用层</h3> <p>应用层，也是直接能接触到的层次，<strong>平时使用的软件就是在应用层实现的</strong>。当两个不同设备的应用需要通信的时候，应用层就把数据传输给下一层，也就是传输层。</p> <p>应用层只关心为用户去提供应用服务，如 <strong>HTTP</strong>、SMTP等。应用层不用去关心数据是如何传输的，就像是我们去寄快递，只是将快递拿给快递员，而不用担心快递是如何运输的。</p> <p>需要注意的是：应用层是工作在操作系统的用户态，而传输层及以下是工作在操作系统的内核态。</p> <h3 id="传输层"><a href="#传输层" class="header-anchor">#</a> 传输层</h3> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310213952574.png" alt="image-20230310213952574"></p> <p>传输层为应用层提供 <strong>网络支持</strong>，应用层的数据会传输给传输层。传输层使用的两个协议是 TCP、UDP。</p> <p><strong>TCP（传输控制协议）</strong>，大部分应用使用的是 TCP 协议，如 HTTP 应用层协议。TCP 相较于 UDP 有很多的特性，如：流量控制、重传机制、拥塞控制等，这些机制都是为了保证数据能够安全、可靠地传输给对方；</p> <p><strong>UDP（用户数据报协议）</strong>， 比较简单，只是负责发送数据包，不保证数据是否可靠地传输给了对方，但是它的实时性更好，传输效率也比较高。但是，UDP 也可以实现可靠传输，可以将 TCP 的特性在应用层上实现，不过比较困难。</p> <p>因为应用需要传输的数据可能非常大，如果直接传输就可能不太好控制，会发生数据丢失等情况，因此当传输层的数据包大小超过 <strong>MSS</strong>（TCP 最大报文段长度） 的时候，就会将数据进行分块，这样即使数据在传输的过程中丢失了，我们也可以做到只传输丢失的那一块即可，不用全部重新发送。在 TCP 协议中，我们将每一个分块称为 <strong>TCP 段</strong>。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310215042250.png" alt="image-20230310215042250"></p> <p><strong>当此台设备作为接收方的时候，传输层的作用就是将数据包传给应用</strong>，但是一台设备上可能有多个应用在接收或者传输数据，因此，我们会使用 编号（端口）将应用区分开来。</p> <p>比如：80 端口 是 Web 服务器用的，22 端口是远程登录服务器用。对于浏览器中的每个标签栏都是一个独立的进程，操作系统会为每一个进程单独分配临时的、合适的端口号。由于传输层的报文中会携带端口号，所以接收方可以识别出该报文是要传送给哪个应用的。</p> <h3 id="网络层"><a href="#网络层" class="header-anchor">#</a> 网络层</h3> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310220528047.png" alt="image-20230310220528047"></p> <p><strong>网络层</strong> 最常使用的协议是 <strong>IP 协议</strong>，IP 协议会将传输层的报文作为数据部分，加上 IP 包头组成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节），就会将 IP 数据再次进行分片，得到一个即将发送到网络的 IP 报文。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310220756955.png" alt="image-20230310220756955"></p> <p>世界上那么多设备，怎么将数据通过网络层传输给对方呢？</p> <p><strong>答案是：通过 IP 地址来寻址</strong>。</p> <p>IP 地址会分为两种意义：</p> <ul><li>网络号：负责标识该 IP 地址是属于哪个 子网 的；</li> <li>主机号：负责标识同一 子网 下的不同主机；</li></ul> <p>网络号与主机号需要配合 <strong>子网掩码</strong> 才能算出 IP 地址的网络号和主机号。</p> <p>在寻址的过程中，需要先匹配到相同的网络号（表示要找到同一个子网），才能去找相对应的主机。</p> <p>IP 协议还有一个重要的功能就是 <strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多 网关、路由器、交换机 等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310222500058.png" alt="image-20230310222500058"></p> <p><strong>IP  寻址</strong> 的作用就是告诉我们下一个目的地应该朝着哪个方向走。</p> <p><strong>路由</strong> 则是根据下一个目的地去选择合适的路径。寻址就像是在导航，而选择路由像是在操纵方向盘。</p> <h3 id="网络接口层"><a href="#网络接口层" class="header-anchor">#</a> 网络接口层</h3> <p>生成 IP 头部之后，接下来就要交给网络接口层，其在 IP 的头部加上 MAC 头部，并封装成 <strong>数据帧</strong> 发送到网络上。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310222946673.png" alt="image-20230310222946673"></p> <p>IP 头部中的接收方表示网络包的目的地，通过这个地址我们可以判断要将包发送到哪里去，但是在以太网的世界中，这个思路是不行的。</p> <p>以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的。所以，在以太网进行通讯要用到 MAC 地址。<strong>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址</strong>。</p> <p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>TCP/IP 四层网络模型如下：</p> <p><strong>应用层、传输层、网络层、网络接口层</strong></p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310223507853.png" alt="image-20230310223507853"></p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310223521401.png" alt="image-20230310223521401"></p> <p>传输的数据包在各层的昵称</p> <ul><li>HTTP：消息或报文</li> <li>TCP：段</li> <li>IP：包</li> <li>MAC：帧</li></ul> <h3 id="相关链接"><a href="#相关链接" class="header-anchor">#</a> 相关链接</h3> <p><a href="https://xiaolincoding.com/network/1_base/tcp_ip_model.html#%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="noopener noreferrer">小林Coding<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="osi-七层模型"><a href="#osi-七层模型" class="header-anchor">#</a> OSI 七层模型</h2> <p>OSI 网络模型是 ISO 组织定义的国际通用标准模型，目的是为了定义全球同一的网络标准模型</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310224213966.png" alt="image-20230310224213966"></p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310224511491.png" alt="image-20230310224511491"></p> <h2 id="tcp-重传机制、滑动窗口、流量控制、拥塞控制"><a href="#tcp-重传机制、滑动窗口、流量控制、拥塞控制" class="header-anchor">#</a> TCP 重传机制、滑动窗口、流量控制、拥塞控制</h2> <p>TCP 是通过 <strong>序列号、确认应答、重发控制、连接管理以及窗口控制</strong> 等机制实现可靠性传输的。</p> <h3 id="重传机制"><a href="#重传机制" class="header-anchor">#</a> 重传机制</h3> <p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p> <p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310090529996.png" alt="image-20230310090529996"></p> <p>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？</p> <p>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p> <p>接下来说说常见的重传机制：</p> <ul><li>超时重传</li> <li>快速重传</li> <li>SACK</li> <li>D-SACK</li></ul> <h4 id="超时重传"><a href="#超时重传" class="header-anchor">#</a> 超时重传</h4> <p>重传机制的其中一个方式，就是在发送数据时，设定一个<strong>定时器</strong>，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p> <p>TCP 会在以下两种情况发生超时重传：</p> <ul><li>数据包丢失</li> <li>确认应答丢失</li></ul> <p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5717/image-20221124160115964.png" alt="image-20221124160115964"></p> <p>特定的时间间隔：RTT（数据发送出去到收到确认的时间差）</p> <p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。</p> <p>假设在重传的情况下，超时时间 <code>RTO</code> 「较长或较短」时，会发生什么事情呢？</p> <p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5717/image-20221124160540791.png" alt="image-20221124160540791"></p> <p>上图中有两种超时时间不同的情况：</p> <ul><li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li> <li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul> <p>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p> <p>实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p> <p>估计往返时间，通常需要采样以下两个：</p> <ul><li>需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。</li> <li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。</li></ul> <h4 id="快速重传"><a href="#快速重传" class="header-anchor">#</a> 快速重传</h4> <h4 id="sack"><a href="#sack" class="header-anchor">#</a> SACK</h4> <h4 id="d-sack"><a href="#d-sack" class="header-anchor">#</a> D-SACK</h4> <h3 id="滑动窗口"><a href="#滑动窗口" class="header-anchor">#</a> 滑动窗口</h3> <h3 id="流量控制"><a href="#流量控制" class="header-anchor">#</a> 流量控制</h3> <p>如果发送者发送数据过快，接收者可能会来不及接收，那么就会出现分组丢失的情况。为了避免分组丢失，就需要控制发送者的发送速度，使得接收者能来得及接收并处理发送者发来的分组，这就是流量控制。</p> <p>流量控制的根本目的是防止分组丢失的情况发生，同时也保证了 TCP 的可靠性。</p> <h3 id="拥塞控制"><a href="#拥塞控制" class="header-anchor">#</a> 拥塞控制</h3> <h2 id="tcp-ip-和-tcp、ip-有什么关系"><a href="#tcp-ip-和-tcp、ip-有什么关系" class="header-anchor">#</a> TCP/IP 和 TCP、IP 有什么关系？</h2> <p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP、UDP、IP、HTTP、ICMP 等协议都是属于 TCP/IP 族内的协议。</p> <p>TCP/IP 网络模型是互联网的基础，是一系列网络协议的总称。这些协议可以划分为 4 层，分别是 应用层、传输层、网络层、网络接口层。</p> <ul><li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li> <li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li> <li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li> <li>网络接口层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li></ul> <h2 id="tcp-分段与-udp-ip-分片"><a href="#tcp-分段与-udp-ip-分片" class="header-anchor">#</a> TCP 分段与 UDP/IP 分片</h2> <p>分片方式主要有两种，分别是 MTU 以及 MSS：</p> <ul><li><strong>MTU</strong>：</li></ul> <p>MTU 是数据链路层的最大传输单元，是数据链路层中网络对数据帧的一个限制。一个 IP 报文在以太网中进行传输，如果长度大于 MTU，就要进行切片传输，使得每一片的长度都小于 MTU。</p> <p>注意：分片传输的 IP 报不一定会按序到达，但是 IP 首部的信息能让这些数据报片按需组装，<strong>IP报文 分片与组装的过程是在 网络层 中进行的</strong>。</p> <ul><li><strong>MSS</strong>：</li></ul> <p>MSS 是 TCP 中的一个概念，MSS 只出现在 SYN 报文段中，即是 TCP 前三次握手的两次。MSS 的值一般为 MTU 减去两个首部的大小（需要减去 IP 数据包包头的 20 Bytes 以及 TCP 数据段的包头 20 Bytes），因为 Internet 上的标准 MTU（最小的MTU，链路层网络为x2.5时）大小为 576 Bytes，那么此时 MSS 的默认大小就是 536 Bytes。MSS 的取值最好是取 512 的整数倍。<strong>TCP 报文的分段以及组装是在传输层上进行的</strong>。</p> <p><strong>那为什么 TCP 不需要进行 MTU 分段呢？</strong></p> <p>由上述知识点可知：MSS &lt;= MTU，所以分段后的每一段 TCP 报文段 + IP 首部后的长度是不可能超过 MTU 的，因此也无需在网络层上浪费时间来进行 IP 分片了。所以很少出现 TCP 报文段发生 IP 分片的情况。</p> <p>再来看 UDP 数据报，由于 UDP 不会自己进行分段，那么当数据报的长度超过 MTU 时，必须要在网络层进行 IP 分片，才能进行有效传输。</p> <p><strong>总结</strong>：UDP不会分段，就由IP来分。TCP会分段，当然就不用IP来分了。</p> <h2 id="tcp粘包和拆包的问题"><a href="#tcp粘包和拆包的问题" class="header-anchor">#</a> TCP粘包和拆包的问题</h2> <h3 id="什么是-tcp粘包和拆包-呢"><a href="#什么是-tcp粘包和拆包-呢" class="header-anchor">#</a> 什么是 TCP粘包和拆包 呢？</h3> <p>因为 TCP 是面向连接的、面向字节流的、提供可靠性服务的，所以在 TCP 收发两端都要有一一成对的 socket。因此，发送端为了将多个发给接收端的包更有效地发送给对方，使用了优化方法（Nagle 算法），将多次间隔较小且数据量较小地数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端很难分辨出完整的数据包，因为面向字节流的通信时无消息保护边界的，所以需要接收端去处理消息边界问题。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230418171159047.png" alt="image-20230418171159047"></p> <p>假设现在客户端分别发送了 D1、D2 两个数据包给服务端，由于服务端一次读取到的数据长度是不确定的，那么会出现以下四种情况：</p> <ul><li>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2，没有 粘包和拆包 现象；</li> <li>服务端一次收到了两个数据包，D1 和 D2 粘合在一起；（粘包）</li> <li>服务端分两次读取到了数据包，第一次读取到了完整的 D1 包 和 部分的 D2 包，那么第二次读取到了剩余的 D2 包；（出现 粘包 和 D2的拆包现象）</li> <li>服务端分两次读取到了数据包，第一次读取到了部分的 D1 包，那么第二次读取到了剩余的 D1 包 和 完整的 D2 包；（出现 粘包 和 D1的拆包现象）</li></ul> <h3 id="如何解决-tcp粘包和拆包-问题呢"><a href="#如何解决-tcp粘包和拆包-问题呢" class="header-anchor">#</a> 如何解决 TCP粘包和拆包 问题呢？</h3> <p>解决 粘包和拆包 的问题关键就是解决 <strong>接收端每次需要读去数据包长度的大小</strong> 的问题。</p> <ol><li><strong>发送端发送数据的时候可以在每个数据包前面添加包首部，首部中至少包含数据包的长度</strong>，这样接收端在接收数据的时候就可以通过读去首部中的数据包长度来计算出数据包的长度。</li> <li>发送端可以将每个数据包封装成固定的长度（不够的通过补充 0 填充），这样接收端就可以根据数据包长度来讲数据包区分开来。</li> <li>在数据包与数据包之间添加特殊的符号来判断边界。</li> <li>Netty 框架也提供了很多开箱即用的编解码器，极大简化网络编程解决此类问题的难度。</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/network/HTTP.html" class="prev">
        HTTP
      </a></span> <span class="next"><a href="/blog/network/what_happen_url.html">
        输入一个网址直到网页显示的期间，发生了什么？
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.c7952645.js" defer></script><script src="/assets/js/2.53ba99d7.js" defer></script><script src="/assets/js/60.497110a7.js" defer></script>
  </body>
</html>
