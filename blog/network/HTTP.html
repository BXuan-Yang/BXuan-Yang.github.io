<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP | BXuan随笔</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="欢迎来到 BXuan 的✨个人网站✨👏👏👏！">
    
    <link rel="preload" href="/assets/css/0.styles.72717b73.css" as="style"><link rel="preload" href="/assets/js/app.c7952645.js" as="script"><link rel="preload" href="/assets/js/2.53ba99d7.js" as="script"><link rel="preload" href="/assets/js/58.d1eb3d61.js" as="script"><link rel="prefetch" href="/assets/js/10.4ab63f7a.js"><link rel="prefetch" href="/assets/js/11.982bd386.js"><link rel="prefetch" href="/assets/js/12.0b6105e0.js"><link rel="prefetch" href="/assets/js/13.0b88c945.js"><link rel="prefetch" href="/assets/js/14.32b6e670.js"><link rel="prefetch" href="/assets/js/15.1651a6b7.js"><link rel="prefetch" href="/assets/js/16.55e08c05.js"><link rel="prefetch" href="/assets/js/17.6d98ee08.js"><link rel="prefetch" href="/assets/js/18.fc4ae118.js"><link rel="prefetch" href="/assets/js/19.ea630d0e.js"><link rel="prefetch" href="/assets/js/20.6151654c.js"><link rel="prefetch" href="/assets/js/21.1ddadd96.js"><link rel="prefetch" href="/assets/js/22.6e312c0e.js"><link rel="prefetch" href="/assets/js/23.ab691b41.js"><link rel="prefetch" href="/assets/js/24.6667f20a.js"><link rel="prefetch" href="/assets/js/25.517e4303.js"><link rel="prefetch" href="/assets/js/26.c92294b8.js"><link rel="prefetch" href="/assets/js/27.30245c81.js"><link rel="prefetch" href="/assets/js/28.83f84f64.js"><link rel="prefetch" href="/assets/js/29.2ebf177e.js"><link rel="prefetch" href="/assets/js/3.c16bd42d.js"><link rel="prefetch" href="/assets/js/30.15f1115b.js"><link rel="prefetch" href="/assets/js/31.271bb831.js"><link rel="prefetch" href="/assets/js/32.a3ffc84b.js"><link rel="prefetch" href="/assets/js/33.837c492d.js"><link rel="prefetch" href="/assets/js/34.6535b864.js"><link rel="prefetch" href="/assets/js/35.a9f35d11.js"><link rel="prefetch" href="/assets/js/36.58c71fa7.js"><link rel="prefetch" href="/assets/js/37.536c34aa.js"><link rel="prefetch" href="/assets/js/38.dca08340.js"><link rel="prefetch" href="/assets/js/39.20e843ec.js"><link rel="prefetch" href="/assets/js/4.d6c515d3.js"><link rel="prefetch" href="/assets/js/40.f33282da.js"><link rel="prefetch" href="/assets/js/41.0afdb83a.js"><link rel="prefetch" href="/assets/js/42.68f5e469.js"><link rel="prefetch" href="/assets/js/43.65a3e240.js"><link rel="prefetch" href="/assets/js/44.0429a345.js"><link rel="prefetch" href="/assets/js/45.61c6d807.js"><link rel="prefetch" href="/assets/js/46.69ea8e4b.js"><link rel="prefetch" href="/assets/js/47.21cbd519.js"><link rel="prefetch" href="/assets/js/48.b46e7243.js"><link rel="prefetch" href="/assets/js/49.8f93a744.js"><link rel="prefetch" href="/assets/js/5.65846da7.js"><link rel="prefetch" href="/assets/js/50.323a9f2b.js"><link rel="prefetch" href="/assets/js/51.731382e7.js"><link rel="prefetch" href="/assets/js/52.429c91e1.js"><link rel="prefetch" href="/assets/js/53.6ad30434.js"><link rel="prefetch" href="/assets/js/54.c2c209db.js"><link rel="prefetch" href="/assets/js/55.36509a79.js"><link rel="prefetch" href="/assets/js/56.442c1774.js"><link rel="prefetch" href="/assets/js/57.104714c1.js"><link rel="prefetch" href="/assets/js/59.7642ee42.js"><link rel="prefetch" href="/assets/js/6.1cca85df.js"><link rel="prefetch" href="/assets/js/60.497110a7.js"><link rel="prefetch" href="/assets/js/61.9456cece.js"><link rel="prefetch" href="/assets/js/62.4acf84cc.js"><link rel="prefetch" href="/assets/js/63.649869e0.js"><link rel="prefetch" href="/assets/js/64.a9a2a5e7.js"><link rel="prefetch" href="/assets/js/65.caf50992.js"><link rel="prefetch" href="/assets/js/66.a082df91.js"><link rel="prefetch" href="/assets/js/67.77906dd6.js"><link rel="prefetch" href="/assets/js/68.b187b7a3.js"><link rel="prefetch" href="/assets/js/69.d4e466ec.js"><link rel="prefetch" href="/assets/js/7.e19e61cb.js"><link rel="prefetch" href="/assets/js/70.d3e767af.js"><link rel="prefetch" href="/assets/js/71.b195f372.js"><link rel="prefetch" href="/assets/js/72.394bd04d.js"><link rel="prefetch" href="/assets/js/73.cca17919.js"><link rel="prefetch" href="/assets/js/74.91e1d2ef.js"><link rel="prefetch" href="/assets/js/75.6f26e213.js"><link rel="prefetch" href="/assets/js/76.9ae90df7.js"><link rel="prefetch" href="/assets/js/77.1220dc5d.js"><link rel="prefetch" href="/assets/js/78.d80a520f.js"><link rel="prefetch" href="/assets/js/79.d22d4bb9.js"><link rel="prefetch" href="/assets/js/8.c222cd7c.js"><link rel="prefetch" href="/assets/js/9.55b8fde2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.72717b73.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="BXuan随笔" class="logo"> <span class="site-name can-hide">BXuan随笔</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/network/" class="nav-link router-link-active">
  🍔计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog/os/" class="nav-link">
  🍟操作系统
</a></li><li class="dropdown-item"><!----> <a href="/blog/algo/" class="nav-link">
  🍕数据结构与算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link">
  🌭Java
</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">
  🍿Go
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件开发" class="dropdown-title"><span class="title">软件开发</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件开发" class="mobile-dropdown-title"><span class="title">软件开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          🌮数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/blog/redis/" class="nav-link">
  Redis
</a></li></ul></li><li class="dropdown-item"><h4>
          🥪开发框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/frame/spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-subitem"><a href="/blog/frame/springboot/" class="nav-link">
  SpringBoot
</a></li></ul></li><li class="dropdown-item"><h4>
          🥟架构设计
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/schemadesigner/" class="nav-link">
  设计模式
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件测试" class="dropdown-title"><span class="title">软件测试</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件测试" class="mobile-dropdown-title"><span class="title">软件测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/softwaretest/baseOfSoftwareTest/" class="nav-link">
  🥓软件测试基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章阅读" class="dropdown-title"><span class="title">文章阅读</span> <span class="arrow down"></span></button> <button type="button" aria-label="文章阅读" class="mobile-dropdown-title"><span class="title">文章阅读</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/interview/all.html" class="nav-link">
  💪面经汇总
</a></li><li class="dropdown-item"><!----> <a href="/blog/other/" class="nav-link">
  🧀其他阅读
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/BXuan-Yang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github🙋‍♂️
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/network/" class="nav-link router-link-active">
  🍔计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog/os/" class="nav-link">
  🍟操作系统
</a></li><li class="dropdown-item"><!----> <a href="/blog/algo/" class="nav-link">
  🍕数据结构与算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link">
  🌭Java
</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">
  🍿Go
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件开发" class="dropdown-title"><span class="title">软件开发</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件开发" class="mobile-dropdown-title"><span class="title">软件开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          🌮数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/blog/redis/" class="nav-link">
  Redis
</a></li></ul></li><li class="dropdown-item"><h4>
          🥪开发框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/frame/spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-subitem"><a href="/blog/frame/springboot/" class="nav-link">
  SpringBoot
</a></li></ul></li><li class="dropdown-item"><h4>
          🥟架构设计
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/schemadesigner/" class="nav-link">
  设计模式
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件测试" class="dropdown-title"><span class="title">软件测试</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件测试" class="mobile-dropdown-title"><span class="title">软件测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/softwaretest/baseOfSoftwareTest/" class="nav-link">
  🥓软件测试基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章阅读" class="dropdown-title"><span class="title">文章阅读</span> <span class="arrow down"></span></button> <button type="button" aria-label="文章阅读" class="mobile-dropdown-title"><span class="title">文章阅读</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/interview/all.html" class="nav-link">
  💪面经汇总
</a></li><li class="dropdown-item"><!----> <a href="/blog/other/" class="nav-link">
  🧀其他阅读
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/BXuan-Yang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github🙋‍♂️
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/network/HTTP.html" aria-current="page" class="active sidebar-link">HTTP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#什么是-http" class="sidebar-link">什么是 HTTP ？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http报头格式" class="sidebar-link">HTTP报头格式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#请求报文" class="sidebar-link">请求报文</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#响应报文" class="sidebar-link">响应报文</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-常见的状态码有哪些" class="sidebar-link">HTTP 常见的状态码有哪些？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-协议中-get-和-post-有什么区别-分别适用于什么场景" class="sidebar-link">HTTP 协议中 GET 和 POST 有什么区别？分别适用于什么场景？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-和-https" class="sidebar-link">HTTP 和 HTTPS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-和-https-有什么区别" class="sidebar-link">HTTP 和 HTTPS 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#https-解决了-http-的哪些问题" class="sidebar-link">HTTPS 解决了 HTTP 的哪些问题？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#https-是如何解决上述风险的" class="sidebar-link">HTTPS 是如何解决上述风险的？</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#https-用到哪些加密技术" class="sidebar-link">HTTPS 用到哪些加密技术？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-用到了哪些其他的协议" class="sidebar-link">http 用到了哪些其他的协议？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#讲一下dns过程。给一个网址-www-bytedance-com-dns服务器如何逐级解析的" class="sidebar-link">讲一下dns过程。给一个网址 www.bytedance.com，dns服务器如何逐级解析的？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#持续连接和非持续连接" class="sidebar-link">持续连接和非持续连接</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#采用非持续连接的-http" class="sidebar-link">采用非持续连接的 HTTP</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#用户点击超链接时会发生什么现象" class="sidebar-link">用户点击超链接时会发生什么现象？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#采用持续连接的http" class="sidebar-link">采用持续连接的HTTP</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-1-1、http-2、http-3-演变" class="sidebar-link">HTTP/1.1、HTTP/2、HTTP/3 演变</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-1-1-相比-http-1-0-提高了什么性能" class="sidebar-link">HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#什么是长连接和短连接" class="sidebar-link">什么是长连接和短连接？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#tcp-连接与断开连接" class="sidebar-link">TCP 连接与断开连接</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#长连接与短连接操作过程" class="sidebar-link">长连接与短连接操作过程</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#什么时候用长连接-短连接" class="sidebar-link">什么时候用长连接，短连接？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-协议与-tcp-ip-协议的关系" class="sidebar-link">HTTP 协议与 TCP/IP 协议的关系</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-2-做了什么优化" class="sidebar-link">HTTP/2 做了什么优化？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-2-有什么缺陷" class="sidebar-link">HTTP/2 有什么缺陷？</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-3-做了什么优化" class="sidebar-link">HTTP/3 做了什么优化？</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-2" class="sidebar-link">HTTP/2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#http-1-1的性能问题" class="sidebar-link">HTTP/1.1的性能问题</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#兼容http-1-1" class="sidebar-link">兼容HTTP/1.1</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#头部压缩" class="sidebar-link">头部压缩</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#hpack实现原理" class="sidebar-link">Hpack实现原理</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#二进制帧" class="sidebar-link">二进制帧</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#并发传输" class="sidebar-link">并发传输</a></li><li class="sidebar-sub-header"><a href="/blog/network/HTTP.html#服务器主动推送资源" class="sidebar-link">服务器主动推送资源</a></li></ul></li></ul></li><li><a href="/blog/network/TCP.html" class="sidebar-link">TCP</a></li><li><a href="/blog/network/what_happen_url.html" class="sidebar-link">输入一个网址直到网页显示的期间，发生了什么？</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h1> <h2 id="什么是-http"><a href="#什么是-http" class="header-anchor">#</a> 什么是 HTTP ？</h2> <p>HTTP，又称为 <strong>超文本传输协议</strong>，是应用层的核心协议。</p> <p>HTTP 由两个程序组成，一个服务端，一个客户端。</p> <p>Web 页面是由对象组成的，一个对象只是一个文件，如 HTML 文件、JPEG 文件、Java 程序或者是视频片段等等，它们可以组成一个 URL 来寻址。多数 Web 页面有一个 HTML 基本文件及几个引用对象，例如：一个 HTML 文件＋五个 JPEG 图形，那么这个 Web 页面里面就有六个对象。</p> <p>HTML 基本文件通过对象的 URL 地址引用页面中的其他对象。<strong>每个 URL 地址由两部分组成，一个是主机名、另一个是路径名</strong>。</p> <ul><li><p>www.baidu.com：就是主机名</p></li> <li><p>/s：就是路径名</p></li></ul> <p>服务端与客户端的工作原理：</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230310083635087.png" alt="image-20230310083635087"></p> <p><strong>HTTP 使用 TCP 作为支撑它的传输协议</strong>（而不是 UDP）</p> <p>HTTP 客户首先发起一个与服务器的 TCP 链接。一旦建立连接，该浏览器和服务器进程就可以通过套接字接口访问 TCP。(客户端的套接字接口是客户进程与 TCP 连接的大门。同样的，服务端的套接字接口是服务端进程与 TCP 连接的大门)</p> <ul><li><p>客户端向它的套接字接口发送 HTTP 请求报文并从它的套接字接口接收 HTTP 响应报文。</p></li> <li><p>服务端向它的套接字接口发送 HTTP 请求报文并从它的套接字接口接收 HTTP 响应报文。</p></li></ul> <p>TCP 为 HTTP 传输服务提供可靠传输数据服务。这意味着，一个客户进程发送的每一个 HTTP 请求最终都能完整的到达服务器。一样的道理，服务器进程发送的每一个 HTTP 请求也能完成的被客户端进程接收响应。HTTP 协议不用担心数据丢失的问题，也不用关心 TCP 协议是如何做到可靠数据传输的，这就是 <strong>分层体系</strong> 结构最大的特点。</p> <p>服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。HTTP 服务器并不保存关于客户的任何信息，所以我们说 HTTP <strong>是一个无状态协议</strong>。这里的无状态协议，举一个简单的例子：某个特定的用户在几秒前发送了一个请求，服务器已经给与响应了，但是几秒后又发送了一个相同的请求，这时服务器还是会像前一个的做法一样返回相同的响应请求，重新发送对象，就像不记得前几秒已经发送过了一样。</p> <h2 id="http报头格式"><a href="#http报头格式" class="header-anchor">#</a> HTTP报头格式</h2> <h3 id="请求报文"><a href="#请求报文" class="header-anchor">#</a> 请求报文</h3> <p>以下是 HTTP 请求报文 的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>GET http://jsuacm.cn/ HTTP/1.1
Host: jsuacm.cn
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3877.400 QQBrowser/10.8.4506.400
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9

//”请求数据”(GET方式的请求一般不包含)
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/28f0146f4568480abf9afe951dbfddc9.png" alt="在这里插入图片描述"></p> <p>HTTP 请求报文 组成：</p> <blockquote><p>请求行 + 请求头部 + 空行 + 请求数据</p></blockquote> <p>1、请求行</p> <p>请求行 由 <strong>请求方法字段 + URL字段 + HTTP协议版本字段</strong> 三部分组成，用空格隔开</p> <p>例如：GET http://jsuacm.cn/template/jsu/css/modifypage-1.css HTTP/1.1</p> <p><strong>（1）请求方法</strong></p> <p>HTTP 协议常见的请求方法有：POST、GET、HEAD、PUT、POTIONS、TRACE、CONNECT。</p> <ul><li><strong>GET</strong>：</li></ul> <p>GET 方法是常见的一种请求方法，当客户端需要从服务器中读取文档的时候、当点击网页上的连接来浏览网站的时候，使用的都是 GET 方法。GET 方法要求服务器将 URL 定位的资源放在响应报文的数据部分，发回给客户端。使用 GET 方法，请求参数和对应的值要附加在 URL 后面，利用一个 ？代表 URL 的结尾与请求参数的开始，传递参数长度受限制。</p> <p>GET 方式的请求一般不包含 ”请求数据“ 部分，请求数据以地址的形式表现在请求行。显然，这种方式不适合传送私密数据，并且由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。</p> <ul><li><strong>POST</strong>：</li></ul> <p>POST 方法也是常见的一种请求方法，POST 方法可以允许客户端给服务器提供信息较多。POST 方法将请求函数封装在 HTTP 请求数据中，以 名称：值 的形式出现，可以传输大量的数据，这样的话 POST 方法对于传递的数据的大小没有限制，而且也不会显示在 URL 中。</p> <ul><li>HEAD：</li></ul> <p>本质上和 GET 方法是一样的，但是服务端接收到 HEAD 请求后只返回一个响应头，不会发送响应内容。当我们只需要查看某个页面的状态，而不需要查看其具体内容的时候，使用 HEAD 方法是非常高效的。</p> <ul><li>PUT：</li></ul> <p>和 POST 方法类似，但是 html 表单不支持，发送资源与服务器，并存储在服务器指定位置，可用于替换资源，要求客户端事先知道该位置。</p> <ul><li>DELETE</li></ul> <p>请求服务器删除某资源。和put都具有破坏性，可能被防火墙拦截。如果是https协议，则无需担心。</p> <ul><li>OPTIONS：</li></ul> <p>获取 HTTP 服务器支持的 HTTP 请求方法，允许客户端查看服务器的性能，比如 ajax 跨域时的预检等。</p> <ul><li>TRACE：</li></ul> <p>回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。</p> <ul><li>CONNECT：</li></ul> <p>HTTP/1.1 协议中预留给能够将连接改为管道方式的 <strong>代理服务器</strong>。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的get、post了。</p> <p><strong>（2）URL 字段</strong></p> <p>URL：统一资源定位符，是一种资源位置的抽象唯一识别方法</p> <p>组成：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p> <p><strong>（3）HTTP 版本协议</strong></p> <p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1，现在最常用的是1.1</p> <p>2、请求头部</p> <p>请求头部为请求报文添加了一些附加信息，由 “名：值” 对组成，每行一对，名和值之间使用冒号分隔。请求头部通知服务器有关于客户端请求的信息。比较常见的有：</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/70810659bd9e4ffd831dc14464e997a9.png" alt="在这里插入图片描述"></p> <p>3、空行</p> <p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据。</p> <p>4、请求数据</p> <p>请求数据不在 GET 方法中使用，而在 POST 方法中使用。POST 方法适用于需要客户填写表单的场合。与请求数据相关的最长使用的请求头部是 Content-Type 和 Content-Length</p> <ul><li>Content-Type：数据类型</li></ul> <blockquote><p>Content-Type: text/html; charset=UTF-8</p></blockquote> <ul><li>Content-Length：数据长度</li></ul> <blockquote><p>Content-Length: 737265</p></blockquote> <h3 id="响应报文"><a href="#响应报文" class="header-anchor">#</a> 响应报文</h3> <p>HTTP 响应报文 例子：</p> <div class="language- extra-class"><pre class="language-text"><code>HTTP/1.1 200 OK
Server: nginx/1.18.0 (Ubuntu)
Date: Wed, 20 Oct 2021 06:46:15 GMT
Content-Type: text/html; charset=UTF-8
Connection: keep-alive
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate
Pragma: no-cache
Content-Length: 737265

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;&gt;
	&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
	&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
	&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;&gt;
	&lt;link rel=&quot;icon&quot; href=&quot;../../favicon.ico&quot;&gt;

	&lt;title&gt;
		吉首大学	&lt;/title&gt;

</code></pre></div><p>HTTP 响应报文组成：</p> <blockquote><p>状态行 + 响应头部 + 空行 + 响应数据</p></blockquote> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/63594585e1dc4ec486eae6260dd552f7.png" alt="在这里插入图片描述"></p> <p>1、状态行</p> <p>状态行由 3 部分组成，分别是 协议版本、状态码、状态码描述。</p> <p>（1）协议版本</p> <p>与上述请求报文中描述的协议版本一致。协议版本需要与其请求报文一致</p> <p><strong>（2）状态码</strong></p> <p>详细状态码可见左边导航栏阅读：</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/08f780f945204228b2d30d141de06e38.png" alt="在这里插入图片描述"></p> <p>（3）状态码描述</p> <p>状态码描述是对状态码的简单描述</p> <p>2、响应头部</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230418225926382.png" alt="image-20230418225926382"></p> <p>3、空行</p> <p>响应头部的最后会有一个空行，表示响应头部结束，接下来为响应数据。与请求报文一致。</p> <p>4、响应数据</p> <p>用于存放需要返回给客户端的数据信息。fiddler 抓出来的一段 HTTP 响应数据是一段 HTML。</p> <h2 id="http-常见的状态码有哪些"><a href="#http-常见的状态码有哪些" class="header-anchor">#</a> HTTP 常见的状态码有哪些？</h2> <p><strong>1xx</strong>：<strong>属于提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少</p> <p><strong>2xx</strong>：<strong>表示服务器成功处理了客户端的请求</strong></p> <ul><li>200 OK：最常见的成功状态码，表示处理请求正常。如果是 非HEAD 请求，服务器返回的响应头都会有 body 数据（HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。）</li> <li>204 No Content：表示成功的状态码，与 200 OK 基本相同，但是响应头中没有 body 数据</li> <li>206 Partial Content：表示成功的状态码，应用于 HTTP 分块下载 或者是 断点传输，表示返回的 body 数据并不是资源的全部，而是其中的一部分</li></ul> <p><strong>3xx</strong>：<strong>表示客户端请求的资源位置发生了变动</strong>，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向</p> <ul><li>301 Moved Permanently：表示永久重定向，说明请求的资源已经不存在了，需要用新的 url 来再次访问</li> <li>302 Found：表示临时重定向，说明请求的资源还在，但是暂时需要用新的 url 来访问</li> <li>304 Not Modified：不具有跳转的含义，表示资源未修改，重定向已存在的缓存文件，也称为 <strong>缓存重定向</strong>。就是告诉客户端可以继续使用缓存资源，用于缓存控制</li></ul> <p><strong>4xx</strong>：表示 <strong>客户端发送的报文有误</strong>，服务器无法处理，也就是错误码的意思。</p> <ul><li>400 Bad Request：表示客户端请求的报文有错误，但是是个笼统的错误</li> <li>403 Forbidden：表示服务器禁止访问资源，不是客户端的请求出错</li> <li>404 Not Found：表示请求的资源在服务器上找不到或者不存在，无法提供给客户端</li></ul> <p><strong>5xx</strong>：表示客户端请求报文正确，<strong>但是服务器处理时内部发生错误</strong>，属于服务器错误码</p> <ul><li>500 Internal Server Error：与 400 类似，是个笼统的错误码，服务器发生了错误，但是具体发生了什么错误，我们确实不知道的</li> <li>501 Not Implemented：表示客户端的请求的功能还不支持</li> <li>502 Bad Gateway：表示服务器作为网关或者代理时返回的错误码，但是服务器自身工作正常，访问后端服务器发生了错误</li> <li>503 Service Unavailable：表示服务器当前很忙，暂时没有办法响应客户端</li></ul> <h2 id="http-协议中-get-和-post-有什么区别-分别适用于什么场景"><a href="#http-协议中-get-和-post-有什么区别-分别适用于什么场景" class="header-anchor">#</a> HTTP 协议中 GET 和 POST 有什么区别？分别适用于什么场景？</h2> <p>HTTP 协议中 GET 和 POST 是两种常用的请求方法，它们的区别如下：</p> <ol><li><strong>参数传递方式不同</strong>：GET 请求参数是在 URL 中以键值对的形式传递的，例如：http://www.example.com/?key1=value1&amp;key2=value2。 而 POST 请求参数是在请求体中以键值对的形式传递的。</li> <li><strong>参数传递大小不同</strong>：GET 请求参数有大小限制，因为 URL 长度有限制，不同的浏览器和服务器对 URL 长度的限制不同，一般为 2048 个字符。而 POST 请求参数没有大小限制，因为它们是以请求体的形式传递的。</li> <li><strong>安全性不同</strong>：GET 请求的参数是明文传输的，因为参数在 URL 中，如果涉及敏感信息（如密码），容易被窃取或暴露在浏览器历史记录、代理服务器日志等地方。而 POST 请求的参数在请求体中传输，相对安全一些，但是也需要注意参数加密和防止 CSRF 攻击等问题。</li></ol> <p><strong>GET 和 POST 适用的场景不同</strong>：</p> <ol><li><strong>GET 请求适用于获取数据</strong>，如浏览网页、搜索等。因为 GET 请求参数以明文形式传输，容易被拦截和篡改，所以不适用于提交敏感信息的操作。</li> <li><strong>POST 请求适用于提交数据</strong>，如登录、注册、发布内容等。因为 POST 请求参数在请求体中传输，相对安全一些，可以提交敏感信息，但是需要注意参数加密和防止 CSRF 攻击等问题。</li></ol> <h2 id="http-和-https"><a href="#http-和-https" class="header-anchor">#</a> HTTP 和 HTTPS</h2> <h3 id="http-和-https-有什么区别"><a href="#http-和-https-有什么区别" class="header-anchor">#</a> HTTP 和 HTTPS 有什么区别？</h3> <ul><li>HTTP 是 <strong>超文本传输协议</strong>，信息是明文传输，存在安全风险的问题。HTTPS 则解决了 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输</li> <li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li> <li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li> <li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230418210643628.png" alt="image-20230418210643628"></p> <h3 id="https-解决了-http-的哪些问题"><a href="#https-解决了-http-的哪些问题" class="header-anchor">#</a> HTTPS 解决了 HTTP 的哪些问题？</h3> <p>由于 HTTP 是明文传输，所以安全上存在以下三个风险</p> <ol><li>窃听风险：可以在通信链路上获取通信内容</li> <li>篡改风险：可以强制植入广告</li> <li>冒充风险：冒充是淘宝网站</li></ol> <p>HTTPS 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p> <ol><li>信息加密</li> <li>校验机制</li> <li>身份证书</li></ol> <h3 id="https-是如何解决上述风险的"><a href="#https-是如何解决上述风险的" class="header-anchor">#</a> HTTPS 是如何解决上述风险的？</h3> <p>1、<strong>混合加密</strong> 的方式实现信息的 <strong>机密性</strong>，解决了窃听的风险。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230416195737264.png" alt="image-20230416195737264"></p> <p>HTTPS 采用的是 对称加密 和 非对称加密 结合的混合加密方式。</p> <p>在通信建立前采用 非对称加密 的方式交换 会话密钥，后续不再采用 非对称加密。在通信过程中采用的是 对称加密 的会话密钥的方式来加密明文数据。</p> <p>采用 混合加密 的方式的原因是：</p> <ol><li>对称加密只使用到一个密钥，运算速度快，密钥必须加密，无法做到安全的密钥交换</li> <li>非对称密钥使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但是速度较慢</li></ol> <p><strong>对称加密与非对称加密的区别</strong>：</p> <p><strong>对称加密算法</strong> 又称传统加密算法，加密密钥和解密密钥是相同的。对称加密算法要求通信双方在开始通信前，首先要商定这个用于加密和解密的密钥。对称加密算法的安全性就是依赖于这个密钥，如果这个密钥泄露了，就意味着通信不安全。</p> <p><strong>非对称加密算法</strong> 的加密密钥是公开的，理论上任何人都可以获得这个公开的加密密钥进行加密。但是，使用公开的密钥加密的信息只有响应的解密密钥才能解开，而这个解密密钥不是公开的。所以在非对称加密算法中，加密密钥也叫做公钥，解密密钥称为私钥。</p> <p>2、<strong>摘要算法</strong> 的方式来实现 <strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</p> <p>为了保证传输的内容不被篡改，我们需要对传输的内容计算出一个 指纹，然后同内容传输给对方。</p> <p>对方收到后，也是先对收到的内容根据计算出一个指纹，然后跟发送方发送过来的指纹做一个比较，如果指纹相同，那么说明内容没有被篡改，否则就是可以判断内容被篡改了。</p> <p>在计算机里会用 <strong>摘要函数</strong>（<strong>哈希函数</strong>）来计算出内容的哈希值，也就是传输的内容的指纹。这个哈希值是唯一的，而且无法通过哈希值推导出内容。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230416211106033.png" alt="image-20230416211106033"></p> <p>虽然通过哈希算法可以保证内容不会被篡改，但是不能保证 内容+哈希值 不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230416212306906.png" alt="image-20230416212306906"></p> <p>私钥是由服务端保存的，服务端会向客户端颁发对应的公钥。如果客户端收到的消息，能被公钥解密，那么说说明该消息是由服务器发送的。</p> <p>3、将服务器公钥放入到 <strong>数字证书</strong> 中，解决了冒充的风险。</p> <h2 id="https-用到哪些加密技术"><a href="#https-用到哪些加密技术" class="header-anchor">#</a> HTTPS 用到哪些加密技术？</h2> <h4 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="header-anchor">#</a> 对称加密与非对称加密</h4> <p>为了保证消息的保密性，就需要用到加密和解密。加解密算法目前主流的就是 对称加密 和 非对称加密。</p> <p><strong>对称加密</strong>（共享密钥加密）：</p> <p><strong>客户端和服务器公用一个密匙用来对消息加解密</strong>，这种方式称为对称加密。客户端和服务器约定好一个加密的密匙。客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230417124314761.png" alt="image-20230417124314761"></p> <p>优点：</p> <ul><li>对称加密解决了 http 中消息保密性的问题</li></ul> <p>缺点：</p> <ul><li>因为客户端与服务端共用一个密钥，所以导致密钥容易泄漏 ，这样子的话很难保证消息来源的可靠性、完整性和准确性</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230417124512226.png" alt="image-20230417124512226"></p> <p><strong>非对称加密</strong>（公有密钥加密）：</p> <p>采用非对称加密时，客户端和服务端均拥有一个公有密匙和一个私有密匙。公有密匙可以对外暴露，而私有密匙只有自己可见。</p> <p>使用公有密匙加密的消息，只有对应的私有密匙才能解开。反过来，使用私有密匙加密的消息，只有公有密匙才能解开。这样客户端在发送消息前，先用服务器的公匙对消息进行加密，服务器收到后再用自己的私匙进行解密。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230417124627061.png" alt="image-20230417124627061"></p> <p>优点：</p> <ul><li>非对称加密采用 <strong>公有密钥和私有密钥</strong> 的方式，解决了 http 中消息保密性的问题，并且能够使得私有密钥泄漏的风险大大降低</li> <li>因为公匙加密的消息只有对应的私匙才能解开，所以较大程度上保证了消息的来源性以及消息的准确性和完整性。</li></ul> <p>缺点：</p> <ul><li>非对称加密时需要使用到接收方的公匙对消息进行加密，但是公匙不是保密的，任何人都可以拿到，中间人也可以。那么中间人可以做两件事，第一件是中间人可以在客户端与服务器交换公匙的时候，将客户端的公匙替换成自己的。这样服务器拿到的公匙将不是客户端的，而是中间人的。服务器也无法判断公匙来源的正确性。第二件是中间人可以不替换公匙，但是他可以截获客户端发来的消息，然后篡改，然后用服务器的公匙加密再发往服务器，服务器将收到错误的消息。</li> <li>非对称加密的性能相对对称加密来说会慢上几倍甚至几百倍，比较消耗系统资源。正是因为如此，https将两种加密结合了起来。</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230417125059913.png" alt="image-20230417125059913"></p> <h4 id="数字证书与数字签名"><a href="#数字证书与数字签名" class="header-anchor">#</a> 数字证书与数字签名</h4> <p>1、<strong>数字证书的申请</strong></p> <p>为了解决非对称加密中公匙来源的不安全性，我们可以使用 <strong>数字证书和数字签名</strong> 来解决。</p> <p>服务器可以向 CA 申请数字证书，申请的大致流程是：</p> <ul><li>服务器自己本地先生成一对密匙，然后拿着自己的公匙以及其他信息（比如说企业名称啊什么的）去CA申请数字证书。</li> <li>CA在拿到这些信息后，会选择一种单向Hash算法（比如说常见的MD5）对这些信息进行加密，加密之后的东西我们称之为 <strong>摘要</strong>。</li> <li>单向Hash算法有一种特点就是单向不可逆的，只要原始内容有一点变化，加密后的数据都将会是千差万别（当然也有很小的可能性会重复，有兴趣的小伙伴鸽巢原理了解一下），这样就防止了信息被篡改。</li> <li>生成摘要后还不算完，CA还会用自己的私匙对摘要进行加密，摘要加密后的数据我们称之为 <strong>数字签名</strong>。</li> <li>最后，CA将会把我们的申请信息（包含服务器的公匙）和数字签名整合在一起，由此而生成数字证书。然后CA将数字证书传递给我们。</li></ul> <p>2、数字证书怎么起作用？</p> <p>服务器在获取到数字证书后，服务器会将数字证书发送给客户端，客户端就需要用CA的公匙解密数字证书并验证数字证书的合法性。那我们如何能拿到CA的公匙呢？我们的电脑和浏览器中已经内置了一部分权威机构的根证书，这些根证书中包含了CA的公匙。</p> <p>之所以是根证书，是因为现实生活中，认证中心是分层级的，也就是说有顶级认证中心，也有下面的各个子级的认证中心，是一个树状结构，计算机中内置的是最顶级机构的根证书，不过不用担心，根证书的公匙在子级也是适用的。</p> <p>客户端用CA的公匙解密数字证书，如果解密成功则说明证书来源于合法的认证机构。解密成功后，客户端就拿到了摘要。</p> <p>此时，客户端会按照和CA一样的Hash算法将申请信息生成一份摘要，并和解密出来的那份做对比，如果相同则说明内容完整，没有被篡改。最后，客户端安全的从证书中拿到服务器的公匙就可以和服务器进行安全的非对称加密通信了。服务器想获得客户端的公匙也可以通过相同方式。</p> <h4 id="https-原理"><a href="#https-原理" class="header-anchor">#</a> HTTPS 原理</h4> <p>HTTPS 没有采用单一的技术去实现，而是根据他们的特点，充分的将这些技术整合进去，以达到性能与安全最大化。这套整合的技术我们称之为SSL（Secure Scoket Layer 安全套接层）。所以https并非是一项新的协议，它只是在http上披了一层加密的外壳。</p> <p>HTTPS 先是利用数字证书保证服务器端的公匙可以安全无误的到达客户端。然后再用非对称加密安全的传递共享密匙，最后用共享密匙安全的交换数据。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230417130313826.png" alt="image-20230417130313826"></p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230417131524058.png" alt="image-20230417131524058"></p> <h2 id="http-用到了哪些其他的协议"><a href="#http-用到了哪些其他的协议" class="header-anchor">#</a> http 用到了哪些其他的协议？</h2> <h4 id="tcp-ip-协议"><a href="#tcp-ip-协议" class="header-anchor">#</a> TCP/IP 协议</h4> <p>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的就是 TCP 和 IP，其它的还有 UDP、ICMP、ARP等等，共同构成了一个复杂但有层次的协议栈。</p> <p>TCP 属于 “传输层”，IP 属于 “网际层”</p> <p>IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。</p> <p>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。</p> <p>HTTP 是一个&quot;传输协议&quot;，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“HTTP over TCP/IP”。</p> <h4 id="dns"><a href="#dns" class="header-anchor">#</a> DNS</h4> <p>“域名系统”，用有意义的名字来作为 IP 地址的等价代替。在 DNS 中，“域名” 又称为 “主机名”。域名用 “.” 分隔成多个单词，组别从左到右逐级升高，最右边的被称为 ”顶级域名“。</p> <p>但想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的**“域名解析”**。</p> <h4 id="uri-url"><a href="#uri-url" class="header-anchor">#</a> URI/URL</h4> <p>URI（Uniform Resource Identifier），中文名称是 统一资源标识符，使用它就能够唯一地标记互联网上资源。</p> <p>URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。</p> <div class="language- extra-class"><pre class="language-text"><code>http://nginx.org/en/download.html
</code></pre></div><p>URI 主要有三个基本的部分构成：</p> <ul><li>协议名：即访问该资源应当使用的协议，在这里是“http”；</li> <li>主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；</li> <li>路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。</li></ul> <h4 id="https"><a href="#https" class="header-anchor">#</a> HTTPS</h4> <p>&quot;HTTP over SSL/TLS&quot;，也就是运行在 SSL/TLS 协议上的 HTTP。
SSL/TLS，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。
HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”。</p> <h4 id="ssl"><a href="#ssl" class="header-anchor">#</a> SSL</h4> <p>SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。</p> <p>SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。</p> <h4 id="代理"><a href="#代理" class="header-anchor">#</a> 代理</h4> <p>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。</p> <p>代理有很多的种类，常见的有：</p> <ol><li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li> <li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</li> <li>正向代理：靠近客户端，代表客户端向服务器发送请求；</li> <li>反向代理：靠近服务器端，代表服务器响应客户端的请求；</li></ol> <p>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：</p> <ul><li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li> <li>内容缓存：暂存上下行的数据，减轻后端的压力；</li> <li>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li> <li>数据处理：提供压缩、加密等额外的功能。</li></ul> <p>关于 HTTP 的代理还有一个特殊的“代理协议”（proxy protocol），它由知名的代理软件 HAProxy 制订，但并不是 RFC 标准</p> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <ul><li>TCP/IP 是网络世界最常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；</li> <li>DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射；</li> <li>URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL；</li> <li>HTTPS 相于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳；代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。</li></ul> <h2 id="讲一下dns过程。给一个网址-www-bytedance-com-dns服务器如何逐级解析的"><a href="#讲一下dns过程。给一个网址-www-bytedance-com-dns服务器如何逐级解析的" class="header-anchor">#</a> 讲一下dns过程。给一个网址 www.bytedance.com，dns服务器如何逐级解析的？</h2> <p>DNS 解析过程：</p> <p>第一步：客户机提出域名解析请求,并将该请求发送给本地的<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/9705133?fromModule=lemma_inlink" target="_blank" rel="noopener noreferrer">域名服务器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>第二步：当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回.</p> <p>第三步：如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给<a href="https://baike.baidu.com/item/%E6%A0%B9%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/5907519?fromModule=lemma_inlink" target="_blank" rel="noopener noreferrer">根域名服务器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址.</p> <p>第四步：本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址.</p> <p>第五步：重复第四步,直到找到正确的纪录.</p> <p>第六步：本地域名服务器把返回的结果保存到缓存,以备下一次使用,同时还将结果返回给客户机</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/e7a34161bde84e858757ff1c26bc9674.png" alt="img"></p> <h2 id="持续连接和非持续连接"><a href="#持续连接和非持续连接" class="header-anchor">#</a> 持续连接和非持续连接</h2> <p><strong>非持续连接</strong>：每个请求/响应式经过一个单独的TCP连接发送的</p> <p><strong>持续连接</strong>：所有的请求/响应是经由一个相同的TCP连接发送的（HTTP默认的情况下使用的是持续连接）</p> <h3 id="采用非持续连接的-http"><a href="#采用非持续连接的-http" class="header-anchor">#</a> 采用非持续连接的 HTTP</h3> <p>假设我们现在在<strong>非持续连接的 HTTP 的情况</strong>下，服务器向客户传送一个Web页面的步骤，假设该页面含有一个基本的HTML文件＋十张JPEG图片，此时这个Web页面里面就有11个对象，并且这11个对象位于同一台服务器上，进一步假设当前HTML文件的URL为：http://www.homeSchool.com/user/home.index。此时会发生下面的情况：</p> <ol><li>HTTP客户进程在端口 80 发送一个到服务器 www.homeSchool.com 的 TCP 连接，该端口号是 HTTP 默认的端口号，在客户和服务器上分别由一个套接字与该连接相连</li> <li>HTTP 客户端经它的套接字向该服务器发送一个 HTTP 请求报文，请求报文中包含 URL 的路径 (/user/home.index)</li> <li>HTTP服务器经它的套接字接收到该HTTP请求报文，从存储器中（RAM/磁盘）中检索出对象http://www.homeSchool.com/user/home.index，然后在一个HTTP影响报文里面封装该对象，并通过套接字向客户发送响应报文</li> <li>HTTP服务器进程通知TCP断开连接（但是TCP会等到客户已经确认完之后才去断开）</li> <li>HTTP客户接收响应报文，TCP连接关闭，该报文封装的是一个HTML文件，客户从响应报文中提取出该文件，检查HTML文件，得到10个JEPG图形的引用。</li> <li>对每一个JEPG引用都重复使用前四个步骤</li></ol> <p>**在非持续连接的HTTP情况下，每个HTTP连接在服务器发送玩一个对象后就会进行关闭，即该对象并不会为了其他的对象而存活下来。**每个TCP连接至传输一个请求报文和一个响应报文，例如上面的例子，就要产生11个TCP连接。</p> <p>在上面的描述步骤中，没有明确的说出获取后面的10个JPEG图形对象是使用10个串行连接还是并行连接，事实上，这个可以通过用户自己来控制，在默认的方式下，大部分浏览器可以打开5~10个的TCP连接。使用并行连接的话可以缩短响应的时间。</p> <p>RTT（往返时间）：从客户请求HTML基本文件到该客户收到整个文件所花费的时间。RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p> <h3 id="用户点击超链接时会发生什么现象"><a href="#用户点击超链接时会发生什么现象" class="header-anchor">#</a> 用户点击超链接时会发生什么现象？</h3> <p>设计一次“三次握手”的过程，即在客户向服务器发送一个小TCP报文段，服务器用一个小TCP报文段做出确认和响应，最后，客户向服务器返回确认。</p> <p>总时间：2*RTT + 最终传输HTML文件所需的时间（图中画的不是很明显）</p> <h3 id="采用持续连接的http"><a href="#采用持续连接的http" class="header-anchor">#</a> 采用持续连接的HTTP</h3> <p>首先我们先来谈一下非持续连接的缺点</p> <ul><li>必须为每一个请求的对象建立和维护一个全新的连接</li></ul> <p>对于每一个这样的TCP连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，这会给Web服务器带来严重的负担，因为一台Web服务器中可能要同时服务很多的客户的请求</p> <ul><li>时间过长</li></ul> <p>像我们之前分析的来说，每一个对象都需要经受两个RTT，即一个RTT用于创建TCP，另一个RTT用于请求和接收对象</p> <p>一般来说，如果一条连接经过一定时间间隔（是可配置的时间间隔）仍未被时延，那么HTTP服务器就关闭该连接，HTTP默认是使用带流水线的持续连接。</p> <p>自HTTP1.1采用持续连接的情况下，服务器能在发送响应后保持TCP连接打开。相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。特别是一个完整的Web页面（如上个例子中的HTML文件和十个JEPG文件），可以持续使用单个TCP连接进行传送。更有甚者，唯一同一台服务器上的多个Web文件从该服务器发给客户时，都可以在单个TCP连接上进行。</p> <h2 id="http-1-1、http-2、http-3-演变"><a href="#http-1-1、http-2、http-3-演变" class="header-anchor">#</a> HTTP/1.1、HTTP/2、HTTP/3 演变</h2> <h3 id="http-1-1-相比-http-1-0-提高了什么性能"><a href="#http-1-1-相比-http-1-0-提高了什么性能" class="header-anchor">#</a> HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</h3> <p><strong>HTTP/1.1 相比 HTTP/1.0 性能上的改进：</strong></p> <ul><li>使用长连接（Connection:keep-alive）的方式改善了 HTTP/1.0 短连接造成的性能开销。</li> <li>支持 <strong>管道（pipeline）网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul> <p>但 HTTP/1.1 还是有性能瓶颈：</p> <ul><li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li> <li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li> <li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li> <li>没有请求优先级控制；</li> <li>请求只能从客户端开始，服务器只能被动响应。</li></ul> <h3 id="什么是长连接和短连接"><a href="#什么是长连接和短连接" class="header-anchor">#</a> 什么是长连接和短连接？</h3> <p>**在 HTTP/1.0 中默认使用短连接。**短连接也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的 Web 资源（如JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</p> <p><strong>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性</strong>。使用长连接的 HTTP 协议，会在响应头加入这行代码：</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token property">Connection</span><span class="token punctuation">:</span>keep-alive
</code></pre></div><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p> <p>Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p> <p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p> <h3 id="tcp-连接与断开连接"><a href="#tcp-连接与断开连接" class="header-anchor">#</a> TCP 连接与断开连接</h3> <p>当网络通信时采用 TCP 协议时，在真正的读写操作之前，客户端与服务器端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时可以释放这个连接。</p> <p>连接的建立依靠“<strong>三次握手</strong>”，而释放则需要“<strong>四次握手</strong>”，所以每个连接的建立都是需要资源消耗和时间消耗的。</p> <p>经典的三次握手及四次挥手示意图：</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230306004438441.png" alt="image-20230306004438441"></p> <h3 id="长连接与短连接操作过程"><a href="#长连接与短连接操作过程" class="header-anchor">#</a> 长连接与短连接操作过程</h3> <blockquote><p>短连接的操作步骤是：
建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接</p> <p>长连接的操作步骤是：
建立连接——数据传输...（保持连接）...数据传输——关闭连接</p></blockquote> <h3 id="什么时候用长连接-短连接"><a href="#什么时候用长连接-短连接" class="header-anchor">#</a> 什么时候用长连接，短连接？</h3> <p><strong>长连接</strong>多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个 TCP 连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就 OK 了，不用建立 TCP 连接。</p> <p>例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成 socket 错误，而且频繁的 socket 创建也是对资源的浪费。</p> <p>而像 WEB 网站的 http 服务一般都用<strong>短链接</strong>，因为长连接对于服务端来说会耗费一定的资源，而像 WEB 网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连接好。</p> <h3 id="http-协议与-tcp-ip-协议的关系"><a href="#http-协议与-tcp-ip-协议的关系" class="header-anchor">#</a> <strong>HTTP 协议与 TCP/IP 协议的关系</strong></h3> <p>HTTP 的长连接和短连接本质上是 TCP 长连接和短连接。</p> <p><strong>HTTP 属于应用层协议，在传输层使用 TCP 协议，在网络层使用IP协议。</strong></p> <p>IP 协议主要解决网络路由和寻址问题，TCP 协议主要解决如何在 IP 层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP 协议是可靠的、面向连接的。</p> <h3 id="http-2-做了什么优化"><a href="#http-2-做了什么优化" class="header-anchor">#</a> HTTP/2 做了什么优化？</h3> <p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230306004742770.png" alt="image-20230306004742770"></p> <p>HTTP/2 相比 HTTP/1.1 性能上的改进：</p> <ul><li>头部压缩</li> <li>二进制格式</li> <li>并发传输</li> <li>服务器主动推送资源</li></ul> <ol><li>头部压缩</li></ol> <p>HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p> <p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p> <ol start="2"><li>二进制格式</li></ol> <p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p> <ol start="3"><li>并发传输</li></ol> <p>我们都知道 <strong>HTTP/1.1 的实现是基于请求-响应模型</strong>的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p> <ol start="4"><li>服务器推送</li></ol> <p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</p> <p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p> <h3 id="http-2-有什么缺陷"><a href="#http-2-有什么缺陷" class="header-anchor">#</a> HTTP/2 有什么缺陷？</h3> <p>HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p> <p><strong>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</strong></p> <h3 id="http-3-做了什么优化"><a href="#http-3-做了什么优化" class="header-anchor">#</a> HTTP/3 做了什么优化？</h3> <p>我们知道了 HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：</p> <ul><li>HTTP/1.1 中的<strong>管道（ pipeline）<strong>虽然解决了请求的队头阻塞，但是</strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li> <li>HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li></ul> <p>HTTP/2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p> <p>**UDP 发送是不管顺序，也不管丢包的。**所以不会出现像 HTTP/2 队头阻塞的问题。</p> <p>大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p> <p>QUIC 有以下 3 个特点。</p> <ul><li>无队头阻塞</li> <li>更快的连接建立</li> <li>连接迁移</li></ul> <p><em>1、无队头阻塞</em></p> <p>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p> <p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p> <p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p> <p><em>2、更快的连接建立</em></p> <p>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p> <p>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p> <p>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：</p> <p>甚至，在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p> <p>如下图右边部分，HTTP/3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT（下图的右下角）：</p> <p><em>3、连接迁移</em></p> <p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p> <p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p> <p>而 QUIC 协议没有用四元组的方式来 “绑定” 连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p> <p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP/2 的多路复用的协议。</p> <p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p> <h2 id="http-2"><a href="#http-2" class="header-anchor">#</a> HTTP/2</h2> <p>HTTP/2 升级后的四大特性</p> <ul><li>头部压缩</li> <li>二进制帧</li> <li>并发传输</li> <li>服务器主动推送资源</li></ul> <h3 id="http-1-1的性能问题"><a href="#http-1-1的性能问题" class="header-anchor">#</a> HTTP/1.1的性能问题</h3> <p>HTTP/1.1有高延迟的问题</p> <p>现在的站点相比以前变化太多了，比如：</p> <ul><li><em>消息的大小变大了</em>，从几 KB 大小的消息，到几 MB 大小的消息；</li> <li><em>页面资源变多了</em>，从每个页面不到 10 个的资源，到每页超 100 多个资源；</li> <li><em>内容形式变多样了</em>，从单纯到文本内容，到图片、视频、音频等内容；</li> <li><em>实时性要求变高了</em>，对页面的实时性要求的应用越来越多；</li></ul> <p>主要原因如下几个：</p> <ul><li><em>延迟难以下降</em>，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；</li> <li><em>并发连接有限</em>，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；</li> <li><em>队头阻塞问题</em>，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；</li> <li><em>HTTP 头部巨大且重复</em>，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 cookie 的头部，而 cookie 的大小通常很大；</li> <li><em>不支持服务器推送消息</em>，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。</li></ul> <h3 id="兼容http-1-1"><a href="#兼容http-1-1" class="header-anchor">#</a> 兼容HTTP/1.1</h3> <p>第一点，HTTP/2 没有在 URI 里引入新的协议名，仍然用「http://」表示明文协议，用「https://」表示加密协议，于是只需要浏览器和服务器在背后自动升级协议，这样可以让用户意识不到协议的升级，很好的实现了协议的平滑升级。</p> <p>第二点，只在应用层做了改变，还是基于 TCP 协议传输，应用层方面为了保持功能上的兼容，HTTP/2 把 HTTP 分解成了「语义」和「语法」两个部分，「语义」层不做改动，与 HTTP/1.1 完全一致，比如请求方法、状态码、头字段等规则保留不变。</p> <p>但是，HTTP/2 在「语法」层面做了很多改造，基本改变了 HTTP 报文的传输格式。</p> <h3 id="头部压缩"><a href="#头部压缩" class="header-anchor">#</a> 头部压缩</h3> <p>HTTP 协议的报文是由「Header + Body」构成的。</p> <p>对于 Body 部分，HTTP/1.1 协议可以使用头字段 「Content-Encoding」指定 Body 的压缩方式，比如用 gzip 压缩，这样可以节约带宽。</p> <p>但报文中的另外一部分 Header，是没有针对它的优化手段。</p> <p>HTTP/1.1 报文中 Header 部分存在的问题：</p> <ul><li>含很多固定的字段，比如Cookie、User Agent、Accept 等，这些字段加起来也高达几百字节甚至上千字节，所以有必要<strong>压缩</strong>；</li> <li>大量的请求和响应的报文里有很多字段值都是重复的，这样会使得大量带宽被这些冗余的数据占用了，所以有必须要<strong>避免重复性</strong>；</li> <li>字段是 ASCII 编码的，虽然易于人类观察，但效率低，所以有必要改成<strong>二进制编码</strong>；</li></ul> <p>HTTP/2 对 Header 部分做了大改造，把以上的问题都解决了。</p> <p>HTTP/2 没使用常见的 gzip 压缩方式来压缩头部，而是开发了 <strong>HPACK</strong> 算法，HPACK 算法主要包含三个组成部分：</p> <ul><li>静态字典；</li> <li>动态字典；</li> <li>Huffman 编码（压缩算法）；</li></ul> <h3 id="hpack实现原理"><a href="#hpack实现原理" class="header-anchor">#</a> Hpack实现原理</h3> <p>客户端和服务器两端都会建立和维护「<strong>字典</strong>」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，<strong>可达到 50%~90% 的高压缩率</strong>。</p> <h4 id="静态表编码"><a href="#静态表编码" class="header-anchor">#</a> 静态表编码</h4> <p>HTTP/2 为高频出现在头部的字符串和字段建立了一张<strong>静态表</strong>，它是写入到 HTTP/2 框架里的，不会变化的</p> <div class="language- extra-class"><pre><code>  +-------+-----------------------------+---------------+
  | Index | Header Name                 | Header Value  |
  +-------+-----------------------------+---------------+
  | 1     | :authority                  |               |
  | 2     | :method                     | GET           |
  | 3     | :method                     | POST          |
  | 4     | :path                       | /             |
  | 5     | :path                       | /index.html   |
  | 6     | :scheme                     | http          |
  | 7     | :scheme                     | https         |
  | 8     | :status                     | 200           |
  | 9     | :status                     | 204           |
  | 10    | :status                     | 206           |
  | 11    | :status                     | 304           |
  | 12    | :status                     | 400           |
  | 13    | :status                     | 404           |
  | 14    | :status                     | 500           |
  | 15    | accept-charset              |               |
  | 16    | accept-encoding             | gzip, deflate |
  | 17    | accept-language             |               |
  | 18    | accept-ranges               |               |
  | 19    | accept                      |               |
  | 20    | access-control-allow-origin |               |
  | 21    | age                         |               |
  | 22    | allow                       |               |
  | 23    | authorization               |               |
  | 24    | cache-control               |               |
  | 25    | content-disposition         |               |
  | 26    | content-encoding            |               |
  | 27    | content-language            |               |
  | 28    | content-length              |               |
  | 29    | content-location            |               |
  | 30    | content-range               |               |
  | 31    | content-type                |               |
  | 32    | cookie                      |               |
  | 33    | date                        |               |
  | 34    | etag                        |               |
  | 35    | expect                      |               |
  | 36    | expires                     |               |
  | 37    | from                        |               |
  | 38    | host                        |               |
  | 39    | if-match                    |               |
  | 40    | if-modified-since           |               |
  | 41    | if-none-match               |               |
  | 42    | if-range                    |               |
  | 43    | if-unmodified-since         |               |
  | 44    | last-modified               |               |
  | 45    | link                        |               |
  | 46    | location                    |               |
  | 47    | max-forwards                |               |
  | 48    | proxy-authenticate          |               |
  | 49    | proxy-authorization         |               |
  | 50    | range                       |               |
  | 51    | referer                     |               |
  | 52    | refresh                     |               |
  | 53    | retry-after                 |               |
  | 54    | server                      |               |
  | 55    | set-cookie                  |               |
  | 56    | strict-transport-security   |               |
  | 57    | transfer-encoding           |               |
  | 58    | user-agent                  |               |
  | 59    | vary                        |               |
  | 60    | via                         |               |
  | 61    | www-authenticate            |               |
  +-------+-----------------------------+---------------+
</code></pre></div><h4 id="动态表编码"><a href="#动态表编码" class="header-anchor">#</a> 动态表编码</h4> <p>静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建<strong>动态表</strong>，它的 Index 从 <code>62</code> 起步，会在编码解码的时候随时更新。</p> <p>比如，第一次发送时头部中的「<code>user-agent</code> 」字段数据有上百个字节，经过 Huffman 编码发送出去后，客户端和服务器双方都会更新自己的动态表，添加一个新的 Index 号 62。<strong>那么在下一次发送的时候，就不用重复发这个字段的数据了，只用发 1 个字节的 Index 号就好了，因为双方都可以根据自己的动态表获取到字段的数据</strong>。</p> <p>所以，使得动态表生效有一个前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部</strong>。如果消息字段在 1 个连接上只发送了 1 次，或者重复传输时，字段总是略有变化，动态表就无法被充分利用了。</p> <p>因此，随着在同一 HTTP/2 连接上发送的报文越来越多，客户端和服务器双方的「字典」积累的越来越多，理论上最终每个头部字段都会变成 1 个字节的 Index，这样便避免了大量的冗余数据的传输，大大节约了带宽。</p> <p>理想很美好，现实很骨感。动态表越大，占用的内存也就越大，如果占用了太多内存，是会影响服务器性能的，因此 Web 服务器都会提供类似 <code>http2_max_requests</code> 的配置，用于限制一个连接上能够传输的请求数量，避免动态表无限增大，请求数量到达上限后，就会关闭 HTTP/2 连接来释放内存。</p> <p><em><em>动态表的大小 = （每个 Header 的字节数的和 + 32）</em> 键值对个数</em>*</p> <p>综上，HTTP/2 头部的编码通过「静态表、动态表、Huffman 编码」共同完成的。</p> <h4 id="表的索引概念"><a href="#表的索引概念" class="header-anchor">#</a> 表的索引概念</h4> <p>hpack编码后的数据成分可以拆分成一下几个部分：</p> <ol><li>操作码</li> <li>在表中的索引（这个索引可能是hearder中key值的索引，也可能是整个键值对的索引）</li> <li>是否使用哈夫曼编码</li> <li>key的长度</li> <li>key的编码</li> <li>value的长度</li> <li>value的编码</li></ol> <p>上述的七个部分中不是每一个部分都能用得到，比如表中的索引若是已经存在的话，那么key的长度以及编码部分的内容就不需要编码传输了，可以直接在索引表中取得。</p> <h3 id="二进制帧"><a href="#二进制帧" class="header-anchor">#</a> 二进制帧</h3> <p>HTTP/2 厉害的地方在于将 HTTP/1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析。</p> <p>HTTP/2 把响应报文划分成了两类<strong>帧（*Frame*）</strong>，图中的 HEADERS（首部）和 DATA（消息负载） 是帧的类型，也就是说一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码。</p> <p>比如状态码 200</p> <p>在 HTTP/1.1 是用 '2''0''0' 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节。</p> <p>在 HTTP/2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节就能表示，相比于 HTTP/1.1 节省了 2 个字节</p> <h3 id="并发传输"><a href="#并发传输" class="header-anchor">#</a> 并发传输</h3> <p>知道了 HTTP/2 的帧结构后，我们再来看看它是如何实现<strong>并发传输</strong>的。</p> <p>我们都知道 HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p> <p>而 HTTP/2 就很牛逼了，通过 Stream 这个设计，<strong>多个 Stream 复用一条 TCP 连接，达到并发的效果</strong>，解决了 HTTP/1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量。</p> <h3 id="服务器主动推送资源"><a href="#服务器主动推送资源" class="header-anchor">#</a> 服务器主动推送资源</h3> <p>客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 <code>PUSH_PROMISE</code> 帧传输 HTTP 头部，并通过帧中的 <code>Promised Stream ID</code> 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/network/TCP.html">
        TCP
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.c7952645.js" defer></script><script src="/assets/js/2.53ba99d7.js" defer></script><script src="/assets/js/58.d1eb3d61.js" defer></script>
  </body>
</html>
