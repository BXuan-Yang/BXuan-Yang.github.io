<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java 集合 | BXuan随笔</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="欢迎来到 BXuan 的✨个人网站✨👏👏👏！">
    
    <link rel="preload" href="/assets/css/0.styles.72717b73.css" as="style"><link rel="preload" href="/assets/js/app.c7952645.js" as="script"><link rel="preload" href="/assets/js/2.53ba99d7.js" as="script"><link rel="preload" href="/assets/js/50.323a9f2b.js" as="script"><link rel="prefetch" href="/assets/js/10.4ab63f7a.js"><link rel="prefetch" href="/assets/js/11.982bd386.js"><link rel="prefetch" href="/assets/js/12.0b6105e0.js"><link rel="prefetch" href="/assets/js/13.0b88c945.js"><link rel="prefetch" href="/assets/js/14.32b6e670.js"><link rel="prefetch" href="/assets/js/15.1651a6b7.js"><link rel="prefetch" href="/assets/js/16.55e08c05.js"><link rel="prefetch" href="/assets/js/17.6d98ee08.js"><link rel="prefetch" href="/assets/js/18.fc4ae118.js"><link rel="prefetch" href="/assets/js/19.ea630d0e.js"><link rel="prefetch" href="/assets/js/20.6151654c.js"><link rel="prefetch" href="/assets/js/21.1ddadd96.js"><link rel="prefetch" href="/assets/js/22.6e312c0e.js"><link rel="prefetch" href="/assets/js/23.ab691b41.js"><link rel="prefetch" href="/assets/js/24.6667f20a.js"><link rel="prefetch" href="/assets/js/25.517e4303.js"><link rel="prefetch" href="/assets/js/26.c92294b8.js"><link rel="prefetch" href="/assets/js/27.30245c81.js"><link rel="prefetch" href="/assets/js/28.83f84f64.js"><link rel="prefetch" href="/assets/js/29.2ebf177e.js"><link rel="prefetch" href="/assets/js/3.c16bd42d.js"><link rel="prefetch" href="/assets/js/30.15f1115b.js"><link rel="prefetch" href="/assets/js/31.271bb831.js"><link rel="prefetch" href="/assets/js/32.a3ffc84b.js"><link rel="prefetch" href="/assets/js/33.837c492d.js"><link rel="prefetch" href="/assets/js/34.6535b864.js"><link rel="prefetch" href="/assets/js/35.a9f35d11.js"><link rel="prefetch" href="/assets/js/36.58c71fa7.js"><link rel="prefetch" href="/assets/js/37.536c34aa.js"><link rel="prefetch" href="/assets/js/38.dca08340.js"><link rel="prefetch" href="/assets/js/39.20e843ec.js"><link rel="prefetch" href="/assets/js/4.d6c515d3.js"><link rel="prefetch" href="/assets/js/40.f33282da.js"><link rel="prefetch" href="/assets/js/41.0afdb83a.js"><link rel="prefetch" href="/assets/js/42.68f5e469.js"><link rel="prefetch" href="/assets/js/43.65a3e240.js"><link rel="prefetch" href="/assets/js/44.0429a345.js"><link rel="prefetch" href="/assets/js/45.61c6d807.js"><link rel="prefetch" href="/assets/js/46.69ea8e4b.js"><link rel="prefetch" href="/assets/js/47.21cbd519.js"><link rel="prefetch" href="/assets/js/48.b46e7243.js"><link rel="prefetch" href="/assets/js/49.8f93a744.js"><link rel="prefetch" href="/assets/js/5.65846da7.js"><link rel="prefetch" href="/assets/js/51.731382e7.js"><link rel="prefetch" href="/assets/js/52.429c91e1.js"><link rel="prefetch" href="/assets/js/53.6ad30434.js"><link rel="prefetch" href="/assets/js/54.c2c209db.js"><link rel="prefetch" href="/assets/js/55.36509a79.js"><link rel="prefetch" href="/assets/js/56.442c1774.js"><link rel="prefetch" href="/assets/js/57.104714c1.js"><link rel="prefetch" href="/assets/js/58.d1eb3d61.js"><link rel="prefetch" href="/assets/js/59.7642ee42.js"><link rel="prefetch" href="/assets/js/6.1cca85df.js"><link rel="prefetch" href="/assets/js/60.497110a7.js"><link rel="prefetch" href="/assets/js/61.9456cece.js"><link rel="prefetch" href="/assets/js/62.4acf84cc.js"><link rel="prefetch" href="/assets/js/63.649869e0.js"><link rel="prefetch" href="/assets/js/64.a9a2a5e7.js"><link rel="prefetch" href="/assets/js/65.caf50992.js"><link rel="prefetch" href="/assets/js/66.a082df91.js"><link rel="prefetch" href="/assets/js/67.77906dd6.js"><link rel="prefetch" href="/assets/js/68.b187b7a3.js"><link rel="prefetch" href="/assets/js/69.d4e466ec.js"><link rel="prefetch" href="/assets/js/7.e19e61cb.js"><link rel="prefetch" href="/assets/js/70.d3e767af.js"><link rel="prefetch" href="/assets/js/71.b195f372.js"><link rel="prefetch" href="/assets/js/72.394bd04d.js"><link rel="prefetch" href="/assets/js/73.cca17919.js"><link rel="prefetch" href="/assets/js/74.91e1d2ef.js"><link rel="prefetch" href="/assets/js/75.6f26e213.js"><link rel="prefetch" href="/assets/js/76.9ae90df7.js"><link rel="prefetch" href="/assets/js/77.1220dc5d.js"><link rel="prefetch" href="/assets/js/78.d80a520f.js"><link rel="prefetch" href="/assets/js/79.d22d4bb9.js"><link rel="prefetch" href="/assets/js/8.c222cd7c.js"><link rel="prefetch" href="/assets/js/9.55b8fde2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.72717b73.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="BXuan随笔" class="logo"> <span class="site-name can-hide">BXuan随笔</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/network/" class="nav-link">
  🍔计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog/os/" class="nav-link">
  🍟操作系统
</a></li><li class="dropdown-item"><!----> <a href="/blog/algo/" class="nav-link">
  🍕数据结构与算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link router-link-active">
  🌭Java
</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">
  🍿Go
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件开发" class="dropdown-title"><span class="title">软件开发</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件开发" class="mobile-dropdown-title"><span class="title">软件开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          🌮数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/blog/redis/" class="nav-link">
  Redis
</a></li></ul></li><li class="dropdown-item"><h4>
          🥪开发框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/frame/spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-subitem"><a href="/blog/frame/springboot/" class="nav-link">
  SpringBoot
</a></li></ul></li><li class="dropdown-item"><h4>
          🥟架构设计
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/schemadesigner/" class="nav-link">
  设计模式
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件测试" class="dropdown-title"><span class="title">软件测试</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件测试" class="mobile-dropdown-title"><span class="title">软件测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/softwaretest/baseOfSoftwareTest/" class="nav-link">
  🥓软件测试基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章阅读" class="dropdown-title"><span class="title">文章阅读</span> <span class="arrow down"></span></button> <button type="button" aria-label="文章阅读" class="mobile-dropdown-title"><span class="title">文章阅读</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/interview/all.html" class="nav-link">
  💪面经汇总
</a></li><li class="dropdown-item"><!----> <a href="/blog/other/" class="nav-link">
  🧀其他阅读
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/BXuan-Yang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github🙋‍♂️
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/network/" class="nav-link">
  🍔计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog/os/" class="nav-link">
  🍟操作系统
</a></li><li class="dropdown-item"><!----> <a href="/blog/algo/" class="nav-link">
  🍕数据结构与算法
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/java/" class="nav-link router-link-active">
  🌭Java
</a></li><li class="dropdown-item"><!----> <a href="/blog/go/" class="nav-link">
  🍿Go
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件开发" class="dropdown-title"><span class="title">软件开发</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件开发" class="mobile-dropdown-title"><span class="title">软件开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          🌮数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/blog/redis/" class="nav-link">
  Redis
</a></li></ul></li><li class="dropdown-item"><h4>
          🥪开发框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/frame/spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-subitem"><a href="/blog/frame/springboot/" class="nav-link">
  SpringBoot
</a></li></ul></li><li class="dropdown-item"><h4>
          🥟架构设计
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/schemadesigner/" class="nav-link">
  设计模式
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="软件测试" class="dropdown-title"><span class="title">软件测试</span> <span class="arrow down"></span></button> <button type="button" aria-label="软件测试" class="mobile-dropdown-title"><span class="title">软件测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/softwaretest/baseOfSoftwareTest/" class="nav-link">
  🥓软件测试基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章阅读" class="dropdown-title"><span class="title">文章阅读</span> <span class="arrow down"></span></button> <button type="button" aria-label="文章阅读" class="mobile-dropdown-title"><span class="title">文章阅读</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/interview/all.html" class="nav-link">
  💪面经汇总
</a></li><li class="dropdown-item"><!----> <a href="/blog/other/" class="nav-link">
  🧀其他阅读
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/BXuan-Yang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github🙋‍♂️
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/java/JavaBase.html" class="sidebar-link">Java基础</a></li><li><a href="/blog/java/JavaGather.html" aria-current="page" class="active sidebar-link">Java 集合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#java-集合概览" class="sidebar-link">Java 集合概览</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#说说-list-set-queue-map-四者的区别" class="sidebar-link">说说 List, Set, Queue, Map 四者的区别？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#list" class="sidebar-link">List</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#set" class="sidebar-link">Set</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#queue" class="sidebar-link">Queue</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#map" class="sidebar-link">Map</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#集合和数组有什么区别" class="sidebar-link">集合和数组有什么区别？</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#list-2" class="sidebar-link">List</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#arraylist-简介" class="sidebar-link">ArrayList 简介</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#arraylist-和-vector-的区别" class="sidebar-link">Arraylist 和 Vector 的区别?</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#arraylist-与-linkedlist-区别" class="sidebar-link">Arraylist 与 LinkedList 区别?</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#arraylist-构造函数" class="sidebar-link">ArrayList 构造函数</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#arraylist-扩容机制" class="sidebar-link">ArrayList 扩容机制</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#system-arraycopy-和-arrays-copyof-方法" class="sidebar-link">System.arraycopy() 和 Arrays.copyOf()方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#queue-2" class="sidebar-link">Queue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#简单描述一下-priorityqueue" class="sidebar-link">简单描述一下 PriorityQueue？</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#map-2" class="sidebar-link">Map</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#hashmap底层实现" class="sidebar-link">HashMap底层实现？</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#hashmap的长度为什么是2的幂次方" class="sidebar-link">HashMap的长度为什么是2的幂次方？</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#hashmap和hashtable的区别" class="sidebar-link">HashMap和Hashtable的区别</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#hashmap和hashset的区别" class="sidebar-link">HashMap和HashSet的区别</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#hashmap和treemap的区别" class="sidebar-link">HashMap和TreeMap的区别</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#concurrenthashmap和hashtable有什么区别" class="sidebar-link">ConCurrentHashMap和Hashtable有什么区别？</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#concurrenthashmap的底层实现方式" class="sidebar-link">ConcurrentHashMap的底层实现方式？</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#concurrenthashmap-1-7-和-1-8-有什么不同" class="sidebar-link">ConcurrentHashMap 1.7 和 1.8 有什么不同？</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#hashmap" class="sidebar-link">HashMap</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#hashmap的内部数据结构" class="sidebar-link">HashMap的内部数据结构：</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#hashmap常见参数" class="sidebar-link">HashMap常见参数</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#concurrenthashmap" class="sidebar-link">ConcurrentHashMap</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#为什么要使用-concurrenthashmap" class="sidebar-link">为什么要使用 ConcurrentHashMap</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#concurrenthashmap初始化" class="sidebar-link">ConcurrentHashMap初始化</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#java线程安全的集合" class="sidebar-link">Java线程安全的集合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#vector" class="sidebar-link">Vector</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#hashtable" class="sidebar-link">HashTable</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#collections的包装方法" class="sidebar-link">Collections的包装方法</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#java-util-concurrent包中的集合" class="sidebar-link">java.util.concurrent包中的集合</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#相关链接" class="sidebar-link">相关链接</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#java-如何给-arraylist-排序" class="sidebar-link">Java 如何给 ArrayList 排序？</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#说一下-hashmap、hashtable-和-concurrenthashmap-的区别" class="sidebar-link">说一下 HashMap、Hashtable 和 ConcurrentHashMap 的区别</a></li><li class="sidebar-sub-header"><a href="/blog/java/JavaGather.html#为什么-hashmap-的容量一定是-2-的次方" class="sidebar-link">为什么 HashMap 的容量一定是 2 的次方？</a></li></ul></li><li><a href="/blog/java/JUC.html" class="sidebar-link">JUC</a></li><li><a href="/blog/java/JVM.html" class="sidebar-link">JVM</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java-集合"><a href="#java-集合" class="header-anchor">#</a> Java 集合</h1> <h2 id="java-集合概览"><a href="#java-集合概览" class="header-anchor">#</a> Java 集合概览</h2> <p>Java 集合， 也叫作容器，主要是由两大接口派生而来：</p> <ul><li><p>一个是 <code>Collection</code>接口，主要用于存放单一元素；</p></li> <li><p>一个是 <code>Map</code> 接口，主要用于存放 key-value 键值对。</p></li></ul> <p>对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p> <h2 id="说说-list-set-queue-map-四者的区别"><a href="#说说-list-set-queue-map-四者的区别" class="header-anchor">#</a> 说说 List, Set, Queue, Map 四者的区别？</h2> <ul><li><code>List</code>(有序的):：存储的元素是有序的、可重复的。</li> <li><code>Set</code>(不重复的)：存储的元素是无序的、不可重复的。</li> <li><code>Queue</code>(排队)：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li> <li><code>Map</code>(key - value)：使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，&quot;x&quot; 代表 key，&quot;y&quot; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul> <h3 id="list"><a href="#list" class="header-anchor">#</a> List</h3> <ul><li><code>ArrayList</code>： <code>Object[]</code> 数组</li> <li><code>Vector</code>：<code>Object[]</code> 数组</li> <li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul> <h3 id="set"><a href="#set" class="header-anchor">#</a> Set</h3> <ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li> <li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li> <li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul> <h3 id="queue"><a href="#queue" class="header-anchor">#</a> Queue</h3> <ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li> <li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <ul><li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由 数组+链表 组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（使用 “拉链法” 解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li> <li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条 <strong>双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li> <li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的，虽然线程是安全的，但是效率较低。</li> <li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li></ul> <h2 id="集合和数组有什么区别"><a href="#集合和数组有什么区别" class="header-anchor">#</a> 集合和数组有什么区别？</h2> <p>数组一旦声明长度之后就不可变，同时数组的数据类型也决定了该数组存储的数据的类型，数组存储的数据是有序的、可重复的、单一的；</p> <p>集合提高了灵活性，不仅可以用来存储不同类型的对象，还可以保存具有映射关系的数据。</p> <h2 id="list-2"><a href="#list-2" class="header-anchor">#</a> List</h2> <h3 id="arraylist-简介"><a href="#arraylist-简介" class="header-anchor">#</a> ArrayList 简介</h3> <p>ArrayList 的底层是<strong>数组队列</strong>，相当于动态数组。</p> <p>与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用 <code>ensureCapacity</code> 操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230315090802100.png" alt="image-20230315090802100"></p> <p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230315090704667.png" alt="image-20230315090704667"></p> <ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li> <li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li> <li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li></ul> <h3 id="arraylist-和-vector-的区别"><a href="#arraylist-和-vector-的区别" class="header-anchor">#</a> Arraylist 和 Vector 的区别?</h3> <ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 ；</li> <li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[]</code>存储，线程安全的。</li></ul> <h3 id="arraylist-与-linkedlist-区别"><a href="#arraylist-与-linkedlist-区别" class="header-anchor">#</a> Arraylist 与 LinkedList 区别?</h3> <ol><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li> <li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）</li> <li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li> <li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li> <li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ol> <h3 id="arraylist-构造函数"><a href="#arraylist-构造函数" class="header-anchor">#</a> ArrayList 构造函数</h3> <div class="language-java extra-class"><pre class="language-java"><code>   <span class="token comment">/**
     * 默认初始容量大小
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_CAPACITY</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>


    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 带初始容量参数的构造函数。（用户自己指定容量）
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//初始容量大于0</span>
            <span class="token comment">//创建initialCapacity大小的数组</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//初始容量等于0</span>
            <span class="token comment">//创建空数组</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//初始容量小于0，抛出异常</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Illegal Capacity: &quot;</span><span class="token operator">+</span>
                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


   <span class="token comment">/**
    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回
    *如果指定的集合为null，throws NullPointerException。
    */</span>
     <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
                elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// replace with empty array.</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


</code></pre></div><p>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</p> <blockquote><p>补充：JDK 6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData</p></blockquote> <h3 id="arraylist-扩容机制"><a href="#arraylist-扩容机制" class="header-anchor">#</a> ArrayList 扩容机制</h3> <p>初始创建的时候创建的是一个空的数组，等到第一个元素开始插入的时候才会对数组进行初始化，初始化容量为10。以后的扩容都是 <strong>1.5倍</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里区分一下 length、length()、size()：</p> <ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度就会用到了 length 这个属性.</li> <li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li> <li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看。</li></ul> <h3 id="system-arraycopy-和-arrays-copyof-方法"><a href="#system-arraycopy-和-arrays-copyof-方法" class="header-anchor">#</a> System.arraycopy() 和 Arrays.copyOf()方法</h3> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span>
    <span class="token comment">/**
    *   复制数组
    * @param src 源数组
    * @param srcPos 源数组中的起始位置
    * @param dest 目标数组
    * @param destPos 目标数组中的起始位置
    * @param length 要复制的数组元素的数量
    */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span><span class="token class-name">Object</span> src<span class="token punctuation">,</span>  <span class="token keyword">int</span>  srcPos<span class="token punctuation">,</span>
                                        <span class="token class-name">Object</span> dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span>
                                        <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> newLength<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token comment">// 申请一个新的数组</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>newLength<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> copy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
                         <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span>length<span class="token punctuation">,</span> newLength<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> copy<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre></div><h2 id="queue-2"><a href="#queue-2" class="header-anchor">#</a> Queue</h2> <h3 id="简单描述一下-priorityqueue"><a href="#简单描述一下-priorityqueue" class="header-anchor">#</a> 简单描述一下 PriorityQueue？</h3> <p>PriorityQueue 是在 JDK 1.5 被引入的，它与 Queue 的区别在于元素出队顺序都是与优先级相关的，即总是优先级最高的元素先出队。</p> <ul><li>PriorityQueue 利用了 <strong>二叉堆</strong> 的数据结构来实现，底层使用可变长的数组来存储数据；</li> <li>PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶的元素；</li> <li>PriorityQueue 是非线程安全的，并且不支持 null 和 non-comparable 的对象</li> <li>PriorityQueue 默认是小顶堆，但是可以接收一个 Compare 作为构造参数，从而来自定义元素优先级的先后</li></ul> <h2 id="map-2"><a href="#map-2" class="header-anchor">#</a> Map</h2> <h3 id="hashmap底层实现"><a href="#hashmap底层实现" class="header-anchor">#</a> HashMap底层实现？</h3> <h4 id="在-jdk1-8-之前"><a href="#在-jdk1-8-之前" class="header-anchor">#</a> 在 JDK1.8 之前</h4> <p>HashMap 的底层是 数组＋链表，也就是链表散列。Hash 通过 key 的 hashcode 经过扰动函数之后得到 hash 值，然后通过 (n -1)&amp;hash，判断当前元素存放的位置。</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230419102040230.png" alt="image-20230419102040230"></p> <ul><li>如果当前位置不存在元素，直接进行存放。</li> <li>如果当前位置存在元素，先判断该元素和将要存入的元素是否一致，如果一致则覆盖；如果不一致，需要使用拉链法解决冲突。</li></ul> <p><strong>扰动函数（hash方法）：</strong></p> <p>JDK 1.7</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This function ensures that hashCodes that differ only by</span>
    <span class="token comment">// constant multiples at each bit position have a bounded</span>
    <span class="token comment">// number of collisions (approximately 8 at default load factor).</span>

    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>JDK 1.8</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> h<span class="token punctuation">;</span>
	<span class="token comment">// key.hashCode()：返回散列值也就是hashcode</span>
    <span class="token comment">// ^ ：按位异或</span>
    <span class="token comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>什么是<strong>拉链法</strong>？</p> <p>拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p> <h4 id="在jdk-1-8之后"><a href="#在jdk-1-8之后" class="header-anchor">#</a> 在JDK 1.8之后</h4> <p>解决哈希冲突有了变化，当链表长度大于阈值（<a href="https://blog.csdn.net/Liu_Wd/article/details/108052428" target="_blank" rel="noopener noreferrer">默认阈值为8<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>），会将链表转换成红黑树，以减少搜索时间</p> <p>（注意：这里将链表转换成红黑树时会进行判断，如果当前数组的长度小于64的话，首先选择对数组进行扩容（变成原来的2倍），而不是直接转换成红黑树）</p> <h3 id="hashmap的长度为什么是2的幂次方"><a href="#hashmap的长度为什么是2的幂次方" class="header-anchor">#</a> HashMap的长度为什么是2的幂次方？</h3> <p>这是为了让HashMap存取高效，尽量减少碰撞，也就是要将数据分配均匀。</p> <p>**取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。**并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方</strong></p> <h3 id="hashmap和hashtable的区别"><a href="#hashmap和hashtable的区别" class="header-anchor">#</a> HashMap和Hashtable的区别</h3> <ul><li><p><strong>线程是否安全</strong>：Hashtable 内部的方法基本是经过synchornized 修饰的，所以 Hashtable 是线程安全的。但是 HashMap 是非线程安全的。</p></li> <li><p><strong>效率</strong>：因为线程安全的问题，HashMap 要比Hashtable 效率更高一点。所以在基本开发中Hashtable很少使用</p></li> <li><p><strong>对于 null key 和 null value 的支持</strong>：</p> <ul><li>HashMap 可以存储 null 的 key 和 value，但是作为 key 为 null 的只能有一个，但是 value 可以有多个。</li> <li>Hashtable 不允许有 null 的 key 和 value 出现，否则会报 NullPointerException。</li></ul></li> <li><p><strong>初始化容量和每次扩充容量的大小不同</strong>：如果在创建时不指定初始值，Hashtable 默认的初始大小为11，每次扩容，容量变成原来的 2n+1。HashMap 默认的容量初始值为 16，每次扩容，容量变成原来的2倍。如果在创建时指定了初始值，那么 Hashtable 会使用制定的容量，而 HashMap 会将其自动向上扩容到2的幂次数倍。</p></li> <li><p><strong>底层数据结构</strong>：JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</p></li></ul> <h3 id="hashmap和hashset的区别"><a href="#hashmap和hashset的区别" class="header-anchor">#</a> HashMap和HashSet的区别</h3> <p>HashSet是基于HashMap实现的，所以只有 writeObject()、readObject()、clone()是HashSet自己实现的之外，其他的都是直接调用HashMap中的方法。</p> <table><thead><tr><th style="text-align:center;"><code>HashMap</code></th> <th style="text-align:center;"><code>HashSet</code></th></tr></thead> <tbody><tr><td style="text-align:center;">实现了 <code>Map</code> 接口</td> <td style="text-align:center;">实现 <code>Set</code> 接口</td></tr> <tr><td style="text-align:center;">存储键值对</td> <td style="text-align:center;">仅存储对象</td></tr> <tr><td style="text-align:center;">调用 <code>put()</code>向 map 中添加元素</td> <td style="text-align:center;">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr> <tr><td style="text-align:center;"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td> <td style="text-align:center;"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table> <h3 id="hashmap和treemap的区别"><a href="#hashmap和treemap的区别" class="header-anchor">#</a> HashMap和TreeMap的区别</h3> <p>HashMap 和 TreeMap 都是继承自 AbstractMap，但是 TreeMap 还实现了 NavigableMap 和 SortedMap 接口。</p> <ul><li>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</li> <li>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">TreeMap</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @Author: BXuan
 * @Date: 2023/02/24/ 13:47
 * @description TreeMap测试类
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Person</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> res <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> p2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>person1<span class="token punctuation">,</span> <span class="token string">&quot;person1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>person2<span class="token punctuation">,</span> <span class="token string">&quot;person2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>person3<span class="token punctuation">,</span> <span class="token string">&quot;person3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>person4<span class="token punctuation">,</span> <span class="token string">&quot;person4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>pp <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="concurrenthashmap和hashtable有什么区别"><a href="#concurrenthashmap和hashtable有什么区别" class="header-anchor">#</a> ConCurrentHashMap和Hashtable有什么区别？</h3> <ul><li><strong>底层数据结构</strong>：JDK1.7的 ConCurrentHashMap 底层采用 分段的数组＋链表 实现，JDK1.8采用的数据结构跟 HashMap 1.8的结构一样，数组 + 链表 / 数组 + 链表 + 红黑树；Hashtable采用的是数组链表的形式，数组是 HashMap 的主体，链表则是为了解决哈希冲突而存在。</li> <li><strong>实现线程安全的方式</strong> <ul><li>在 <strong>JDK1.7</strong> 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li> <li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li> <li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul></li></ul> <h3 id="concurrenthashmap的底层实现方式"><a href="#concurrenthashmap的底层实现方式" class="header-anchor">#</a> ConcurrentHashMap的底层实现方式？</h3> <h4 id="jdk1-8-之前"><a href="#jdk1-8-之前" class="header-anchor">#</a> <strong>JDK1.8 之前</strong></h4> <p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p> <p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p> <p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p> <p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p> <h4 id="jdk1-8-之后"><a href="#jdk1-8-之后" class="header-anchor">#</a> JDK1.8 之后</h4> <p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（默认为 8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p> <p>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p> <h3 id="concurrenthashmap-1-7-和-1-8-有什么不同"><a href="#concurrenthashmap-1-7-和-1-8-有什么不同" class="header-anchor">#</a> ConcurrentHashMap 1.7 和 1.8 有什么不同？</h3> <ul><li><strong>线程安全实现方式</strong> ：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li> <li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li> <li><strong>并发度</strong> ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul> <h2 id="hashmap"><a href="#hashmap" class="header-anchor">#</a> HashMap</h2> <p>HashMap 基于键的 HashCode 值的唯一性，同时基于键的 HashCode 值进行数据的存取，因此可以快速地更新和查询数据，但是<a href="https://blog.csdn.net/weixin_59248227/article/details/123943771" target="_blank" rel="noopener noreferrer">每次遍历的顺序无法保证相同<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。（LinkedHashMap √）</p> <p>HashMap 的 key 和 value 允许为 null。（<strong>HashMap 可以存储一个 Key 为 null，多个 value 为 null 的元素，但是 Hashtable 却不可以存储任何为 null 的值（目的是为了保证线程安全</strong>）</p> <p>HashMap 是线程不安全的，在同一个时刻要是有多个线程同时对 HashMap 进行写的操作，可能会导致成环的操作。如果必须满足线程安全的操作，可以使用 Collections.synchronizaedMap() / ConCurrentHashMap 使 HashMap 变成线程安全。</p> <h3 id="hashmap的内部数据结构"><a href="#hashmap的内部数据结构" class="header-anchor">#</a> HashMap的内部数据结构：</h3> <p>Entry包含：key、val、next、hash</p> <p>JDK 1.7：数组＋链表( O(n) )</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230307004407944.png" alt="image-20230307004407944"></p> <p>JDK 1.8：数组＋链表＋红黑树（ O(logn) ）</p> <p><img src="https://cdn.jsdelivr.net/gh/BXuan-Yang/blogImage/img/image-20230307004421031.png" alt="image-20230307004421031"></p> <h3 id="hashmap常见参数"><a href="#hashmap常见参数" class="header-anchor">#</a> HashMap常见参数</h3> <p>capacity：当前数组的容量，默认为16，可以扩容，*2，所以该容量始终为2n次方</p> <p>loadFactor：负载因子，始终为0.75</p> <p>threshold：扩容阈值（就是达到需要再次扩容的点），capacity * loadFactor</p> <h2 id="concurrenthashmap"><a href="#concurrenthashmap" class="header-anchor">#</a> ConcurrentHashMap</h2> <p>ConcurrentHashMap 是线程安全并且高效的 HashMap</p> <h3 id="为什么要使用-concurrenthashmap"><a href="#为什么要使用-concurrenthashmap" class="header-anchor">#</a> 为什么要使用 ConcurrentHashMap</h3> <p>在并发编程中，<strong>使用线程不安全的 HashMap 可能导致程序的死循环，然后使用线程安全的 HashTable效率太低</strong>，所以基于以上的两个原因，在常见的并发编程中就有了 ConcurrentHashMap的登场机会</p> <ul><li>线程不安全的 HashMap</li></ul> <p>在多线程的环境下，使用 HashMap 进行 put 操作可能会引起死循环，导致CPU利用率达100%。这是因为HashMap在并发执行Put操作的时候会使得其中的Entry链表形成环形数据结构。一旦形成环形的数据结构，Entry的next指针永远也不会为空，因此陷入死循环。</p> <ul><li>效率低下的 HashTable</li></ul> <p>HashTable使用Synchronized来对线程进行加锁，保证线程安全。</p> <ul><li>ConcurrentHashMap</li></ul> <p>HashTable在竞争激烈的状态下显示出效率低下的原因是因为访0问HashTable的是同一把锁。</p> <p>ConcurrentHashMap这里使用的就是锁分段技术，将数据分成一段一段地存储，然后再给每个数据添加一把锁。</p> <p>ConcurrentHashMap是由segment数组和HashEntry数组组成的。Segment继承了ReentrantLock，是一把可重入锁。每一个ConcurrentHashMap里面有一个segment数组，segment的结构和HashMap类似，是一种数组和链表的结构，一个Segment里面包含一个HashEntry数组，每个HashEntry是一个链表结构的元素。每个segment里面守护者HashEntry数组中的元素，当要对HashEntry数组里面的数据进行修改时，就需要获得相对应的segment的锁。</p> <h3 id="concurrenthashmap初始化"><a href="#concurrenthashmap初始化" class="header-anchor">#</a> ConcurrentHashMap初始化</h3> <p>ConcurrentHashMap 在进行初始化的时候，会首先判断哈希表是否已经初始化，如果没有，则首先对哈希表进行初始化。</p> <h2 id="java线程安全的集合"><a href="#java线程安全的集合" class="header-anchor">#</a> Java线程安全的集合</h2> <h3 id="vector"><a href="#vector" class="header-anchor">#</a> Vector</h3> <p>Vector和ArrayList类似，是长度可变的数组，与ArrayList不同的是，Vector是线程安全的，它给几乎所有的public方法都加上了synchronized关键字。由于加锁导致性能降低，在不需要并发访问同一对象时，这种强制性的同步机制就显得多余，所以现在Vector已被弃用</p> <h3 id="hashtable"><a href="#hashtable" class="header-anchor">#</a> HashTable</h3> <p>HashTable和HashMap类似，不同点是HashTable是线程安全的，它给几乎所有public方法都加上了synchronized关键字，还有一个不同点是HashTable的K，V都不能是null，但HashMap可以，它现在也因为性能原因被弃用了</p> <h3 id="collections的包装方法"><a href="#collections的包装方法" class="header-anchor">#</a> Collections的包装方法</h3> <p>Vector和HashTable被弃用后，它们被ArrayList和HashMap代替，但它们不是线程安全的，所以Collections工具类中提供了相应的包装方法把它们包装成线程安全的集合</p> <p>Collections针对每种集合都声明了一个线程安全的包装类，在原集合的基础上添加了锁对象，集合中的每个方法都通过这个锁对象实现同步</p> <h3 id="java-util-concurrent包中的集合"><a href="#java-util-concurrent包中的集合" class="header-anchor">#</a> java.util.concurrent包中的集合</h3> <ul><li>ConcurrentHashMap</li></ul> <p>ConcurrentHashMap和HashTable都是线程安全的集合，它们的不同主要是加锁粒度上的不同。HashTable的加锁方法是给每个方法加上synchronized关键字，这样锁住的是整个Table对象。</p> <ul><li><p>CopyOnWriteArrayList</p></li> <li><p>CopyOnWriteArraySet</p></li> <li><p>除此之外还有ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque等，至于为什么没有ConcurrentArrayList，原因是无法设计一个通用的而且可以规避ArrayList的并发瓶颈的线程安全的集合类，只能锁住整个list，这用Collections里的包装类就能办到</p></li></ul> <h3 id="相关链接"><a href="#相关链接" class="header-anchor">#</a> 相关链接</h3> <p><a href="https://blog.csdn.net/lixiaobuaa/article/details/79689338" target="_blank" rel="noopener noreferrer">Java线程安全的集合详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="java-如何给-arraylist-排序"><a href="#java-如何给-arraylist-排序" class="header-anchor">#</a> Java 如何给 ArrayList 排序？</h2> <p>ArrayList 的排序可以借助 Collections 工具类的 sort(List list) 以及重载的 sort(List list, Comparator&lt;? super T&gt; c) 方法；</p> <p>其中要想使用 sort(List list) 方法进行排序集合元素必须实现 comparable 接口中的 compareTo 方法；使用重载的 sort(List list, Comparator&lt;? super T&gt; c) 方法则必须传入一个自定义构造器，可以使用匿名内部类的方法传入构造器。</p> <ul><li>如果集元素类型是8大基本类型的包装类，或者是 String 类源码中这些类已经实现了 Comparable 接口。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>bxuan<span class="token punctuation">.</span>studydemo</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @Author: BXuan
 * @Date: 2023/03/22/ 9:16
 * @description 测试类
 */</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayListTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> o1 <span class="token operator">&lt;</span> o2 <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>o1 <span class="token operator">==</span> o2<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>对于对象的排序，如果想要使用 sort(List list) 方法给集合排序，集合元素必须实现 comparable 接口中的 compareTo 方法</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>bxuan<span class="token punctuation">.</span>studydemo<span class="token punctuation">.</span></span><span class="token class-name">ArrayListSortDemo</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @Author: BXuan
 * @Date: 2023/03/22/ 9:26
 * @description
 */</span>

<span class="token annotation punctuation">@Data</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> age<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Person</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>bxuan<span class="token punctuation">.</span>studydemo<span class="token punctuation">.</span></span><span class="token class-name">ArrayListSortDemo</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Collections</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @Author: BXuan
 * @Date: 2023/03/22/ 9:28
 * @description
 */</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">,</span> <span class="token string">&quot;Bxuan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">&quot;Bxuan1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">&quot;Bxuan2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">,</span> <span class="token string">&quot;Bxuan3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person3<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;未排序之前&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;排序之后&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="说一下-hashmap、hashtable-和-concurrenthashmap-的区别"><a href="#说一下-hashmap、hashtable-和-concurrenthashmap-的区别" class="header-anchor">#</a> 说一下 HashMap、Hashtable 和 ConcurrentHashMap 的区别</h2> <ul><li>HashMap 线程不安全，效率高一点，可以存储 null 的 key 和 value，null 的key 只能有一个，null 的value 可以有多个。默认初始容量为 16，每次扩充为原来的 2 倍。创建时如果指定了初始容量，则自动扩充为 2 的幂次方大小。底层数据结构为 数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于 64，如果小于 64，则扩充数组，反之将链表转化为红黑树，以减少搜索的时间；</li> <li>HashTable 线程安全，效率较低，因为内部方法都是经过 synchronized 修饰，不可以有 null 的 key 和 value。默认初始容量为 11，每次扩容为原来的 2n+1。创建时如果给定了初始容量，会直接使用给定的大小。底层的数据结构为 数组+链表。基本被淘汰，不适用，要保证线程安全可以使用 ConcurrentHashMap；</li> <li>ConcurrentHashMap 是 Java 中一个线程安全的哈希表实现的，它可以在多线程环境下并发地进行读写操作，而不需要像传统的 HashTable 那样在读写时枷锁。ConcurrentHashMap 的实现原理主要基于分段锁和 CAS 操作，它将整个哈希表分成多段（Segment），每个 Segment 都类似于一个小的 HashMap，它可以拥有自己的数组和一个独立的锁。在 ConcurrentHashMap 中，读操作不需要锁，可以直接对 Segment 进行读取，而写操作只需要锁定对应的 Segment，而不是整个哈希表，这样可以大大提高并发性能。</li></ul> <h2 id="为什么-hashmap-的容量一定是-2-的次方"><a href="#为什么-hashmap-的容量一定是-2-的次方" class="header-anchor">#</a> 为什么 HashMap 的容量一定是 2 的次方？</h2> <p>​		在 HashMap 中，元素的存储位置是根据键的哈希值来确定的。当需要存储一个键值对时，HashMap 会根据键的哈希值计算出一个索引位置，然后将该键值对存储在该索引位置上。</p> <p>​		选择容量为 2 的次方，主要是为了利用位运算来代替取模运算，以提高计算效率。在 HashMap 内部，计算索引位置时，使用的是 (n-1)&amp;hash 的位运算方式，其中 n 为 HashMap 的容量，hash 为键的哈希值。由于容量为 2 的次方，所以 (n-1) 的二进制表示形式全是 1，这样就可以通过位运算取哈希值的低位，避免了昂贵的取模运算。</p> <p>​		此外，选择容量为 2 的次方还可以减少哈希冲突的概率，当容量为 2 的次方时，哈希值的低位在计算索引位置时会更加均匀地分布在 HashMap 的桶中，减少哈希冲突的可能性，提高 HashMap 的性能。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/java/JavaBase.html" class="prev">
        Java基础
      </a></span> <span class="next"><a href="/blog/java/JUC.html">
        JUC
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.c7952645.js" defer></script><script src="/assets/js/2.53ba99d7.js" defer></script><script src="/assets/js/50.323a9f2b.js" defer></script>
  </body>
</html>
